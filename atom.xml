<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sheepice的博客</title>
  
  <subtitle>感谢各位家人的访问，希望能跟大家成为朋友</subtitle>
  <link href="https://sample.com/atom.xml" rel="self"/>
  
  <link href="https://sample.com/"/>
  <updated>2022-07-30T04:37:53.114Z</updated>
  <id>https://sample.com/</id>
  
  <author>
    <name>sheepice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图论之Kruskal</title>
    <link href="https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BKruskal/"/>
    <id>https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BKruskal/</id>
    <published>2022-07-28T01:29:15.000Z</published>
    <updated>2022-07-30T04:37:53.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于最小生成树的问题来说的话，我们可以发现如果直接利用我们的dijkstra算法，每次去遍历一个点，然后通过一个点的话去更新其他的所有边，在这样的过程中，换一个理解的方式来看的话，不过就是把我们所有的最短的边连起来，也就是，我们尝试将所有有关系的点通过最短的概念，连接起来，然后能够通过这样的方式，在集合内部已经连好的点，就不会在继续连，也就是我们一旦选定两个点进行边的连接的话，我们一定会选最短的，然后最后我们判断一下是否所有的点到最后会被连接到一个集合之中就好了。有了这个思路，我们其实就可以利用今天所讲到的Kruskal算法进行最短边的尝试，知道我们能够去让所有点入集合。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①Kruskal算法模板-ACwing-859"><a href="#①Kruskal算法模板-ACwing-859" class="headerlink" title="①Kruskal算法模板(ACwing.859)"></a>①Kruskal算法模板(ACwing.859)</h3><p><img src="https://img-blog.csdnimg.cn/643f49b0432a4eb7be8dd34de80e15f1.png" alt="Kruskal最小生成树"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度:</code>  $O(mlogn)$</p><p><code>适用场景:</code>  点数和边数都比较多的最小生成树的问题，应用面广于之前所说的Prim算法。</p><p><code>思路: </code>  将所有的边进行排序，贪心的从最短的边开始遍历，一旦发现我们遍历的那个边能够加到我们的集合中的话，我们就可以加到我们的集合当中去的话就加入。那么判断这个边是否能够加入我们之前的集合当中去，无非就是看一下这个边加入集合后，会不会破坏我们的生成树的条件，而我们知道，一棵树只有一个根节点，我们只要满足每次加入的时候保证根节点只有一个就好了，这里就可以用并查集进行优化，最后我们只要判断一下是否所有边的数量为n - 1就好了！</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 1e5 + 5, M &#x3D; 2 * N + 10;&#x2F;&#x2F;因为是遍历所有的边，用结构体装一下就好了struct Edge &#123;    &#x2F;&#x2F;代表a, b有一条权值为c的边    int a, b, c;    &#x2F;&#x2F;为了按照边从小到大排序的话，需要重载一下小于号    &#x2F;&#x2F;这里的写法主要是学比如写的，具体其实两个const和一个&amp;不要也可以的    bool operator&lt; (const Edge&amp; W) const &#123;        return c &lt; W.c;    &#125;&#125;edges[M];&#x2F;&#x2F;并查集的pre数组int pre[N];&#x2F;&#x2F;并查集加路径压缩的函数写法int find(int x) &#123;    if(x !&#x3D; pre[x]) pre[x] &#x3D; find(pre[x]);    return pre[x];&#125;int main() &#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    &#x2F;&#x2F;初始化一下我们的并查集的点    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) pre[i] &#x3D; i;        for(int i &#x3D; 0; i &lt; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        edges[i] &#x3D; &#123;a, b, c&#125;;    &#125;        sort(edges, edges + m);    &#x2F;&#x2F;记录加的边,和最终的结果    int cnt &#x3D; 0, ans &#x3D; 0;    &#x2F;&#x2F;遍历一下所有的边    for(int i &#x3D; 0; i &lt; m; i ++ ) &#123;        auto t &#x3D; edges[i];        int f1 &#x3D; find(t.a), f2 &#x3D; find(t.b);                if(f1 !&#x3D; f2) &#123;            &#x2F;&#x2F;可以把边加入             cnt++;            &#x2F;&#x2F;把两个不相连的集合连起来            pre[f1] &#x3D; f2;            ans +&#x3D; t.c;            if(cnt &#x3D;&#x3D; n - 1) break;        &#125;    &#125;        if(cnt !&#x3D; n - 1) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; ans &lt;&lt; endl;        &#x2F;&#x2F; cout &lt;&lt; cnt &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②未完待续"><a href="#②未完待续" class="headerlink" title="②未完待续"></a>②未完待续</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;对于最小生成树的问题来说的话，我们可以发现如果直接利用我们的dijkstra算法，每次去遍历一个点，然后通过一个点的话去更新</summary>
      
    
    
    
    <category term="图论专题篇" scheme="https://sample.com/categories/%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图论" scheme="https://sample.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论之Prim</title>
    <link href="https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BPrim/"/>
    <id>https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BPrim/</id>
    <published>2022-07-28T01:28:49.000Z</published>
    <updated>2022-07-30T03:15:15.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>此篇主要针对图论中的求最小生成树的一种算法Prim算法，这个算法其实整体的结构和dijkstra算法是相似的，所以整体的思路也和dijkstra算法有异曲同工之妙。首先，讲一下自己对最小生成树这个概念的理解。</p><p><code>生成树:</code> 包含图中所有结点，且整个结点形成的一张图中不含有任何环，一旦再多连接两个结点形成一条边，一定会生成一个环的一个结构图。</p><p><code>最小生成树:</code>  在一个图中找到的所有生成树中，所有边加起来的权值最小的那一棵生成树是一颗最小生成树。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①Prim算法模板-ACwing-858"><a href="#①Prim算法模板-ACwing-858" class="headerlink" title="①Prim算法模板(ACwing.858)"></a>①Prim算法模板(ACwing.858)</h3><p><img src="https://img-blog.csdnimg.cn/26e9b03e0c97421a80f76f2559a2a883.png" alt="Prim求最小生成树"></p><p><code>时间复杂度:</code>  $O(n^2)$</p><p><code>适用场景:</code>  点数少，边数多的最小生成树求解。</p><p><code>思路:</code>  和dijkstra算法结构差不多，但是此时定义的dist数组指的是，此时计算的某个点，到我们此时求到的生成树整个集合中的一个最小值距离。也就是说我们在推导dist数组的时候，同样每次选取一个距离集合最短的那一条边进行一个延申，不断延申的时候求出某个点到整个已经求出的部分最小生成树的一个距离最小值。</p><p><code>更新过程:</code></p><p><img src="https://img-blog.csdnimg.cn/6d7826cd1056488fa903c9a04092b223.jpeg"></p><p><code>紫色</code> <font color="purple">当前利用的更新点</font></p><p><code>蓝色</code><font color="blue">当前更新完后，某个点距离整个集合的最小距离</font></p><p><code>红色</code><font color="red">两个结点边的长度</font></p><p>上图最终的最小生成树就为3！</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 505, INF &#x3D; 0x3f3f3f3f;int g[N][N], dist[N];bool st[N];int n, m;int prim() &#123;    int res &#x3D; 0;    dist[1] &#x3D; 0;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        int t &#x3D; -1;        &#x2F;&#x2F;寻找离集合最近的那一条边                for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t])) &#123;                t &#x3D; j;            &#125;        &#125;     &#x2F;&#x2F;如果dist[t] &#x3D; INF代表没有边连向集合，直接返回            if(dist[t] &#x3D;&#x3D; INF) return INF;        st[t] &#x3D; true;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            dist[j] &#x3D; min(dist[j], g[t][j]);        &#125;                res +&#x3D; dist[t];    &#125;        return res;&#125;int main() &#123;    memset(dist, 0x3f, sizeof(dist));    memset(st, 0, sizeof st);    memset(g, 0x3f, sizeof g);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        &#x2F;&#x2F;先去掉自环        &#x2F;&#x2F;注意这种都是无向图，所以两个边都需要赋值        if(a !&#x3D; b) g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b], c);    &#125;        int ans &#x3D; prim();        if(ans &#x3D;&#x3D; INF) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;此篇主要针对图论中的求最小生成树的一种算法Prim算法，这个算法其实整体的结构和dijkstra算法是相似的，所以整体的思路</summary>
      
    
    
    
    <category term="图论专题篇" scheme="https://sample.com/categories/%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图论" scheme="https://sample.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论之Floyd</title>
    <link href="https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd/"/>
    <id>https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd/</id>
    <published>2022-07-28T01:28:34.000Z</published>
    <updated>2022-07-30T04:42:42.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在之前的图论算法中有说过基本都是从一个原点出发，然后定义其他点到原点的一个距离最小值。那假设这个原点都是不固定的，而题目刚好要求去求任意两个点之间的最小距离的话，那么这个时候暴力美学就非常凸显出其独有的重要性了。那么本章总结的Floyd算法，就是能够解决这样的问题。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①Floyd算法模板-ACwing-854"><a href="#①Floyd算法模板-ACwing-854" class="headerlink" title="①Floyd算法模板(ACwing.854)"></a>①Floyd算法模板(ACwing.854)</h3><p><img src="https://img-blog.csdnimg.cn/ce6634a7cd4f47aabbb5e8d03d15f85b.png" alt="Floyd求最短路"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度:</code>  $O(n^3)$</p><p><code>适用场景:</code>  当点的数量很少，而边的数量较多的稠密图，且题目要求求的是任意两点之间的最短距离的时候，就可以利用此算法进行求解。</p><p><code>思路:</code>  由于是稠密图，可以用邻接矩阵来存图，对于每个邻接矩阵，都是会有$g[a][b]$表示a到b的距离，那么一旦a到b之间这条路径有其他点k的话，那么就可以考虑用k这个点去尝试更新一下$g[a][b]$之间的距离，也就是:<br>$$<br>g[a][b] &#x3D; min(g[a][b], g[a][k] + g[k][b])<br>$$<br>这样的话，我们利用三层循环，内两层循环去循环a,b两个点，外一层循环，循环k这个点这样就可以不重不漏的列举每个路径的可能性，对于无边的边，初始化为正无穷，就可以实现更新了。</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int INF &#x3D; 1e9;const int N &#x3D; 205;int n, m, k;int grid[N][N];void floyd() &#123;    for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;                grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    &#x2F;&#x2F;初始化    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;            if(i &#x3D;&#x3D; j) grid[i][j] &#x3D; 0;            else grid[i][j] &#x3D; INF;        &#125;    &#125;        for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;                grid[a][b] &#x3D; min(grid[a][b], c);    &#125;        floyd();        while(k -- ) &#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;                if(grid[x][y] &gt; INF &#x2F; 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;        else cout &lt;&lt; grid[x][y] &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p><font color="blue">循环的顺序能不能变？</font></p><p>在上面的代码，我们可以看到，循环的顺序是先循环k，再循坏i，j。也就如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void floyd() &#123;    for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;                grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果把k这一层放到最内层，如下的话可以吗？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void floyd() &#123;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;                grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案是不行的！</p><p>首先举个例子，假设有一组样例是这样的</p><blockquote><p>10 4 1</p><p>2 8 1</p><p>8 9 8</p><p>9 1 10</p><p>1 10 0</p><p>2 10</p></blockquote><p>上面的样例，显然从2到10的距离最短是19，但是如果按照第二种方式，最后得到的结果会是impossible的，为什么呢？<font color="red">从循环顺序来看，当我们要求$ g[2][10]$的时候就需要求$g[2][1]$,而在求$g[2][1]$的时候，我们发现$g[2][1]是通过g[2][9]和g[9][1]得到的 $，而如果循环把k放到内层，那么$g[2][9]$会在i&#x3D;2，j&#x3D;9的时候才能推出来，这样就导致$g[2][1]$不能顺利得到正确结果，也就是最后得不到一条2到10的最短距离。</font></p><p>其次我们应该用动态规划的思想去理解Floyd的算法。我们可以让这个算法的动态规划数组看成$f(k, i, j)$代表以前k个点为媒介的时候，从i到j这个点的最短距离。</p><p>利用dp分析的方法有下面这个图</p><p><img src="https://img-blog.csdnimg.cn/6cdceff2fc274a91b8618651e3500d49.png" alt="闫式dp分析"></p><p>动态规划转移方程如下:<br>$$<br>f[k][i][j] &#x3D; min(f[k - 1][i][j],f[k - 1][i][k] + f[k-1][k][j])<br>$$<br>也就是说，我们当前第k层的状态应该根据上一层已经推出的k-1层来进行运算，所以k这一层循环应当放在最外面。</p><p>而由于上一层推出来的一个数据本身就可以用来推导下一层，就和背包dp问题的感觉一样，就可以优化一层，利用滚动数组的感觉，变成二维的dp解法，也就是我们的解法一。</p><h3 id="②未完待续"><a href="#②未完待续" class="headerlink" title="②未完待续"></a>②未完待续</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;在之前的图论算法中有说过基本都是从一个原点出发，然后定义其他点到原点的一个距离最小值。那假设这个原点都是不固定的，而题目刚好</summary>
      
    
    
    
    <category term="图论专题篇" scheme="https://sample.com/categories/%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图论" scheme="https://sample.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论之spfa</title>
    <link href="https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8Bspfa/"/>
    <id>https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8Bspfa/</id>
    <published>2022-07-28T01:28:17.000Z</published>
    <updated>2022-07-30T04:08:15.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于之前有写到的Dijkstra算法，我们发现他只能用来计算边的权值为正的情况，这其实也就是为什么我们需要开一个st数组，对于一个已经被更新过的点来说，他一旦用于更新其他点的时候，我们就不需要再考虑再利用这个点再次更新其他的点。</p><p><font color="blue">但是呢，如果点之间的边是负值的时候，就必须去遍历一下所有的边，因为存在负值的时候，负数加正数是会把距离缩短的，所以呢就可以利用遍历所有边的办法去更新点到原点的距离。</font>这就需要用到后续要说的spfa算法，那么在讲这个算法之前，需要了解bellman-ford算法，会先利用这个算法进行一个引入。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①bellman-ford-ACwing-853"><a href="#①bellman-ford-ACwing-853" class="headerlink" title="①bellman-ford(ACwing.853)"></a>①bellman-ford(ACwing.853)</h3><p><img src="https://img-blog.csdnimg.cn/dbffd9a6fb0b44748a688cb55b6fdd9e.png" alt="边权受限制的最短路"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度：</code>  $O(mn)$</p><p><code>适用场景：</code>  这个算法可以看到，时间复杂度比较高，所以mn的值要落在$1e7-1e8$之间才能满足不超时，另外，由于这个算法，是从原点出发，外层循环多少次，内层就需要更新多少次边。这个实际含义就是，外层循环多少次，就代表：<font color="red">从原点出发了多少条边</font>，所以能够计算，走多少条边到终点的一个最短距离，<font color="red">注意这个最短距离并不一定是整个图看上去的最短，而是满足了走k条边的最短！</font></p><p><code>思路：</code>  如果题目规定走k条边，那么按照上述分析，外层循环k次代表走k条边的更新情况，内部循环，更新每一条边，一旦能够更新就更新，不能更新的话，距离保证不变。<font color="red">这里注意由于内层循环更新的是所有的边，所以是有可能发生应该只再原本的基础上衍生1条边，但是衍生出去了2条边。所以需要一个回溯的数组，保存一下上一次更新好的dist数组。而这个串联反应可以举个例子，如下：</font></p><p><img src="https://img-blog.csdnimg.cn/8148d0f1d76e4a7d95599783af89bef6.png"></p><p>假设这个图，如果我们的k只给1的话，那么从1-&gt;3的距离最短应该为3，而不是1+1&#x3D;2。假设我们在更新的时候，还是像之前dijkstra的更新方式，利用dist数组更新的话，那么在仅有的一次循环里面，1-&gt;2这条边的距离首先会被更新为1，那么在2-&gt;3这条边就会按照dist[2] &#x3D; 1的这个数组更新dist[3],让dist[3]变成2，那么就和我们最终得到的答案3就是不同的。</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 505, M &#x3D; 10050;&#x2F;&#x2F;因为要遍历所有边，所以结构体存图struct Edge &#123;    int a, b, c;&#125;edges[M];int dist[N], n, m, k;&#x2F;&#x2F;设置一个回溯的数组int backup[N];void bellman_ford() &#123;    dist[1] &#x3D; 0;        for(int i &#x3D; 1; i &lt;&#x3D; k; i ++ ) &#123;        &#x2F;&#x2F;先进行一个备份操作        memcpy(backup, dist, sizeof dist);                for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;            auto t &#x3D; edges[i];            &#x2F;&#x2F;就是这个地方，如果写成            &#x2F;&#x2F;dist[t.b] &gt; dist[t.a] + t.c的话            &#x2F;&#x2F;就会有可能出现串联反应            if(dist[t.b] &gt; backup[t.a] + t.c) &#123;                dist[t.b] &#x3D; backup[t.a] + t.c;            &#125;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    memset(dist, 0x3f, sizeof dist);        for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        &#x2F;&#x2F;代表a到b有一条权值为c的边        edges[i] &#x3D; &#123;a, b, c&#125;;    &#125;        bellman_ford();        if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="②spfa模板-ACwing-851"><a href="#②spfa模板-ACwing-851" class="headerlink" title="②spfa模板(ACwing.851)"></a>②spfa模板(ACwing.851)</h3><p><img src="https://img-blog.csdnimg.cn/5cf3def466b34406a70e05162bfa6d1f.png" alt="spfa求最短路"></p><h4 id="相关分析-1"><a href="#相关分析-1" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度：</code>  $O(m)$</p><p><code>适用场景：</code>  其实spfa这个算法以他比较优越的时间复杂度，其实用在很多题目都可以，且不仅能够求带负权的最短路，在一定程度上也可以解决dijkstra的题目。并且这个算法，可以判定一个图里面是否有负环</p><p><code>思路：</code>  这里的思路其实也是从上一个bellman-ford算法延申过来的。我们可以看到，上一个算法的好处就是可以知道有边限制的最短路，但是其实如果没有边的限制的话，第一个算法其实在内层循环遍历边的时候，会有很多操作本身更新不了一个点到原点的距离，但是还是进行了一个尝试更新的操作。<font color="red">那么spfa的话其实就是可以排除这些没有实际价值的更新操作，也就是说在$dist[j] &#x3D; dist[t] + w[i] $的那一步，只有一个点能够达到这一步操作了，让这个点进入队列之中，才有机会更新其他的边，如果某个点本身压根无法更新其他边，那也就没有必要让他到队列中再去更新其他边 </font></p><h4 id="完整AC代码-1"><a href="#完整AC代码-1" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 1e5 + 5;bool st[N];int dist[N], n, m;int h[N], w[N], e[N], ne[N], idx;queue&lt;int&gt; q;void add(int a, int b, int c) &#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++;&#125;void spfa() &#123;    q.push(1);    dist[1] &#x3D; 0;    st[1] &#x3D; true;    &#x2F;&#x2F;利用类似宽搜的方法进行优化    while(q.size()) &#123;        auto t &#x3D; q.front();        q.pop();        &#x2F;&#x2F;注意用过的点，有可能在后续更新的时候会继续用        st[t] &#x3D; false;                for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]) &#123;            int j &#x3D; e[i];                        if(dist[j] &gt; dist[t] + w[i]) &#123;                dist[j] &#x3D; dist[t] + w[i];                if(!st[j]) &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;&#125;int main() &#123;    memset(h, -1, sizeof h);    memset(st, 0, sizeof st);    memset(dist, 0x3f, sizeof dist);    cin &gt;&gt; n &gt;&gt; m;        for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;        spfa();        if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码相关问题"><a href="#代码相关问题" class="headerlink" title="代码相关问题"></a>代码相关问题</h4><p>这里的话有一个问题，就是为什么一个已经被使用来更新其他点的点，从对头取出来的那一刻，他的st数组要被更新成为没有使用过，这里举一个例子，例子图如下:</p><p><img src="https://img-blog.csdnimg.cn/c108a2f31d904c2f8056dcaecc2581a7.png" alt="spfa例子图"></p><p>我们可以看到这个图，假设，我们在用1这个点第一次更新好1-&gt;2和1-&gt;4的距离后，不让他的st数组变为false的话，那么当3这个点用来更新1的时候，很显然从1-&gt;2-&gt;3-&gt;1一回会让整个路径变小，而我们虽然更新了一下3-&gt;1的距离，但是并没有在后面让1入队的话，那么1这个点就不会继续更新4这个点，当然这个例子有些问题，因为，我们可以一直让上方的环不断的走，让最后的1到4的路径距离不断的减少，所以希望读者有更好的例子可以举例一下。</p><p>当然，这个题，如果不专门用st代表是否访问，直接更新然后不断放点那其实就等同于bellman-ford算法了，所以还是建议这个地方能够继续好好理解一下。然后也正因为这样，spfa算法可以去判定一下是否有负环，或者是否有一个环可以让某一个路径的距离一直减小。</p><h3 id="③spfa判断负环-ACwing-852"><a href="#③spfa判断负环-ACwing-852" class="headerlink" title="③spfa判断负环(ACwing. 852)"></a>③spfa判断负环(ACwing. 852)</h3><p><del>负环的定义就是一个环上边的权值全部为负数</del>，刚开始我还一直这么认为的，其实负环应该是一个环上所有数加起来的权值和是为负数叫做负环，因此根据上面的一个分析，其实判断负环就很容易了，就看循环是不是一直跑不出来，因为不能死循环，所以我们要利用一个cnt数组，判断一下某个点走了多少次，根据抽屉原理，一旦走的次数比n大的时候，那么一定存在负环。</p><p><img src="https://img-blog.csdnimg.cn/ce8a83dc0fb24fb1bb3636a59bd3c1c4.png"></p><h4 id="完整AC代码-2"><a href="#完整AC代码-2" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 100050, INF &#x3D; 1e9 + 10;int n, m, idx;int h[N], e[N], ne[N], w[N];int dist[N], cnt[N];bool st[N];void add(int a, int b, int c) &#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], w[idx] &#x3D; c, h[a] &#x3D; idx ++ ;&#125;bool spfa() &#123;    queue&lt;int&gt; q;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        q.push(i);        st[i] &#x3D; true;    &#125;        while(q.size()) &#123;        int t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i] ) &#123;            int j &#x3D; e[i];                        if(dist[j] &gt; dist[t] + w[i]) &#123;                dist[j] &#x3D; dist[t] + w[i];                cnt[j] &#x3D; cnt[t] + 1;                                if(cnt[j] &gt;&#x3D; n) return true;                                if(!st[j]) &#123;                    st[j] &#x3D; true;                    q.push(j);                &#125;            &#125;        &#125;    &#125;        return false;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);        for(int i &#x3D; 0; i &lt; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;        if(spfa()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码问题"><a href="#代码问题" class="headerlink" title="代码问题"></a>代码问题</h4><p>为什么dist数组不用初始化为正无穷？</p><p>​    其实就是，负环必须走的那个路径是有负数产生的，且由于一个环必须满足权值为负，那么我们其实可以偷懒一下，让每次开始更新dist出现在，我们搜索的时候，第一次搜到的负数开始，然后在更新dist，如果有负环，那么这个dist是会不断减少的。<font color="red">这个等价于什么呢，我们可以发现，之前的题目都是从1这个点出发开始的，而负环不一定存在1这个点连接的路径上，所以其实在刚开始，队列就应该把所有点放进去，然后所有点去找负环，那也就是说从这个角度看，所有点距离本身的距离为0，那么初始化为0就是正确的！</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;对于之前有写到的Dijkstra算法，我们发现他只能用来计算边的权值为正的情况，这其实也就是为什么我们需要开一个st数组，对</summary>
      
    
    
    
    <category term="图论专题篇" scheme="https://sample.com/categories/%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图论" scheme="https://sample.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论之Dijkstra</title>
    <link href="https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BDijkstra/"/>
    <id>https://sample.com/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BDijkstra/</id>
    <published>2022-07-28T01:27:54.000Z</published>
    <updated>2022-08-05T08:40:10.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本篇开始进行有关图论Dijkstra的题目整理，首先会整理两个模板，针对dijkstra的朴素版本和优化版本，此系列也会一直的更新，对于之后做到相关的题目，会放到此专题当中！而对于这个算法来说，一般求的是对于一些有向图，从某个点走到另外的一个终点不同路径的最小距离，<font color="red">注意此时有向边的权值必须为正数才行！</font></p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①朴素版Dijkstra-ACwing-849"><a href="#①朴素版Dijkstra-ACwing-849" class="headerlink" title="①朴素版Dijkstra(ACwing 849)"></a>①朴素版Dijkstra(ACwing 849)</h3><p><img src="https://img-blog.csdnimg.cn/9d19c2becddc4fc9a17f3b542df945cd.png" alt="求最短路"></p><h4 id="相关分析："><a href="#相关分析：" class="headerlink" title="相关分析："></a>相关分析：</h4><p><code>时间复杂度：</code>   $O(n^2)$，此处的n代表点的数量</p><p><code>适用场景：</code>  题目中是稠密图，点比较少，但是边比较多。此时利用邻接矩阵存图！</p><p><code>思路：</code>  朴素版本的Dijkstra的整体思路就是，从某个点(记作一号点)开始设其距离为0，然后通过与他本身距离更短的点不断的更新其他点到一号点的一个距离。外层的循环就是循环点的编号，内层的循环就是找到第一个离原点最近的那个点，然后利用那个点更新他其他边到原点最近的距离。</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 505;&#x2F;&#x2F;邻接矩阵存图, n表示点数,m表示边数量;int g[N][N], n, m;&#x2F;&#x2F;dist数组表示某个点到原点的最短距离int dist[N];&#x2F;&#x2F;记录某个点有没有被更新过bool st[N];void dijkstra() &#123;    &#x2F;&#x2F;原点距离本身为0    dist[1] &#x3D; 0;        &#x2F;&#x2F;两层循环    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        &#x2F;&#x2F;哨兵，便于选点        int t &#x3D; -1;        &#x2F;&#x2F;找到没有用来更新其他点的最短距离原点的点        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t])) &#123;                t &#x3D; j;            &#125;        &#125;        &#x2F;&#x2F;t这个点已经用来更新过了        st[t] &#x3D; true;                &#x2F;&#x2F;用t这个点更新一下        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            dist[j] &#x3D; min(dist[j], g[t][j] + dist[t]);        &#125;    &#125;&#125;int main() &#123;    &#x2F;&#x2F;初始化，刚开始边都是正无穷，便于取最小，判定是否有路径    memset(g, 0x3f, sizeof g);    memset(dist, 0x3f, sizeof dist);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        &#x2F;&#x2F;代表a到b有一个权值为v的边        int a, b, v;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;        &#x2F;&#x2F;可以提前排除自环        if(a !&#x3D; b) g[a][b] &#x3D; min(g[a][b], v);    &#125;    &#x2F;&#x2F;进行求解    dijkstra();    &#x2F;&#x2F;如果路径不存在，那么dist[n]还是正无穷    if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;        return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="②堆优化版Dijkstra-ACwing-850"><a href="#②堆优化版Dijkstra-ACwing-850" class="headerlink" title="②堆优化版Dijkstra(ACwing.850)"></a>②堆优化版Dijkstra(ACwing.850)</h3><p><img src="https://img-blog.csdnimg.cn/630fa3f2d27543bbb1b52f70837ee197.png" alt="求最短路"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度：</code>   $O(mlogm)$</p><p><code>适用场景:  </code>  这个题目和第一个题目最大的不同就是点数变多了，而如果再使用$O(n^2)$的做法就会超时，所以需要看点数比较多，而边数能够满足时间复杂度的时候就可以使用了。</p><p><code>思路：  </code>  之所以有这个优化，主要是因为我们可以看到第一个解法再寻找t用来更新其他路径的时候，是利用一层循环进行更新才能保证t的那个点更新的距离是最短的，但是其实这个过程是可以利用一个数据结构–优先队列(堆)进行相关的优化的，而在堆进行查找的操作是O(1)的，只不过删除元素后，把堆调整，是需要log的时间,所以以上的时间可以被优化。</p><h4 id="完整AC代码-1"><a href="#完整AC代码-1" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 2e5;int m, n, dist[N];&#x2F;&#x2F;利用邻接表存int h[N], e[N], ne[N], w[N], idx;&#x2F;&#x2F;队列放一个pair,pair第一个装距离，第二个装点编号&#x2F;&#x2F;因为pair默认按照第一个关键字排序&#x2F;&#x2F;这样可以做到排序的时候就是按照距离短进行priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;bool st[N];&#x2F;&#x2F;邻接表的一半添加操作，头插法void add(int a, int b, int c) &#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], w[idx] &#x3D; c, h[a] &#x3D; idx ++ ;&#125;void dijkstra() &#123;    dist[1] &#x3D; 0;    &#x2F;&#x2F;先让队列存在第一个点，第一个点的距离为0，编号是1    q.push(&#123;0, 1&#125;);        while(q.size()) &#123;        auto t &#x3D; q.top();        q.pop();        &#x2F;&#x2F;如果此点已经更新了其他点就不用再更新        if(st[t.y]) continue;        &#x2F;&#x2F;标记此点用来更新其他点        st[t.y] &#x3D; true;                for(int i &#x3D; h[t.y]; i !&#x3D; -1; i &#x3D; ne[i]) &#123;            int j &#x3D; e[i];            &#x2F;&#x2F;只有让某个点的距离能够更新的情况            &#x2F;&#x2F;才把那个点放到队列，可能用来更新其他点到原点的距离            if(dist[j] &gt; w[i] + dist[t.y]) &#123;                dist[j] &#x3D; w[i] + dist[t.y];                q.push(&#123;dist[j], j&#125;);            &#125;        &#125;            &#125;&#125;int main() &#123;    &#x2F;&#x2F;初始化操作    &#x2F;&#x2F;距离先初始化为正无穷    &#x2F;&#x2F;头结点开始指向空，记作-1    memset(dist, 0x3f, sizeof dist);    memset(h, -1, sizeof h);    memset(st, 0, sizeof st);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;        dijkstra();        if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;本篇开始进行有关图论Dijkstra的题目整理，首先会整理两个模板，针对dijkstra的朴素版本和优化版本，此系列也会一直</summary>
      
    
    
    
    <category term="图论专题篇" scheme="https://sample.com/categories/%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图论" scheme="https://sample.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>状压dp</title>
    <link href="https://sample.com/2022/07/28/%E7%8A%B6%E5%8E%8Bdp/"/>
    <id>https://sample.com/2022/07/28/%E7%8A%B6%E5%8E%8Bdp/</id>
    <published>2022-07-28T01:26:37.000Z</published>
    <updated>2022-08-09T07:13:19.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这一篇博客总结自己在学习状态压缩dp时候的一个题目汇总吧。这里主要分为两块吧，一个是状态机模型，另外就是状压dp，因为两个都是由某一个状态转移到另外一个状态，所以整合在一起，也能更加的对状态到状态之间的转移有个比较好的一个逻辑内联吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;这一篇博客总结自己在学习状态压缩dp时候的一个题目汇总吧。这里主要分为两块吧，一个是状态机模型，另外就是状压dp，因为两个都</summary>
      
    
    
    
    <category term="动态规划专题" scheme="https://sample.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="-状压DP -DP分析" scheme="https://sample.com/tags/%E7%8A%B6%E5%8E%8BDP-DP%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>树形dp</title>
    <link href="https://sample.com/2022/07/28/%E6%A0%91%E5%BD%A2dp/"/>
    <id>https://sample.com/2022/07/28/%E6%A0%91%E5%BD%A2dp/</id>
    <published>2022-07-28T01:26:17.000Z</published>
    <updated>2022-07-28T10:32:19.225Z</updated>
    
    <content type="html"><![CDATA[<p>等待更新ing……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;等待更新ing……&lt;/p&gt;
</summary>
      
    
    
    
    <category term="动态规划专题" scheme="https://sample.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="-树形DP -DP分析" scheme="https://sample.com/tags/%E6%A0%91%E5%BD%A2DP-DP%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>区间DP</title>
    <link href="https://sample.com/2022/07/27/%E5%8C%BA%E9%97%B4DP/"/>
    <id>https://sample.com/2022/07/27/%E5%8C%BA%E9%97%B4DP/</id>
    <published>2022-07-27T08:47:04.000Z</published>
    <updated>2022-08-04T09:54:41.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>最近写的一些相关文章，主要会整理一下相关题目，此系列会不断的更新，只要遇到了相关的题目就都会整理在一起！本篇主要针对区间DP进行相关整理。区间dp有一个特点，就是一般题目都会对一个区间进行一些处理，而此dp的状态定义也与区间相关。而整个题目的分析，采取闫式dp分析法，从<font color="red">状态表示，状态计算</font>两个方面分析每一个dp题目。希望之后做到类似的题目的时候能够更快速的分析出如何解题！</p><h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><h3 id="①ACwing-282-石子合并"><a href="#①ACwing-282-石子合并" class="headerlink" title="①ACwing 282.石子合并"></a>①ACwing 282.石子合并</h3><p><img src="https://img-blog.csdnimg.cn/b2869b5a18454244929219a1982c5a8e.png" alt="石子合并"></p><p><code>注意：</code></p><p>本题和大家比较常见的合并果子那一个贪心题不同，因为此题必须合并相邻的两堆石子。如果合并的顺序是任意的话才能够利用贪心！</p><h4 id="DP分析"><a href="#DP分析" class="headerlink" title="DP分析"></a>DP分析</h4><p><img src="https://img-blog.csdnimg.cn/ec2607b4d3a447579a45ccbe1b105650.png"></p><blockquote><p>此处解释上方的一个分析方法</p><p>对于动态规划来说，如何能够正确的写出这类的题目，首先要知道，先定义一个与题目相关的状态表示，而这样的状态表示恰好表示一类集合，而这一类集合表达出来以后，是可以先考虑以集合的最后一个点作为分界点往前看。</p><p>假设我们在计算f(i, j)的时候，我们可以以j为分界点，把集合分成j - 1的子集合，状态转移中的m分界点。注意这个m所选取的区间是落在[i, j)这个区间内的。</p><p>为什么i为闭区间，j为开区间呢？</p><p>因为选i为分界点，可以分为拿第一个和后面所有为两个区间</p><p>而如果选j为分界点，就无法分成两堆了！</p><p>一旦分好这些分界点之后，就知道如何进行递推了。</p></blockquote><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>如果以m为分界点，我们要计算f(i, j)的值</p><p><font color="red">$f(i, j) &#x3D; min(f(i, m) + f(m + 1, j) + sum(i, j)), m \in [i, j)$</font></p><p>其中sum(i, j)表示[i, j]区间所有果子合并需要花费的体力值，这个也就是合并两段区间所需要的体力值！而因为这个是一个区间求和的问题，因此再计算sum的时候就可以利用前缀和进行一个优化了！</p><p><font color="blue">最后结果就是：f(1,n)</font></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>对于初始化来说，有下面情况</p><p>i &#x3D;&#x3D; j : 就是合并一个石子的最小花费为0(因为不需要合并)</p><p>i &lt; j : 最小花费初始化为$+\infty$,因为要求最小值，所以可以初始成一个很大的数，<font color="red">这里不能说初始化为0，因为0代表无花费，这样的话怎么推导，都是最小为0，那么最后的答案肯定是0</font></p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 305, INF &#x3D; 0x3f3f3f3f;&#x2F;&#x2F;初始化1int f[N][N];&#x2F;&#x2F;前缀和数组int sum[N];int main() &#123;    int n;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;        cin &gt;&gt; sum[i];        sum[i] +&#x3D; sum[i - 1];    &#125;        &#x2F;&#x2F;先枚举可能的区间长度    for(int len &#x3D; 2; len &lt;&#x3D; n; len ++ ) &#123;        &#x2F;&#x2F;左端点为i，右端点为i + len - 1;        &#x2F;&#x2F;满足右端点在n内就可以满足左端点范围        for(int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++ ) &#123;            int l &#x3D; i, r &#x3D; i + len - 1;            &#x2F;&#x2F;初始化2            f[l][r] &#x3D; INF;                        &#x2F;&#x2F;枚举分界点m            for(int m &#x3D; l; m &lt; r; m ++ ) &#123;                &#x2F;&#x2F;状态转移                f[l][r] &#x3D; min(f[l][r], f[l][m] + f[m + 1][r] + sum[r] - sum[l - 1]);            &#125;        &#125;    &#125;        cout &lt;&lt; f[1][n] &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;最近写的一些相关文章，主要会整理一下相关题目，此系列会不断的更新，只要遇到了相关的题目就都会整理在一起！本篇主要针对区间DP</summary>
      
    
    
    
    <category term="动态规划专题" scheme="https://sample.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="-区间DP -DP分析" scheme="https://sample.com/tags/%E5%8C%BA%E9%97%B4DP-DP%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>线性DP</title>
    <link href="https://sample.com/2022/07/27/%E7%BA%BF%E6%80%A7DP/"/>
    <id>https://sample.com/2022/07/27/%E7%BA%BF%E6%80%A7DP/</id>
    <published>2022-07-27T08:46:51.000Z</published>
    <updated>2022-08-09T07:17:26.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>此篇章主要整理一些关于线性dp的题目，很多题目其实都可以被挂上线性dp的标志，比如最熟悉的最长上升子序列啊，最长公共子序列啊等等，并且线性dp在自己写力扣周赛的题目的时候，真的会时不时出几道，然后刚好利用这些题目加上dp分析的方法，把题目好好写一写。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①力扣2369-检查数组是否存在有效的划分"><a href="#①力扣2369-检查数组是否存在有效的划分" class="headerlink" title="①力扣2369.检查数组是否存在有效的划分"></a>①力扣2369.检查数组是否存在有效的划分</h3><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="(1)题目描述"></a>(1)题目描述</h4><p><img src="https://img-blog.csdnimg.cn/db9dfc3ca68b4282b5a836d090bf0d56.png" alt="2369.检查数组是否存在有效划分"></p><h4 id="2-dp分析"><a href="#2-dp分析" class="headerlink" title="(2)dp分析"></a>(2)dp分析</h4><p><img src="https://img-blog.csdnimg.cn/78f2bba876c142508a6d8076573e1767.png"></p><p><font color="red">状态转移方程：</font><br>$$<br>f[i]&#x3D;Or<br>\begin{cases}<br>f[i-2], i\ge2&amp;&amp;num[i-1]&#x3D;num[i-2] \\<br>f[i-3],i&gt;&#x3D;3&amp;&amp;num[i-1]&#x3D;num[i-1]&#x3D;num[i-2] \\<br>f[i-3],i&gt;&#x3D;3&amp;&amp;num[i-1]-num[i-2]&#x3D;num[i-2]-num[i-3]&#x3D;&#x3D;1<br>\end{cases}<br>$$<br><font color="red">这个状态转移代表什么呢?</font></p><p>其实就是说，当我们选择第i个数的时候，如果在第$i-2$或者第$i-3$个数字前的划分都是正确的，那么我们选择i个数，满足三个条件中的时候，我们就可以有一个合理的划分。举一个例子，假设我们的数组是$[1,1,1,2,3]$,不难发现，对于1这个数字来说，划分有两种，既可以有前两个1组成一组，也可以是前3个1，因此$f(2),f(3)$都是<font color="purple">True</font>,而我们在i等于5的时候，我们此时就可以利用条件3，发现是递增的，那么我们在推导的时候，$f(5) || f(5-3)&#x3D;True$,因此最终是可以成功划分的。</p><p><font color="red">状态初始化</font></p><p>$f[0]&#x3D;true, f[1]&#x3D;false$</p><p><font color="blue">因为第0个划分不需要划分也是正确的，这个也是推出其他是否正确的一个必要条件。</font></p><p><code>最终结果:</code> $f[n]$</p><p><code>时间复杂度:</code> $O(N)$</p><h4 id="3-完整AC代码"><a href="#3-完整AC代码" class="headerlink" title="(3)完整AC代码"></a>(3)完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool validPartition(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        vector&lt;bool&gt; f(n + 1, false);        f[0] &#x3D; true;        for(int i &#x3D; 2; i &lt;&#x3D; n; i ++ ) &#123;            if(nums[i - 1] &#x3D;&#x3D; nums[i - 2]) f[i] &#x3D; f[i] || f[i - 2];            if(i &gt;&#x3D; 3) &#123;                if(nums[i - 1] &#x3D;&#x3D; nums[i - 2] &amp;&amp; nums[i - 2] &#x3D;&#x3D; nums[i - 3])                    f[i] &#x3D; f[i] || f[i - 3];                if(nums[i - 1] - nums[i - 2] &#x3D;&#x3D; 1 &amp;&amp; nums[i - 2] - nums[i - 3] &#x3D;&#x3D; 1)                    f[i] &#x3D; f[i] || f[i - 3];            &#125;        &#125;        return f[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②力扣2370-最长理想子数组"><a href="#②力扣2370-最长理想子数组" class="headerlink" title="②力扣2370.最长理想子数组"></a>②力扣2370.最长理想子数组</h3><h4 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="(1)题目描述"></a>(1)题目描述</h4><p><img src="https://img-blog.csdnimg.cn/96de949027784629829d422aee2cc0d1.png" alt="2370.最长理想子数组"></p><h4 id="2-dp分析-1"><a href="#2-dp分析-1" class="headerlink" title="(2)dp分析"></a>(2)dp分析</h4><p><img src="https://img-blog.csdnimg.cn/6b6dbc631e444aa78156771b20d62127.png"></p><p><font color="red">状态转移方程:</font><br>$$<br>f(i,j)&#x3D;max<br>\begin{cases}<br>f(i-1,j),不选择第i个字符的情况 \\<br>f(i-1,[max(j-k,0),min(j+k,25)]),选择第i个字符的情况<br>\end{cases}<br>$$<br><font color="red">相关分析:</font></p><p>这个转移和最长上升子序列的那个dp非常的像，所以也就告诉我们，这个题目其实可以利用一维进行dp，当然下面的代码也会展现出二维的代码，就是二维的比较蛋疼，因为，每一层转移的时候，都需要把所有字符在上一层的状态迁移到本层，最终得到的结果才可以在最后一层里面推出来。</p><p><code>最终结果:</code> $max(f[n][i], 0\leq i \leq 25)$</p><p><code>时间复杂度:</code> $O(n*(26 + 2 * k))$</p><h4 id="3-完整AC代码-1"><a href="#3-完整AC代码-1" class="headerlink" title="(3)完整AC代码"></a>(3)完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;二维代码class Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n &#x3D; s.size();        int f[100050][26];        memset(f, 0, sizeof f);        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;            for(int j &#x3D; 0; j &lt; 26; j ++ ) f[i][j] &#x3D; f[i - 1][j];            int j &#x3D; s[i - 1] - &#39;a&#39;;            for(int p &#x3D; max(j - k, 0); p &lt;&#x3D; min(j + k, 25); p ++ ) &#123;                f[i][j] &#x3D; max(f[i][j], f[i - 1][p] + 1);            &#125;         &#125;        int maxn &#x3D; 0;        for(int i &#x3D; 0; i &lt; 26; i ++ ) &#123;            maxn &#x3D; max(maxn, f[n][i]);        &#125;        return maxn;    &#125;&#125;;&#x2F;&#x2F;一维代码class Solution &#123;public:    int longestIdealString(string s, int k) &#123;        vector&lt;int&gt; f(26, 0);        for(auto c : s) &#123;            int j &#x3D; c - &#39;a&#39;;            f[j] &#x3D; f[j] + 1;            for(int i &#x3D; max(0, j - k); i &lt;&#x3D; min(25, j + k); i ++ ) &#123;                if(i !&#x3D; j) f[j] &#x3D; max(f[j], f[i] + 1);            &#125;        &#125;        int maxn &#x3D; 0;        for(auto t : f) maxn &#x3D; max(t, maxn);        return maxn;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;此篇章主要整理一些关于线性dp的题目，很多题目其实都可以被挂上线性dp的标志，比如最熟悉的最长上升子序列啊，最长公共子序列啊</summary>
      
    
    
    
    <category term="动态规划专题" scheme="https://sample.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="-线性DP -DP分析" scheme="https://sample.com/tags/%E7%BA%BF%E6%80%A7DP-DP%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>模拟堆</title>
    <link href="https://sample.com/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%A0%86/"/>
    <id>https://sample.com/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%A0%86/</id>
    <published>2022-07-03T03:52:35.000Z</published>
    <updated>2022-07-03T10:59:29.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本篇文章主要以小根堆为例子，做一些有关小根堆的知识点笔记，前面主要就是堆排序，后面呢是一个题目的相关介绍，由于那个题目的特殊性，所以不多加赘述，这一篇主要是以堆能够实现的一些操作为例子，记录一下堆的一些应用。</p><h1 id="二、理解"><a href="#二、理解" class="headerlink" title="二、理解"></a>二、理解</h1><p>本篇主要受众是已经建立在知道二叉树的建立的基础上，进行堆的记录。如果不太了解二叉树的uu们可以先去了解一下二叉树的建立，知道左右孩子的节点是怎么表示的，然后食用一下这篇文章。</p><p>堆呢，其实原型就是一颗完全二叉树，我们知道，完全二叉树必须保证树儿子的完整性，即一个节点为x的父亲，如果他有孩子，那么他左右孩子的节点位置一定为2x和(2x+ 1)，而整个树的根节点坐标从1开始计算！</p><p>而堆其实分为小根堆和大根堆。以小根堆为主要例子介绍。小根小根，就是根都是小的，也就是一个节点如果有孩子，那么他在他本身和他孩子中间，他是最小的。即是我们的小根堆。至于小根堆，以下面的图做例子，相信大家能够更加清晰的知道了。</p><p><img src="https://img-blog.csdnimg.cn/04ee26c8076d4a15b9044e8ab0e92b6d.png"></p><p>上图就是一个小根堆，而红颜色代表着每一个节点的坐标。</p><h1 id="三、堆的相关函数"><a href="#三、堆的相关函数" class="headerlink" title="三、堆的相关函数"></a>三、堆的相关函数</h1><p>我觉得还是应该先以堆的相关函数为例子然后在进行后续堆的基本操作的讲解</p><h3 id="①定义相关变量"><a href="#①定义相关变量" class="headerlink" title="①定义相关变量"></a>①定义相关变量</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100050;int h[N]; &#x2F;&#x2F;存储堆的元素int sz &#x3D; 0; &#x2F;&#x2F;表示堆的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②down函数"><a href="#②down函数" class="headerlink" title="②down函数"></a>②down函数</h3><p>如果有一些节点发生了变化，可能会导致节点需要向下调整到合适的位置</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void down(int u) &#123;    &#x2F;&#x2F;记录节点和孩子谁最小，小的会到父亲的位置，成为根    int t &#x3D; u;    &#x2F;&#x2F;如果左孩子存在，并且比根小的话    if(2*u &lt;&#x3D; sz &amp;&amp; h[t] &gt; h[2*u]) t &#x3D; 2*u;    &#x2F;&#x2F;如果有孩子存在，并且比根和左孩子小的话    if(2*u+1 &lt;&#x3D; sz &amp;&amp; h[t] &gt; h[2*u+1]) t &#x3D; 2*u+1;    &#x2F;&#x2F;如果此时记录的t不等于u的话    if(t !&#x3D; u) &#123;        swap(h[t], h[u]);    &#x2F;&#x2F;递归的处理一下后续的节点    down(t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③up函数"><a href="#③up函数" class="headerlink" title="③up函数"></a>③up函数</h3><p>如果有一些节点发生了变化，可能会导致节点需要向上调整到合适的位置，<font color="red">而向上调整与向下不同的是，向上调整的时候，只需要跟根节点进行比较就好，因为为了满足小根堆的需求，其中孩子变化了，但是在之前一个状态下，根还是保证最小。</font></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void up(int u) &#123;    &#x2F;&#x2F;当根节点比变化的孩子大，就让他向上调整    while(u &#x2F; 2 &gt; 0 &amp;&amp; h[u &#x2F; 2] &gt; h[u]) &#123;        swap(h[u &#x2F; 2], h[u]);        u &#x2F;&#x3D; 2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、堆的基本操作"><a href="#四、堆的基本操作" class="headerlink" title="四、堆的基本操作"></a>四、堆的基本操作</h1><p>通过堆相关函数的介绍下面其实就是函数的拼凑了</p><h3 id="①构建一个堆"><a href="#①构建一个堆" class="headerlink" title="①构建一个堆"></a>①构建一个堆</h3><p>这里有一个比较巧的方法，无论是什么样的小根堆，如果他含有n个元素，那么叶子节点(没有孩子节点层)的上一层最后一个存有元素的父亲节点为n &#x2F; 2,这个结论大家可以直接记住。所以我们在构建堆的时候，我们只需要从节点为n &#x2F; 2处开始向上调整节点，每个节点都往下down一遍就可以建立一个堆。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这个操作可以把一个存有元素的一维数组，按照堆的节点顺序排列for(int i &#x3D; n &#x2F; 2; i &gt; 0; i -- ) &#123;    down(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②向堆里面插入一个元素"><a href="#②向堆里面插入一个元素" class="headerlink" title="②向堆里面插入一个元素"></a>②向堆里面插入一个元素</h3><p>这里有个技巧就是下面几个点</p><ul><li>将插入的元素先插入在堆的最后</li><li>利用up函数向上调整一遍</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">h[++sz] &#x3D; val;&#x2F;&#x2F;向上调整堆的最后一个元素up(sz);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="③删除堆中的元素"><a href="#③删除堆中的元素" class="headerlink" title="③删除堆中的元素"></a>③删除堆中的元素</h3><ul><li>将待删除的元素和堆中最后一个元素</li><li>up调整一遍</li><li>down调整一遍</li></ul><p>其中后面两个步骤只会进行其中一个，因为调整后，要不然就是比其父亲小，要不然就比孩子大。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">swap(h[k], h[sz]);sz--;up(k);down(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④修改堆中的某个元素值"><a href="#④修改堆中的某个元素值" class="headerlink" title="④修改堆中的某个元素值"></a>④修改堆中的某个元素值</h3><p>和第三个操作类似</p><ul><li>修改堆中元素值</li><li>up调整一遍</li><li>down调整一遍</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">h[k] &#x3D; val;up(k);down(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑤输出堆中的最小值"><a href="#⑤输出堆中的最小值" class="headerlink" title="⑤输出堆中的最小值"></a>⑤输出堆中的最小值</h3><ul><li>直接输出堆顶元素就好</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; h[1] &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="blue">不难发现，其实整个堆的调整就是类似打拳皇一样，我们先熟知每一个英雄他有什么技能，然后根据不同的需求，利用我们已知的技能，打出不同的组合技能，最终KO对方。而我们就是要利用组合起来的函数AC相关的算法题。还是很好玩的！</font></p><h1 id="五、相关题目"><a href="#五、相关题目" class="headerlink" title="五、相关题目"></a>五、相关题目</h1><h3 id="题目一-堆排序"><a href="#题目一-堆排序" class="headerlink" title="题目一.堆排序"></a>题目一.堆排序</h3><p>能够利用堆排序主要的原因就是小根堆能够维护我们整个堆中的最小值。当最小值被输出之后，我们删除堆顶元素，然后不断的输出新的堆顶元素，我们就可以完成这一个题目。所以只需要利用四中的①③⑤组合技我们就可以AC掉了</p><p><img src="https://img-blog.csdnimg.cn/7e6cd8f3a0f6437c9b5f531c3c83eff9.png"></p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100005;int m, n;int sz, h[N];void down(int x) &#123;    int t &#x3D; x;    &#x2F;&#x2F;左子树存在且比节点小    if(2 * x &lt;&#x3D; sz &amp;&amp; h[2 * x] &lt; h[t]) t &#x3D; 2 * x;    &#x2F;&#x2F;右子树存在且比节点小    if(2 * x + 1 &lt;&#x3D; sz &amp;&amp; h[2 * x + 1] &lt; h[t]) t &#x3D; 2 * x + 1;    if(t !&#x3D; x) &#123;        swap(h[t], h[x]);        down(t);    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    sz &#x3D; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; h[i];    for(int i &#x3D; n &#x2F; 2; i; i--) down(i);    while(m--) &#123;        cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;;        h[1] &#x3D; h[sz--];        down(1);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p><img src="https://img-blog.csdnimg.cn/a21629f07a4f486a93bb6dbc8ce117e6.png"></p><p>这个题目因为要记录一下第k个插入数的位置，所以大家可以直接用结构体装一下每个节点是第几个插入的，但是为了快速，是可以类似利用数组去模拟哈希表的方式进行实现，因为可能会有些难理解。我写了相关的注释在代码中，可以量力理解一下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;ph[k]表示第k个插入的节点在堆中的下标，hp[k]表示堆中第k个节点是第几个插入的数。#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100005;int ph[N], hp[N], h[N];&#x2F;&#x2F;m代表第m个插入的数，cnt代表整个堆的大小int m, cnt;&#x2F;&#x2F;这个swap就实现了不仅元素交换了，节点对应是第几个插入的数也被交换了！void heap_swap(int a, int b) &#123;    &#x2F;&#x2F;交换第某个插入的数的堆中下标    swap(ph[hp[a]], ph[hp[b]]);    &#x2F;&#x2F;交换堆中某个节点代表插入的数    swap(hp[a], hp[b]);    &#x2F;&#x2F;交换堆中的两个位置的值    swap(h[a], h[b]);&#125;&#x2F;&#x2F;下传操作void down(int x) &#123;    int t &#x3D; x;    if(2 * x &lt;&#x3D; cnt &amp;&amp; h[2 * x] &lt; h[t]) t &#x3D; 2 * x;    if(2 * x + 1 &lt;&#x3D; cnt &amp;&amp; h[2 * x + 1] &lt; h[t]) t &#x3D; 2 * x + 1;    if(t !&#x3D; x) &#123;        heap_swap(t, x);        down(t);    &#125;&#125;&#x2F;&#x2F;上传操作void up(int x) &#123;    while(x &#x2F; 2 &amp;&amp; h[x &#x2F; 2] &gt; h[x]) &#123;        heap_swap(x, x &#x2F; 2);        x &gt;&gt;&#x3D; 1;    &#125;&#125;int main() &#123;    int num, k, n;    cin &gt;&gt; n;    string op;    while(n--) &#123;        cin &gt;&gt; op;        &#x2F;&#x2F;插入操作        if(op &#x3D;&#x3D; &quot;I&quot;) &#123;            cin &gt;&gt; num;            cnt++; m++;            h[cnt] &#x3D; num; hp[cnt] &#x3D; m; ph[m] &#x3D; cnt;            up(cnt);        &#125;        &#x2F;&#x2F;输出最小值        else if(op &#x3D;&#x3D; &quot;PM&quot;) &#123;            &#x2F;&#x2F; cout &lt;&lt; n &lt;&lt; endl;            cout &lt;&lt; h[1] &lt;&lt; endl;        &#125;        &#x2F;&#x2F;删除最小值        else if(op &#x3D;&#x3D; &quot;DM&quot;) &#123;            heap_swap(1, cnt);            cnt--;            down(1);        &#125;        &#x2F;&#x2F;删除第k个插入的数        else if(op &#x3D;&#x3D; &quot;D&quot;) &#123;            cin &gt;&gt; k;            &#x2F;&#x2F;必须先保存一个位置，否则有可能在交换过程直接交换了指针位置，导致答案错误！！            k &#x3D; ph[k];            heap_swap(k, cnt);            cnt--;            up(k);            down(k);        &#125;        &#x2F;&#x2F;修改第k个插入的数为num        else &#123;            cin &gt;&gt; k &gt;&gt; num;            int id &#x3D; ph[k];            h[id] &#x3D; num;            up(id);            down(id);        &#125;    &#125;    return 0;&#125;作者：sheepice链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;3438577&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;本篇文章主要以小根堆为例子，做一些有关小根堆的知识点笔记，前面主要就是堆排序，后面呢是一个题目的相关介绍，由于那个题目的特殊</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sample.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构 -模板" scheme="https://sample.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Trie数(字典树)</title>
    <link href="https://sample.com/2022/07/03/Trie%E6%95%B0-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>https://sample.com/2022/07/03/Trie%E6%95%B0-%E5%AD%97%E5%85%B8%E6%A0%91/</id>
    <published>2022-07-03T03:52:09.000Z</published>
    <updated>2022-07-28T01:32:20.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>字典树是一个比较神奇的东西。试想如果我们要用程序去存一些字符串，但是相同的字符不能放在不同的空间里面，比如有两个字符串abc，abf，我们发现ab是相同的，就需要我们把他们存在一个数组空间?我们应该怎么做到呢？再来就是为什么叫字典树呢，其实很形象的说明了他的存储方式，就是字典。我们在查字典的时候，都会先查一个单词的首字母，然后在对应的地方继续依次查后面的字母。也就是我们可以利用数组完成这样的存储</p><p><font color="red">但是由于一般数组的空间有限，字典树会占据很多的空间，一个abc就占用了3个单位空间，所以在用的时候是需要注意一下数据范围，是否能够不爆空间！</font></p><h1 id="二、相关操作"><a href="#二、相关操作" class="headerlink" title="二、相关操作"></a>二、相关操作</h1><h3 id="①前期变量定义"><a href="#①前期变量定义" class="headerlink" title="①前期变量定义"></a>①前期变量定义</h3><p><img src="https://img-blog.csdnimg.cn/90071e11da794f4fae8dde0d9ba95be5.jpeg"></p><p>字典树需要一个二维数组空间，叫做son，为什么这么称呢。因为我们整个树的根节点我们用idx&#x3D;0来表示。这个点是整个树的头，他有无数的儿子，儿子又有无数的儿子。所以我们亲切的称后续的节点为一个儿子</p><p>而son的定义其实就是每一个x都会对应有y个儿子，无论我们是插入操作还是查询操作，为了满足不浪费多余的空间，我们都需要进行首先的判断，作为第x的父亲是否已经存在y这个节点，如果不存在，就给他一个儿子，如果存在，就一视同仁为一个儿子。</p><h3 id="②插入一个字符串"><a href="#②插入一个字符串" class="headerlink" title="②插入一个字符串"></a>②插入一个字符串</h3><p>假设我们树中的字符串全是小写字母，那我们的儿子其实只可能有26个，所以在开数组的时候就可以开: int $son[N][26]$,而我们后面的例题主要以这个为主。</p><p><img src="https://img-blog.csdnimg.cn/dda00c468fce49e2b60e18731622c1a6.jpeg"></p><p>上面我觉得插入讲得比较清楚了，所以直接贴一个代码好了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insert(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ ) &#123;        int u &#x3D; ss[i] - &#39;a&#39;;        &#x2F;&#x2F;如果没有这个儿子就给他一个儿子        if(son[p][u] &#x3D;&#x3D; 0) son[p][u] &#x3D; ++idx;        &#x2F;&#x2F;不管有没有儿子，p指针都会朝向儿子或者新建点走        &#x2F;&#x2F;一旦p走向新建的点，其实就代表后面的所有点都是新建的        p &#x3D; son[p][u];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③查询一个字符串"><a href="#③查询一个字符串" class="headerlink" title="③查询一个字符串"></a>③查询一个字符串</h3><p>查询其实和构建是差不多的，就是看我们要查询的字符串是否能够完全的走完构建好的字符串，至于查询，结合后面的题目，大家可以理解，直接贴一个小小的代码。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int query(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ ) &#123;        int u &#x3D; ss[i] - &#39;a&#39;;        if(son[p][u] &#x3D;&#x3D; 0) return 0;        p &#x3D; son[p][u];    &#125;        return cnt[p];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、相关题目"><a href="#三、相关题目" class="headerlink" title="三、相关题目"></a>三、相关题目</h1><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p><img src="https://img-blog.csdnimg.cn/fd0f17eb8d7846c0a542dbabb963e9e9.png"></p><p>上面的题目就是比较经典的，查询字串出现次数的题目，在我们构建树的时候，我们另外开一个cnt数组，记录一个字符串最后那个字母所在的位置出现了多少个就能解决这个题目了。可以直接看一下完整的代码。</p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100005;int son[N][26], cnt[N], idx;void insrt(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ )&#123;        int u &#x3D; ss[i] - &#39;a&#39;;        if(son[p][u] &#x3D;&#x3D; 0) son[p][u] &#x3D; ++ idx;        p &#x3D; son[p][u];    &#125;        cnt[p] ++ ;&#125;int query(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ ) &#123;        int u &#x3D; ss[i] - &#39;a&#39;;        if(son[p][u] &#x3D;&#x3D; 0) return 0;        p &#x3D; son[p][u];    &#125;        return cnt[p];&#125;int main() &#123;    int n;    cin &gt;&gt; n;    while (n -- ) &#123;        string op, in;        cin &gt;&gt; op &gt;&gt; in;                if(op &#x3D;&#x3D; &quot;I&quot;) &#123;            insrt(in);        &#125;                else &#123;            cout &lt;&lt; query(in) &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p><img src="/2022/07/03/Trie%E6%95%B0-%E5%AD%97%E5%85%B8%E6%A0%91/Users/0604520/AppData/Roaming/Typora/typora-user-images/image-20220703165405990.png"></p><p>这个题目比较的好玩，其实这个题目就是在表述一个二叉树，具体的思路如图解</p><p><img src="https://img-blog.csdnimg.cn/102a9cd23cea44aa9b1abbb4ae8484e5.jpeg"></p><p>我们都知道一个二进制数异或起来，相同为0，不同为1，那其实就是再告诉我们，我们在不断建树的过程中，可以用待插入元素，与树中的元素比较，每次去看相同位下有没有和本身不同位的儿子，如果有的话，我们就可以忘那个儿子的路径走。</p><p>比如下图：</p><p><img src="https://img-blog.csdnimg.cn/54204ac29ce440e28dc684016f0b4e67.jpeg"></p><p>依次插入5，3，4并且寻找最大异或的元素，</p><p>再插入4的时候，先寻找最大异或，我们发现4的二进制是100</p><p>对于1这一位，先找有没有0儿子，恰好3的第一位为0，一次类推，他和3抑或能够得到最大的异或值7(111);</p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100050, M &#x3D; 31 * N;&#x2F;&#x2F;因为儿子只可能有0，1两个选项int son[M][2], idx &#x3D; 0;void insert(int num) &#123;    int p &#x3D; 0;    &#x2F;&#x2F;体重说最多有31位    for(int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;        int u &#x3D; (num &gt;&gt; i) &amp; 1;        if(son[p][u] &#x3D;&#x3D; 0) son[p][u] &#x3D; ++idx;        p &#x3D; son[p][u];    &#125;&#125;int query(int num) &#123;    int p &#x3D; 0, ret &#x3D; 0;    for(int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;        int u &#x3D; (num &gt;&gt; i) &amp; 1;        &#x2F;&#x2F;如果有不同的儿子        if(son[p][!u] !&#x3D; 0) &#123;            ret &#x3D; ret * 2 + !u;            p &#x3D; son[p][!u];        &#125;        &#x2F;&#x2F;如果没有不同的儿子        else &#123;            ret &#x3D; ret * 2 + u;            p &#x3D; son[p][u];        &#125;    &#125;    return ret;&#125;int main() &#123;    int m, num;    cin &gt;&gt; m;    int ans &#x3D; 0;    while (m -- ) &#123;        cin &gt;&gt; num;        insert(num);        ans &#x3D; max(num ^ query(num), ans);    &#125;        cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;字典树是一个比较神奇的东西。试想如果我们要用程序去存一些字符串，但是相同的字符不能放在不同的空间里面，比如有两个字符串abc</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sample.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构 -模板" scheme="https://sample.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>KMP匹配字符串</title>
    <link href="https://sample.com/2022/07/03/KMP%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://sample.com/2022/07/03/KMP%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-07-03T03:51:25.000Z</published>
    <updated>2022-07-03T09:10:11.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这一章记录的是自己学习KMP算法的一个笔记吧。我觉得KMP虽然目前没有用到相关的算法，但是他的思想很妙，很多人在刚开始会非常不理解这个算法的由来。而我也是写了好几遍才能够真的说掌握了一些KMP算法。其实主要记住一点就是，KMP完成了字符串与本身进行比较的一个思路。</p><p><font color="red">所有字符串下标从1开始</font></p><h1 id="二、相关操作"><a href="#二、相关操作" class="headerlink" title="二、相关操作"></a>二、相关操作</h1><h3 id="①相关变量的定义"><a href="#①相关变量的定义" class="headerlink" title="①相关变量的定义"></a>①相关变量的定义</h3><p><img src="https://img-blog.csdnimg.cn/dd7b7fd4f32e4ff0a3eaed36a6abcab1.jpeg"></p><p>说真的我觉得相关一些数组的定义是整个这个算法的核心</p><p>首先就是题目给的两个串，一个比较长的叫做模式串，另外一个叫做子串，题目的要求就是子串在模式串出现的位置或者出现的次数</p><p>我们再看最难理解的一个ne数组的定义，最长子串的公共前后缀长度</p><p><font color="red">其实这个地方需要加上一个定义，假设ne[X], 这个其实代表的是，子串从1-X位置的字符串的最长公共前后缀的长度。这里要说明的是，前后缀是什么</font></p><ul><li>前缀:包含字符串首字母的连续子串</li><li>后缀:包含字符串尾字母的连续子串</li></ul><blockquote><p>比如字符串：abc</p><p>前缀有: a  ab </p><p>后缀有: c  bc </p></blockquote><h3 id="②ne数组的求解"><a href="#②ne数组的求解" class="headerlink" title="②ne数组的求解"></a>②ne数组的求解</h3><p>搞清楚了前后缀之后，如果我们要去求ne数组怎么求呢？</p><p><img src="https://s2.loli.net/2022/07/03/RxH7P9sMBNehp3K.jpg"></p><p>假设我们有一个字符串：abcabf</p><blockquote><p>a : 0</p><p>ab : 0</p><p>abc : 0</p><p>abca : a为公共前后缀 1</p><p>abcab: ab为公共前后缀 2</p><p>abcabf: 0</p></blockquote><p>而上方求出这样一个数组便是去比较p字符串的本身,匹配图如下：</p><p><img src="https://s2.loli.net/2022/07/03/14KmUZj7hzg2bPA.jpg"></p><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;        while(j !&#x3D; 0 &amp;&amp; p[j + 1] !&#x3D; p[i]) j &#x3D; ne[j];        if(p[j + 1] &#x3D;&#x3D; p[i]) j ++ ;        ne[i] &#x3D; j;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③字符串匹配"><a href="#③字符串匹配" class="headerlink" title="③字符串匹配"></a>③字符串匹配</h3><p>为什么求出一个ne数组就可以拿来进行匹配了呢？</p><p><img src="https://s2.loli.net/2022/07/03/nzI3E4MfhCJ7x1u.jpg"></p><p>这个是我最常用进行的一个理解图</p><p>我们可以看到有两个子串</p><ul><li>q : abcabcabf</li><li>p : abcabf</li></ul><p>当p匹配到f的时候发现不相等了，那么子串p重新开始匹配的位置是由ne数组进行指示的，f位置前一个位置是b,b的ne值为2，代表此位置的公共前后缀的长度为2，那么我们需要先回到2的位置，也就是p串中的b位置，再看b后面的c是否与上面串相等。相等之后继续往后推移匹配p的串的指针j，知道j指针的值等于p的长度，说明已经匹配成功了。</p><p><font color="red">上面之所以能进行，其实就是因为，p利用ne指针去指示已经匹配过的前缀，我们不再进行重新匹配，而是从匹配好的前缀再重新开始，也就是说，abf和q串的abc字串不相等了，但是abc已经完全匹配好了ab后缀，那我的p串刚好有个ab前缀，那我们直接从ab这个前缀的位置再继续往后匹配，这样就避免了重复匹配的时间复杂度！</font></p><h1 id="三、相关题目"><a href="#三、相关题目" class="headerlink" title="三、相关题目"></a>三、相关题目</h1><p><img src="https://img-blog.csdnimg.cn/39a6860bc4104a7d98cca72c8f9cad77.png"></p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100050, M &#x3D; 10 * N;char p[N], q[M];int ne[N];int main() &#123;    &#x2F;&#x2F;进行相关输入    int n, m;    cin &gt;&gt; n &gt;&gt; (p + 1) &gt;&gt; m &gt;&gt; (q + 1);        &#x2F;&#x2F;先进性ne数组的求解    for(int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;        while(j !&#x3D; 0 &amp;&amp; p[j + 1] !&#x3D; p[i]) j &#x3D; ne[j];        if(p[j + 1] &#x3D;&#x3D; p[i]) j ++ ;        ne[i] &#x3D; j;    &#125;        &#x2F;&#x2F;进行字符串的匹配    for(int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; m; i ++ ) &#123;        while(j !&#x3D; 0 &amp;&amp; p[j + 1] !&#x3D; q[i]) j &#x3D; ne[j];        if(p[j + 1] &#x3D;&#x3D; q[i]) j ++ ;        if(j &#x3D;&#x3D; n) &#123;            cout &lt;&lt; i - n &lt;&lt; &quot; &quot;;            j &#x3D; ne[j];        &#125;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;这一章记录的是自己学习KMP算法的一个笔记吧。我觉得KMP虽然目前没有用到相关的算法，但是他的思想很妙，很多人在刚开始会非常</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sample.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构 -模板" scheme="https://sample.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>模拟单链表</title>
    <link href="https://sample.com/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://sample.com/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-03T03:50:50.000Z</published>
    <updated>2022-07-03T09:10:17.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在很久之前的博客sheepice已经有过对于链表的相关介绍，而当时那篇文章的访问量也比较大，说明还是对大家有一定的帮助，那么这篇文章将继续对链表进行一个介绍，而本次所记录的是单链表的数组模拟，其实就是采用了一个虚表头的做法。</p><p>为什么要用数组进行模拟呢，主要有以下几点：</p><ul><li>我们能够更好的理解单链表的存储方式。</li><li>能够巩固之前对于一般利用结构体构建链表的理解。</li><li>由于数组模拟的单链表能够实现用结构体模拟的链表的一切操作，但是在一些算法题上用数组进行模拟能够更快的跑出程序。</li><li>也可以为之后即将总结一些图论的邻接表的构建打下一定的基础。</li></ul><h1 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h1><h3 id="①初始化操作"><a href="#①初始化操作" class="headerlink" title="①初始化操作"></a>①初始化操作</h3><p>初始化的操作主要进行下面几点：</p><ul><li>头结点指向空(我们用-1代表空节点)</li><li>当前节点idx为0(代表我们没有用一个节点进行操作)</li><li>定义一些数组，存储当前节点和下一个节点的信息</li></ul><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100050 &#x2F;&#x2F;根据题目给的数据去定义一个Nint e[N];   &#x2F;&#x2F;这个数组代表某个节点所存下的值int ne[N];  &#x2F;&#x2F;这个数组代表某个节点的下一个节点位置，相当于next指针void init() &#123;    head &#x3D; -1, idx &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②向头节点插入一个元素"><a href="#②向头节点插入一个元素" class="headerlink" title="②向头节点插入一个元素"></a>②向头节点插入一个元素</h3><p><img src="https://s2.loli.net/2022/07/03/kMLPo4DzBaGXqQb.jpg"></p><p>大家可以看一下上面的图，如果要在整个链表最左边插入一个值，我们只需要四步走</p><ul><li>存下当前节点值val</li><li>存下当前节点的下一个节点值，也就是头指针指向的值</li><li>让头指针指向新进来的值</li><li>idx++ 代表我们已经处理完了一个点，下一个节点的坐标需要比这个点多1。刚开始学的时候这个地方不太清楚，其实主要知道，每个节点都是独一无二的，idx无非只是控制这个节点的下标为多少。</li></ul><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void add_to_head(int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; head;    head &#x3D; idx;    idx ++ ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③删除第k个节点后面的一个数"><a href="#③删除第k个节点后面的一个数" class="headerlink" title="③删除第k个节点后面的一个数"></a>③删除第k个节点后面的一个数</h3><p><img src="https://s2.loli.net/2022/07/03/5ejIVBnwxLvTPqY.jpg"></p><p>这个操作其实比较的简单，我们只需要让第k个节点的next指针指向它下一个节点的下一个节点。</p><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;删除下标为k的后面一个数(D k)void remove(int k)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④在一个节点后面新加上一个值"><a href="#④在一个节点后面新加上一个值" class="headerlink" title="④在一个节点后面新加上一个值"></a>④在一个节点后面新加上一个值</h3><p><img src="https://s2.loli.net/2022/07/03/BD9YMRPUsn2A6fb.jpg"></p><p>这个操作和基本链表一样，也是四步走</p><ul><li>构建新节点记下存下的值</li><li>新节点的next指针指向某节点指向的值</li><li>某节点指向新的节点</li><li>idx++ 代表要处理后续的节点</li></ul><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void add(int k, int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx;    idx ++ ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⑤输出链表"><a href="#⑤输出链表" class="headerlink" title="⑤输出链表"></a>⑤输出链表</h3><p>上面的四个步骤已经包含了绝大部分链表的操作了，那最后就是如何把我们的链表进行输出呢?其实就是我们先让一个指针指向head头指针指向的地方，依次利用ne数组，去探索后续的节点，知道指针指向空节点(也就是值等于我们最初初始化的-1)</p><p>可能用文字描述不太能理解，我们可以看下面的图解，大家也可以跟着图慢慢的走，一定能够发现其中的逻辑。</p><p><img src="https://s2.loli.net/2022/07/03/YfZ9yqvPF6DW1oC.jpg"></p><p>上面的这个图便是模拟了插入两次头节点，然后在中间插入后，最终我们的一个红色线路就是我们的输出线路，而完成这个链表的输出。其实就是下面图中的代码！</p><p><img src="https://s2.loli.net/2022/07/03/g2YHWrvRZN8QseT.jpg"></p><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、题目分享"><a href="#三、题目分享" class="headerlink" title="三、题目分享"></a>三、题目分享</h1><p>上述的所有操作就可以完成一个基本模拟单链表的题目，题目如下：</p><p><img src="https://img-blog.csdnimg.cn/3a334c670a3547ae891844bd5902bdb0.png"></p><p><code>完整AC代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;&#x2F;&#x2F;idx表示节点&#x2F;&#x2F;head表示头结点&#x2F;&#x2F;e表示当前下标点的值&#x2F;&#x2F;ne表示当前下标点的下一个下标的位置int idx &#x3D; 0, head &#x3D; -1;int e[N], ne[N];&#x2F;&#x2F;将值为x插入到头节点的位置(H x)void add_to_head(int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; head;    head &#x3D; idx;    idx ++ ;&#125;&#x2F;&#x2F;删除下标为k的后面一个数(D k)void remove(int k)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;&#x2F;&#x2F;在下标为k的数的后面插入一个数x(I k x)void add(int k, int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx;    idx ++ ;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    while (n -- )     &#123;        char op;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &#39;H&#39;)        &#123;            int x;            cin &gt;&gt; x;            add_to_head(x);        &#125;        else if(op &#x3D;&#x3D; &#39;D&#39;)        &#123;            int k;            cin &gt;&gt; k;            if(k &#x3D;&#x3D; 0) head &#x3D; ne[head];            remove(k - 1);        &#125;        else        &#123;            int x, k;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);        &#125;    &#125;    for(int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    return 0;&#125;作者：sheepice链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;3676581&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;在很久之前的博客sheepice已经有过对于链表的相关介绍，而当时那篇文章的访问量也比较大，说明还是对大家有一定的帮助，那么</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sample.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构 -模板" scheme="https://sample.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>19岁!</title>
    <link href="https://sample.com/2022/06/03/19%E5%B2%81/"/>
    <id>https://sample.com/2022/06/03/19%E5%B2%81/</id>
    <published>2022-06-03T05:48:27.000Z</published>
    <updated>2022-06-03T14:17:58.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="歌曲全览"><a href="#歌曲全览" class="headerlink" title="歌曲全览"></a>歌曲全览</h1><h3 id="①生日快乐歌！-原创"><a href="#①生日快乐歌！-原创" class="headerlink" title="①生日快乐歌！(原创)"></a>①生日快乐歌！(原创)</h3><blockquote><p>歌名: 想与你相遇</p><p>歌词: 佳威</p><p>编曲(等于没有): 佳威</p><p>曲:佳威</p><p>演唱：佳威</p><p>大致内容:虽然取这个歌名会让人觉得有点像一首情歌的感觉?但是其实本人的寓意不是这样的，一直觉得相遇表达的意思非常非常的多，也许不需要人与人面对面的相遇，其实只要在某种程度上，能够达到无论是自己慢慢便强大朝着既定的目标逐步前进，抑或是真的能够有那么一个际遇，让两人现实中遇见，其实都是一种相遇吧。这首歌其实本来想写得比较唯美一点啊，伴奏乐器多一点，但是当时写的时候，越写越觉得应该把自己这一年来最真实的想法通过白话文的方式表达出来，所以词非常直白，曲非常单调，伴奏也只用了一些简单的和弦，因为录音设备的缘故，所以整体听起来可能不是那么协调吧，但是这首歌写出来其实更多的还是一种自己内心的表达吧，反正写完之后自己每次听，感触都挺大的！</p></blockquote><p><font color="blue">因为无法转成外链，所以就放到全民k歌去了哈哈哈！下面是链接:</font></p><ul><li><a href="https://kg3.qq.com/node/lVL5C619sN/play_v2?s=-zheYZ-IB6AW2-5Q&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724614__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">《想与你相遇》</a></li></ul><img src="https://s2.loli.net/2022/06/03/j23aZUCLbPiHl1T.jpg" alt="这首歌的初稿" style="zoom:33%;"><br><h3 id="②爱大家，爱身边的每一个人！"><a href="#②爱大家，爱身边的每一个人！" class="headerlink" title="②爱大家，爱身边的每一个人！"></a>②爱大家，爱身边的每一个人！</h3><ul><li><a href="https://kg3.qq.com/node/gLy1O31GnV/play_v2?s=IGFvf7I-0JATiI5f&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724633__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">《爱你》</a></li></ul><blockquote><p>歌名：《爱你》</p><p>清唱：佳威</p><p>大致内容：就是最近特别洗脑的一首歌！灵魂的爱你两个字把我给唱肉麻了哈哈哈！</p></blockquote><br><h3 id="③只要是你，其他都没关系！"><a href="#③只要是你，其他都没关系！" class="headerlink" title="③只要是你，其他都没关系！"></a>③只要是你，其他都没关系！</h3><ul><li><a href="https://kg3.qq.com/node/P9jTyhu6w7/play_v2?s=0cW3AL0BIxf6808V&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724645__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">我喜欢上你时的内心活动</a></li></ul><blockquote><p>歌名：《我喜欢上你时的内心活动》</p><p>清唱：佳威</p><p>大致内容：循环播放了几个星期的歌，真的陈绮贞的歌就会让人有一种内心非常平静但是又不失浪漫的感觉。说真的在某个阶段的某个时候，真的有想过很久很久以后的生活。世界上七千个地方，我们要定居在哪里呢？我会问你你喜欢哪里，如果是你的话，还是会问你很多很多的问题。如果是你的话，今天的小溪很好看的消息我也想第一时间的分享给你。所以，只要是你的话，一切的一切都可以不仅仅是内心活动了吧。</p></blockquote><br><h3 id="④我们一定会！"><a href="#④我们一定会！" class="headerlink" title="④我们一定会！"></a>④我们一定会！</h3><ul><li><a href="https://kg3.qq.com/node/KM3y8SbYp8/play_v2?s=KAOrcHK_8pE2aKKD&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724660__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">一起向未来</a></li></ul><blockquote><p>歌名：《一起向未来》</p><p>翻唱：赟宝，佳威</p><p>大致内容：和赟宝录制的一首歌，刚开始的声音就是赟宝的声音，他的声线唱这首歌真的很四字弟弟也，他现实生活中就是这样比较的温柔又自带一些搞笑因子，合作非常愉快，虽然中途因为设备啊，声音等问题可整了好久，不过最终的效果还挺不错的！</p></blockquote><br><p><font color="red">下面两个歌是刚上高中的时候录的，非常辣耳朵，不过还挺有意义的，希望通过博客记录下来。</font></p><h3 id="⑤非常中二的十五岁！"><a href="#⑤非常中二的十五岁！" class="headerlink" title="⑤非常中二的十五岁！"></a>⑤非常中二的十五岁！</h3><ul><li><a href="https://kg3.qq.com/node/B3RO1eC8X4/play_v2?s=Ws0Q7fWjLr9WVWkX&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724727__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">十七</a></li></ul><blockquote><p>歌名：《十七》</p><p>翻唱：佳威</p><p>大致内容：这首歌其实当时是上高中的时候，刚高一的时候有一些叛逆，十五岁就去给十七岁唱歌了，也是不知道为什么要那么急，怎么说呢，还有15岁之前的傻瓜作品，自己在整理的时候每当我听到以前的声音的时候，我其实还是会经常性的提起自己的以前。以前的时候真的很单纯很单纯，是什么样就是什么样，自己内心的感受(喜欢，难过，开心……)从来也没有藏着掖着，但是当时都是通过行动，不是一个特别会说的孩纸，所以真的重新听了一下歌前面的旁白，真的就很中二，但是我即使放到现在也不会觉得特别尴尬，因为当时我真的就是那么想的！</p></blockquote><br><h3 id="⑥感谢遇见的每一个人！"><a href="#⑥感谢遇见的每一个人！" class="headerlink" title="⑥感谢遇见的每一个人！"></a>⑥感谢遇见的每一个人！</h3><ul><li><a href="https://kg3.qq.com/node/c4yo65r6dA/play_v2?s=Ws0Q7fWjLvEZtWcb&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724753__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">因为遇见你</a></li></ul><blockquote><p>歌名：《因为遇见你》</p><p>翻唱：佳威</p><p>大致内容：其实当时这首歌是写给我高一刚开始对我影响比较大的学长的。当看到这篇博客的uu们肯定肯定和我已经比较熟了，然后呢，也觉得不管怎么样，能够遇见就是一个非常大的缘分，所以我觉得特别特别的感谢。虽然在生活中，有一些相遇最后都成为了不太好的际遇，但是怎么说呢，每一次的不管是好是坏，觉得还是让一个人多多少少的成长了！所以还是很感谢很感谢。最后，希望自己做自己了，不再去伪装自己，找到原本最真实的自己，迎接后面的每一次相遇！</p></blockquote><br><h1 id="生日文案"><a href="#生日文案" class="headerlink" title="生日文案"></a>生日文案</h1><p>往年的生日的第一句话永远是祝我，祝你生日快乐。今年的话很幸运又可以多祝一个人生日快乐了(露宝)。每次都会想很久很久的生日文案，想总结一下一年来啊遇到了什么新鲜事情和很好的朋友。但是今年的话感觉真的除了在家就是在家，所以反而让自己更加的想着说，要不就回忆一下从前吧。所以在家的时候经常会翻起以前的照片来看，看一下过去的自己。一直在问他，你当时许下的愿望，如今实现了多少。就还挺感叹的，从之前的某个阶段(大概是从初三开始吧)，性格从内向慢慢的打开，随着其接踵而至的是，内心也开始变得不如从前的平静。青春期的各种不懂事猛然而生。其实直到大学我都感觉在某些方面的特别不理智。也有一直想着去控制，但是还是很难真的去抑制自己内心的一个情感。虽然性格变得好像还不错了，但是内心的一些幼稚，直白一直没有能够压下去。所以无论是在处理事情抑或是处理一段关系上，总会在现在的自己看来是一个小丑。这几年来，让我感到比较遗憾的很多事情，其实感觉更多的是人际关系带来的，反而不是之前一直很在乎的成绩。之前看过《被讨厌的勇气》，那一本书其实对我来说影响真的挺大的，但是即使能够很清楚的知道他其中的道理，但是在有的时候还是忍不住去做让自己讨厌自己的东西。比如书中有谈到，人生气的时候其实是没有原因的，而是取决于你的目的，而生气的目的其实就在于想要让被生气的对象认可你并且在某种程度上屈服于你。其实每次因为一些没必要的生气而生气的时候，脑子里面一直回想着这个观点，但还是生气了。又比如，书中有一句话说:你是你地图的中心，所以不用在乎别人怎么看你。但是每次心有不甘或者想要别人觉得自己很厉害的时候，又总会很刻意很刻意的伪装自己，有的时候真的自己也不太知道自己的面貌了 。但是无论是哪一个阶段或者再怎么绝望，我觉得我还是特别特别的幸运的，因为和我生日同一天的她还是一如既往的在前面。‘以前一直觉得一定一定要和她站在一起才行，但是好像越长越大，这样的想法也没越来越没有那么强烈了其实。不知道uu们有没有在你们的生活中出现那么一个人吧，就是也许你们互相不熟悉，仅仅是生活中压根可能不会碰面的人。但是就是因为言语之外的温存让你总能回想的起，其实我也不确定是不是我幻想得太多了，但是放下很多的幻想，我依然还是想在某种程度上能够和她相遇吧。因此为了这样的目标，我觉得很多情况下自己的努力还是会战胜内心的懒惰，我希望能够看到自己的灯塔越来越亮，即使我永远到不了也没关系的。最后呢希望自己继续被照亮着前行吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;歌曲全览&quot;&gt;&lt;a href=&quot;#歌曲全览&quot; class=&quot;headerlink&quot; title=&quot;歌曲全览&quot;&gt;&lt;/a&gt;歌曲全览&lt;/h1&gt;&lt;h3 id=&quot;①生日快乐歌！-原创&quot;&gt;&lt;a href=&quot;#①生日快乐歌！-原创&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="生活篇" scheme="https://sample.com/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/"/>
    
    
    <category term="生活" scheme="https://sample.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>周总结7</title>
    <link href="https://sample.com/2022/05/15/%E5%91%A8%E6%80%BB%E7%BB%937/"/>
    <id>https://sample.com/2022/05/15/%E5%91%A8%E6%80%BB%E7%BB%937/</id>
    <published>2022-05-15T10:49:57.000Z</published>
    <updated>2022-05-15T12:34:11.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的<strong>CSDN博客地址</strong>：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！上周事情贼多，然后又加上周日的时候又在考试，所以上周的总结放到这周一起吧，虽然已经忘记了上周干了什么了哈哈哈！</p><p><font color="red">三叶姐也搭配了hexo地址，在这里强烈推荐<a href="https://sharingsource.github.io/about/">三叶姐的hexo</a></font></p><h3 id="二、算法学习"><a href="#二、算法学习" class="headerlink" title="二、算法学习"></a>二、算法学习</h3><p>这两周，总体来说，好像还是学了很多的算法的，也有蛮多是复习的！</p><p><font color="blue">下面是一些能想到学的和复习的算法</font></p><ol><li>最长公共子序列问题</li><li>最长上升子序列问题</li><li>与质数相关的问题(质数筛选，分解质因子)</li><li>dfs(邻接表存图，树的重心问题)</li><li>bfs(邻接表存图，树的层次问题)</li><li>拓扑排序(先处理入度为0的点)</li><li>并查集(路径压缩，有一道超级难的食物链问题)</li><li>字典树(Trie数):用二维数组模拟，idx表示节点</li><li>KMP算法(其实就是自己匹配自己)</li><li>字符串哈希，用unsigned long long 自动取余，经验值：131转换进制，好像还学了一个叫前缀哈希的东西，记得要减前缀的时候进行左移</li><li>堆排序(down操作，up操作，包括如果要维护第k个插入的数，有一个heap_swap操作！)</li></ol><p><strong>这么看来，这两周学的东西有点多啊，但是还是感觉没能够对模板熟记于心，每次看y总写代码的时候，就感觉特别得心应手，什么时候才能有这样一半的水平啊，好好的背模板吧！</strong></p><h3 id="三、Linux操作系统学习"><a href="#三、Linux操作系统学习" class="headerlink" title="三、Linux操作系统学习"></a>三、Linux操作系统学习</h3><ol><li>巩固了一下tmux和vim的相关用法</li><li>学了shell语法，然后内容比较多，已经在开始复习，后边会进行相关的复习！</li></ol><h3 id="四、生活"><a href="#四、生活" class="headerlink" title="四、生活"></a>四、生活</h3><p>感觉这两周虽然很忙，然后学校的内容很多很多吧，但是好像这两周心态调整的特别好哈哈，虽然每天都在熬夜，有的时候甚至4-5点才睡觉，但是一点也不累，还是比较放松一点的，我觉得好像就是放下了很多很多包袱就会特别放松。这两周也尝试了很多很多的方式，包括自己开一些腾讯会议和同学们去交流一些东西，自己也准备了很多开会用的东西，也希望能够把自己想讲的东西更好的能够传输出去。会议后得到的反馈也非常不错，目前来说，感觉非常好。然后也交了不少的朋友，只能说还蛮有成就感的吧。最开心的当然也是本周末的时候出去看了一个非常好看的电影，只能说真的非常好看，剧情无限反转，惊心动魄的感觉了属于是。然后还进到了5-6年都没进去好好吃过一餐的KFC，我再也不想因为痘痘满脸都是吃不到好吃的东西了，不过确实好贵啊，也正是因为贵，吃不了太多东西，我就没有长胖，这属于是回报性消费了对吧哈哈啊哈哈哈！嗯嗯呢，没想到因为疫情，周总结这个栏目直接在家里面写了整整已经2-3个月了哈哈哈，只能说，感触很大，就是觉得虽然作为一个程序员，好像每天对着电脑写写博客啊，写写算法啊，然后写一些工程，学一些框架就够了，但是总是还是会感受到身边少了一些什么东西吧，不知道在家的时间还需要持续多久吧，但是我真的非常非常希望赶快能够和好朋友们聚在一起，一起玩游戏，一起吃大餐，一起拼搏，因为那样的感觉真的真的非常非常的好，呜呜呜呜。最后的话，希望疫情早日结束，我们一起回到最初的美好吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的&lt;strong&gt;CSDN博客地址&lt;/strong&gt;：&lt;a href=&quot;https://blog.csdn.</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(4)</title>
    <link href="https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-4/"/>
    <id>https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-4/</id>
    <published>2022-05-09T10:55:53.000Z</published>
    <updated>2022-05-09T11:32:40.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、文件重定向"><a href="#一、文件重定向" class="headerlink" title="一、文件重定向"></a>一、文件重定向</h1><p>每个进程默认打开3个文件描述符：</p><ul><li><code>stdin</code>：标准输入，从命令行读取数据，文件描述符为0</li><li><code>stdout</code>：标准输出，从命令行输出数据，文件描述符为1</li><li><code>stderr</code>：标准错误输出，向命令行输出数据，文件描述符为2</li></ul><p>可以用文件重定向将这三个文件重定向到其他的文件当中</p><h3 id="①重定向命令列表"><a href="#①重定向命令列表" class="headerlink" title="①重定向命令列表"></a>①重定向命令列表</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">command &gt; file</td><td align="center">将stdout重定向到file文件内</td></tr><tr><td align="center">command &lt; file</td><td align="center">将stdin重定向到file文件内</td></tr><tr><td align="center">command &gt;&gt; file</td><td align="center">以stdout的形式追加到file文件内</td></tr><tr><td align="center">command n &gt; file</td><td align="center">将文件描述符n重定向到file中</td></tr><tr><td align="center">command n &gt;&gt; flie</td><td align="center">将文件描述符n追加到file文件中</td></tr></tbody></table><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo -e &quot;Hello \c&quot; &gt; output.txt  #将Hello重定向输出到fileecho &quot;World&quot; &gt;&gt; output.txt #将World追加到文件后read str &lt; output.txt #将文件的内容读给strecho $str #输出Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="同时重定向输入输出"><a href="#同时重定向输入输出" class="headerlink" title="同时重定向输入输出"></a>同时重定向输入输出</h4><p>创建bash脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashread aread becho $(expr &quot;$a&quot; + &quot;$b&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建input.txt,脸面的内容为</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.sh   #添加可执行操作acs@2ba77538d358:~$ test.sh &lt; input.txt &gt; output.txt  acs@2ba77538d358:~$ cat output.txt   #里面内容为77<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="引入外部脚本"><a href="#引入外部脚本" class="headerlink" title="引入外部脚本"></a>引入外部脚本</h1><p>类似于c引入一个头文件</p><p>语法格式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">. filename  #注意有一个空格或者source filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><font color="blue">举一个例子</font></p><p>比如先创建一个bash脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ vim test1.sh#然后在vim里面写东西#！ &#x2F;bin&#x2F;bashname&#x3D;wjw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再创建一个新的脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ vim test2.sh#然后在vim里面写东西#！ &#x2F;bin&#x2F;bashsource test1.shecho $name  #会输出wjw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、文件重定向&quot;&gt;&lt;a href=&quot;#一、文件重定向&quot; class=&quot;headerlink&quot; title=&quot;一、文件重定向&quot;&gt;&lt;/a&gt;一、文件重定向&lt;/h1&gt;&lt;p&gt;每个进程默认打开3个文件描述符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stdin&lt;/code&gt;：标</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(3)</title>
    <link href="https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-3/"/>
    <id>https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-3/</id>
    <published>2022-05-09T09:17:34.000Z</published>
    <updated>2022-05-09T10:54:32.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、判断语句"><a href="#一、判断语句" class="headerlink" title="一、判断语句"></a>一、判断语句</h1><h3 id="①if…them形式"><a href="#①if…them形式" class="headerlink" title="①if…them形式"></a>①if…them形式</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if conditionthen语句1语句2fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]thenecho $&#123;a&#125;在范围内fi#输出，3在范围内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②单层if-else"><a href="#②单层if-else" class="headerlink" title="②单层if-else"></a>②单层if-else</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if conditionthen语句1语句2else语句1语句2fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4if ! [&quot;$a&quot; -lt &quot;$b&quot;]echo $&#123;a&#125;不小于$&#123;b&#125;elseecho $&#123;a&#125;小于$&#123;b&#125;fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③多层if-else"><a href="#③多层if-else" class="headerlink" title="③多层if-else"></a>③多层if-else</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if conditionthen语句elif conditionthen语句else then语句fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④case语句"><a href="#④case语句" class="headerlink" title="④case语句"></a>④case语句</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">case 变量($a) in1)语句;;2)语句;;*)语句;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a>二、循环结构</h1><h3 id="①-for-var-in-v1-v2-v3"><a href="#①-for-var-in-v1-v2-v3" class="headerlink" title="① for var in v1 v2 v3"></a>① for var in v1 v2 v3</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#命令格式for var in v1 v2 v3do语句1语句2done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">for i in a 2 ccdoecho $idone#输出a &#x2F;n 2 &#x2F;n cc#------------------------for file in &#39;ls&#39;(&#39;&#39;表示获取某个命令的stdout结果,等同于$())doecho $filedone#输出当前目录下的文件名#------------------------for i in $(sec 1 10)doecho $idone#输出1-10#------------------------for i in (1..20)  #可以输出字母，也可以反向输出doecho $idone#输出1-20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②for-…-…-…"><a href="#②for-…-…-…" class="headerlink" title="②for ((…; …; …))"></a>②for ((…; …; …))</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">for ((i &#x3D; 1; i &lt;&#x3D; 10; i++))doecho $idone#输出1-10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③while…do…done"><a href="#③while…do…done" class="headerlink" title="③while…do…done"></a>③while…do…done</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">while read namedoecho $namedone#读取什么就输出什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④untill…do…done"><a href="#④untill…do…done" class="headerlink" title="④untill…do…done"></a>④untill…do…done</h3><blockquote><p>当条件为真的时候才结束,否则一直循环,当然可以直接用Ctrl + c直接杀死现在的进程！</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">untill [ &quot;$&#123;word&#125;&quot; &#x3D;&#x3D; &quot;yes&quot; ]doread -p &quot;please input yes&quot; worddone#只有当用户输入yes的时候才会结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⑤死循环的处理方式"><a href="#⑤死循环的处理方式" class="headerlink" title="⑤死循环的处理方式"></a>⑤死循环的处理方式</h3><ol><li>如果终端可以打开该程序，输入<code>Ctrl +  c</code>就可以结束了！</li><li><ul><li>使用top命令找到该进程的PID，也就是第一列的数字</li><li>输入<code>kill -9 PID</code>即可关掉这个进程</li></ul></li></ol><h1 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h1><p><code>bash</code>中的函数类似于c中的函数，但是返回值是<code>exit code</code></p><p>如果想要获取函数最后的一个stdout的结果，可以通过<code>echo</code>输出到<code>stdout</code>中然后通过<code>$&#123;function_name&#125;</code>来获取stdout中的结果。</p><p>如果不写<code>return</code>的时候默认<code>return 0</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#示例1func() &#123;name&#x3D;wjwecho &quot;hello $name&quot;&#125;func #直接调用，输出hello wjw#示例2func() &#123;name&#x3D;wjwecho &quot;$name&quot;return 123&#125;output&#x3D;$(func)   #保存wjwret&#x3D;$? #保存123#示例3func() &#123;if [$1 -le 0]thenecho 0return 0fisum&#x3D;$(func &#39;expr $1 - 1&#39;)echo $(expr $sum + $1)&#125;echo $(func 10) #递归输出从0-10的累加和！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、exit命令"><a href="#四、exit命令" class="headerlink" title="四、exit命令"></a>四、exit命令</h1><ul><li><code>exit</code>命令用来退出当前<code>shell</code>进程，并返回一个退出状态</li><li><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态，如果不指定，默认为0</li><li>退出状态只能介于0-255之间的整数，只有0代表正常退出</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashif [ $# -ne 1 ] #如果参数等于1就正常退出，不等于1就非正常退出thenecho &quot;NO&quot;exit 1elseecho &quot;YES&quot;exit 0fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">如果执行该脚本</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.shacs@2ba77538d358:~$ .&#x2F;test.sh wjw 18acs@2ba77538d358:~$ echo $?  #输出的是1acs@2ba77538d358:~$ .&#x2F;test.sh wjwacs@2ba77538d358:~$ echo $?  #输出的是0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、判断语句&quot;&gt;&lt;a href=&quot;#一、判断语句&quot; class=&quot;headerlink&quot; title=&quot;一、判断语句&quot;&gt;&lt;/a&gt;一、判断语句&lt;/h1&gt;&lt;h3 id=&quot;①if…them形式&quot;&gt;&lt;a href=&quot;#①if…them形式&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(2)</title>
    <link href="https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-2/"/>
    <id>https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-2/</id>
    <published>2022-05-06T11:47:13.000Z</published>
    <updated>2022-05-09T10:38:35.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、expr命令"><a href="#一、expr命令" class="headerlink" title="一、expr命令"></a>一、expr命令</h1><p><code>expr</code> 命令用户求表达式的值，格式如下</p><blockquote><p>expr 表达式</p></blockquote><p>表达式说明</p><ul><li>用空格隔开每一项</li><li>用\去转义一些特定字符</li><li>对包含空格和其他特殊字符的字符串要用引号括起来</li><li>最后是返回到stdout(标准输出)中输出结果：所以用$(command) 或者 ‘commmand’进行输出。</li><li>不仅会输出一个结果，同时也会有一个返回值(0代表真，1代表假)</li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">str&#x3D;“Hello World”echo &#39;expr length &quot;$str&quot;&#39;  #输出字符串长度12echo &#39;expr index &quot;$str&quot; aWd&#39; #输出aWd任一个字符最先出现的位置，这里就是W出现在7(下标从1开始),如果找不到就输出0echo &#39;expr substr &quot;$str&quot; 2 3&#39; #输出ell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="①整数表达式"><a href="#①整数表达式" class="headerlink" title="①整数表达式"></a>①整数表达式</h3><p><code>expr</code> 支持普通的算数操作！</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4echo &#39;expr $a + $b&#39; #输出7echo &#39;expr $a \* $b&#39; #输出12echo &#39;expr $a % $b&#39; #输出3echo &#39;expr \( $a + 1 \) \* \( $b + 1 \)&#39; #输出20，等同于(3+1)*(4+1)#除号，加号，减号，取模号都不需要转义#也可以用单引号让其识别不为关键字#比如&#39;expr $a &#39;*&#39; $b&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②逻辑表达式"><a href="#②逻辑表达式" class="headerlink" title="②逻辑表达式"></a>②逻辑表达式</h3><p>和c++大致相同，但是返回值有点点不同，比如|，&amp;两个返回的不仅仅是0或1</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4c&#x3D;0d&#x3D;5echo &#39;expr $c \&amp; $d&#39;  #输出0不再计算decho &#39;expr $a \&amp; $b&#39;  #输出a的值,返回3echo &#39;expr $c \| $d&#39;  #输出d的值,返回4echo &#39;expr $a \| $b&#39;  #输出a的值,不再计算b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、read命令"><a href="#二、read命令" class="headerlink" title="二、read命令"></a>二、read命令</h1><p>从stdin里面读入单行数据,当读到文件结束符<code>Ctrl + d</code>的时候返回<code>exit code</code>,为1则继续读，为0则正常退出！</p><p>参数说明</p><ul><li>-p : 后面可以接提示的信息</li><li>-t : 后面跟秒数，超过该秒数后会自动忽略此行命令</li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashread -p &quot;Please input your name: &quot; -t 30 name #读入用户名，等待30s，用户不输入，自动跳过此命令#echo &quot;hello,$name&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么在终端进行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ .&#x2F;test.shacs@2ba77538d358:~$ Please input your name: #提示用户输入acs@2ba77538d358:~$ wjw #用户进行输入(若30s内不输入则代表name为空，进入下一行命令)acs@2ba77538d358:~$ hello,wjw  #标准输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、echo命令"><a href="#三、echo命令" class="headerlink" title="三、echo命令"></a>三、echo命令</h1><h3 id="①显示普通字符串"><a href="#①显示普通字符串" class="headerlink" title="①显示普通字符串"></a>①显示普通字符串</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo wjw    #引号可以省略echo &quot;wjw&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="②显示转义字符"><a href="#②显示转义字符" class="headerlink" title="②显示转义字符"></a>②显示转义字符</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo &quot;\&quot;hello\&quot;wjw&quot;  #输出“hello”wjwecho \&quot;hello\&quot;wjw    #不加外面引号也可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="③显示换行"><a href="#③显示换行" class="headerlink" title="③显示换行"></a>③显示换行</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo -e &quot;hi\nwjw&quot;  #-e开启转义#可以在终端用 man echo 打开帮助命令，查看一些参数#最后输出hiwjw# -c 强制不换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④显示结果到文件内"><a href="#④显示结果到文件内" class="headerlink" title="④显示结果到文件内"></a>④显示结果到文件内</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ .&#x2F;test.shacs@2ba77538d358:~$ echo &quot;hello,world&quot; &gt; temp.txt#此时会在temp.txt多一个hello，world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="四、printf命令"><a href="#四、printf命令" class="headerlink" title="四、printf命令"></a>四、printf命令</h1><p><font color="red">此命令可能用的不是特别多</font></p><p>和c语言的差不多，只不过用空格去表示括号的内容</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">printf &quot;%10d!\n&quot; 123printf &quot;%.2f!\n&quot; 123.2345print &quot;My name is %s\n&quot; &quot;wjw&quot;  #字符串输出printf &quot;%d * %d &#x3D; %d\n&quot; 2 3 &#39;expr 2\* 3&#39;  #表达式的值作为参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">输出结果</font></p><blockquote><p>​       123!</p><p>123.23</p><p>My name is wjw</p><p>2 * 3 &#x3D; 6</p></blockquote><h1 id="五、test命令"><a href="#五、test命令" class="headerlink" title="五、test命令"></a>五、test命令</h1><h3 id="①逻辑运算符-amp-amp-和-bash里面自带的"><a href="#①逻辑运算符-amp-amp-和-bash里面自带的" class="headerlink" title="①逻辑运算符&amp;&amp;和||(bash里面自带的)"></a>①逻辑运算符&amp;&amp;和||(bash里面自带的)</h3><ul><li>两者均有短路的特性（用来实现类似if，else的功能）</li><li>表达式最终的结果返回退出状态，<font color="red">如果为0则真，反之1则假!</font></li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.shacs@2ba77538d358:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; #输出existacs@2ba77538d358:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; #输出not exist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>test命令用于判断文件的类型，以及对变量做比较。</p><p>test命令用<font color="red">exit code</font>作为返回状态！<font color="red">如果为0则真，反之1则假!</font></p></blockquote><h3 id="②命令格式"><a href="#②命令格式" class="headerlink" title="②命令格式"></a>②命令格式</h3><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">文件是否存在</td></tr><tr><td align="center">-f</td><td align="center">是否是文件</td></tr><tr><td align="center">-d</td><td align="center">是否是目录</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.shacs@2ba77538d358:~$ test -e test.shacs@2ba77538d358:~$ echo $? #返回上个命令的返回状态，输出0代表文件存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">文件是否可读</td></tr><tr><td align="center">-w</td><td align="center">文件是否可写</td></tr><tr><td align="center">-x</td><td align="center">文件是否可执行</td></tr><tr><td align="center">-s</td><td align="center">文件是否为空</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.sh output.txtacs@2ba77538d358:~$ test -x output.txtacs@2ba77538d358:~$ echo $? #返回上个命令的返回状态，输出1代表文件是不可以执行的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">a是否等于b</td></tr><tr><td align="center">-ne</td><td align="center">a是否不等于b</td></tr><tr><td align="center">-gt</td><td align="center">a是否大于b</td></tr><tr><td align="center">-lt</td><td align="center">a是否小于b</td></tr><tr><td align="center">-ge</td><td align="center">a是否大于等于b</td></tr><tr><td align="center">-le</td><td align="center">a是否小于等于b</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ test $a -eq $b    #判断a是否等于bacs@2ba77538d358:~$ test 3 -lt 4acs@2ba77538d358:~$ echo $?  #返回0，代表3小于4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-z CHAR</td><td align="center">判断字符串是否为空，为空则真</td></tr><tr><td align="center">-n CHAR</td><td align="center">判断字符串是否为非空，为非空则真，-n可以省略</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">判断两个字符串是否相等，相等为真</td></tr><tr><td align="center">!&#x3D;</td><td align="center">判断两个字符串是否不相等，不相等为真</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ test -z &quot;wjw&quot; &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出N，代表非空acs@2ba77538d358:~$ test -n &quot;wjw&quot; &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出Y，代表非空acs@2ba77538d358:~$ s1&#x3D;yxcacs@2ba77538d358:~$ s2&#x3D;wjwacs@2ba77538d358:~$ test &quot;s1&quot; &#x3D;&#x3D; &quot;s2&quot; &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出N，代表两个字符串不相等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">两条件是否同时成立</td></tr><tr><td align="center">-o</td><td align="center">两条件是否至少一个成立</td></tr><tr><td align="center">!</td><td align="center">取反，如test ! -x test.txt,不可执行返回真</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework.txt test.shacs@2ba77538d358:~$ test -x test.sh -a -r homework.txtacs@2ba77538d358:~$ echo $?   #返回0，代表第一个文件可读，第二个文件可以执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③判断符号"><a href="#③判断符号" class="headerlink" title="③判断符号[]"></a>③判断符号[]</h3><p>与test的用法几乎是一模一样的，更常用与if语句之中,<font color="red">括号和命令之间也要加空格</font></p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ [ 2 -lt 3 ]acs@2ba77538d358:~$ echo $?  #返回0代表2是小于3的acs@2ba77538d358:~$ [ &quot;s1&quot; &#x3D;&#x3D; &quot;s2&quot; ] &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出N，代表两个字符串不相等注意name&#x3D;wjw wing#不能直接用[ $name &#x3D;&#x3D; &quot;wjw wing&quot;]#需要加上双引号，把空格包含[ “$name” &#x3D;&#x3D; &quot;wjw wing&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、expr命令&quot;&gt;&lt;a href=&quot;#一、expr命令&quot; class=&quot;headerlink&quot; title=&quot;一、expr命令&quot;&gt;&lt;/a&gt;一、expr命令&lt;/h1&gt;&lt;p&gt;&lt;code&gt;expr&lt;/code&gt; 命令用户求表达式的值，格式如下&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(1)</title>
    <link href="https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-1/"/>
    <id>https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-1/</id>
    <published>2022-05-06T08:47:30.000Z</published>
    <updated>2022-05-09T09:30:59.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h1><p><font color="red">本篇好像在hexo网站看不了，请移步到CSDN网站观赏！！！！</font><a href="https://blog.csdn.net/qq_60556896/article/details/124619776?spm=1001.2014.3001.5502">CSDN网站入口</a></p><p>shell是我们通过命令行与操作系统沟通的语言。可以直接在命令行中运行，也可以将一套逻辑组织成一个文件，方便复用。</p><p>linux系统默认使用bash脚本</p><h3 id="①vim-test-sh文件之后-创建一个文件"><a href="#①vim-test-sh文件之后-创建一个文件" class="headerlink" title="①vim test.sh文件之后(创建一个文件)"></a>①<strong>vim test.sh</strong>文件之后(创建一个文件)</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#首行指明bash为默认的脚本解释器#! &#x2F;bin&#x2F;bash#输出hello worldecho &quot;hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②运行方式"><a href="#②运行方式" class="headerlink" title="②运行方式"></a>②运行方式</h3><ol><li><p>bash + 文件名 ： bash test.sh</p></li><li><p>当 ls -l test.sh之后，会发现只有r,w的读写可以进行，需要先加入一个可以执行的操作</p><ul><li>chmod +x test.sh</li></ul><p>如果在当前路径的话: .&#x2F;test.sh</p><p>可以用绝对路径: &#x2F;home&#x2F;acs&#x2F;test.sh</p><p>也可以用相对路径:  ~&#x2F;test.sh #家目录下执行</p></li></ol><h1 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h1><h3 id="①单行注释"><a href="#①单行注释" class="headerlink" title="①单行注释"></a>①单行注释</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 这是一行注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="②多行注释"><a href="#②多行注释" class="headerlink" title="②多行注释"></a>②多行注释</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">:&lt;&lt;EDF注释1注释2注释n&lt;&lt;EOF# EOF可以用其他任意字符串都可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h3 id="①定义变量"><a href="#①定义变量" class="headerlink" title="①定义变量"></a>①定义变量</h3><p>定义变量不需要加$符号</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name1&#x3D;&quot;wjw&quot; #定义变量等号两边不能有空格name2&#x3D;&#39;wjw&#39; #单引号也可以定义name3&#x3D;wjw #也可以不加引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②使用变量"><a href="#②使用变量" class="headerlink" title="②使用变量"></a>②使用变量</h3><p>使用变量的时候需要加上$或者 加上一个{};</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjw #定义变量echo $&#123;name&#125; #输出wjwecho $&#123;name&#125;hhh #输出wjwhhh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="③只读变量"><a href="#③只读变量" class="headerlink" title="③只读变量"></a>③只读变量</h3><p>变量的值是没办法改变的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjwreadonly name #第一种写法declare -r name #第二种写法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="④删除变量"><a href="#④删除变量" class="headerlink" title="④删除变量"></a>④删除变量</h3><p>用unset可以删除变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjwunset nameecho $name #输出空行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑤变量类型"><a href="#⑤变量类型" class="headerlink" title="⑤变量类型"></a>⑤变量类型</h3><ul><li>自定义变量(局部变量)<ul><li>子进程不能访问的变量</li></ul></li><li>环境变量(全局变量)<ul><li>子进程可以访问的变量</li></ul></li></ul><p>自定义变量改成环境变量(下面是在终端下进行操作)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ name&#x3D;wjw #定义变量acs@2ba77538d358:~$ export name #第一种方式acs@2ba77538d358:~$ declear -x name #第二种方式acs@2ba77538d358:~$ exit #退出当前进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>环境变量改成自定义变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ export name&#x3D;wjw #定义环境变量acs@2ba77538d358:~$ declear +x name #改为自定义变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开一个子进程</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ bash #开一个子进程#在子进程下，只可以访问环境变量acs@2ba77538d358:~$ exit 或者 [Ctrl + d]都可以退出子进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑥字符串"><a href="#⑥字符串" class="headerlink" title="⑥字符串"></a>⑥字符串</h3><p>单引号：原样输出，不会转义，也不会直接取值</p><p>双引号：(不加引号) 会转义也会取值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjwecho &#39;hello,$name \&quot;hh\&quot;&#39;    #输出hello,$name \&quot;hh\&quot;echo &quot;hello,$name \&quot;hh\&quot;&quot;    #输出hello,wjw &quot;hh&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取字符串长度</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;&quot;wjw&quot;echo $&#123;#name&#125;   #输出3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提取字串</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;hello,wjwecho $&#123;name:0:5&#125; #提取从0开始的5个字符#此处的定义类似于c++的substring函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、默认变量"><a href="#四、默认变量" class="headerlink" title="四、默认变量"></a>四、默认变量</h1><h3 id="①文件参数变量"><a href="#①文件参数变量" class="headerlink" title="①文件参数变量"></a>①文件参数变量</h3><p>在执行shell脚本的时候，可以向脚本传递参数。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashecho &quot;文件名: &quot;$0echo &quot;第一个参数: &quot;$1echo &quot;第二个参数: &quot;$2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后如果执行该脚本的话：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.shacs@2ba77538d358:~$ .&#x2F;test.sh wjw 18#后续会输出的是文件名: .&#x2F;test.sh第一个参数: wjw第二个参数: 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②其他默认参数变量"><a href="#②其他默认参数变量" class="headerlink" title="②其他默认参数变量"></a>②其他默认参数变量</h3><table><thead><tr><th align="center">参数</th><th align="center">参数的相关说明</th></tr></thead><tbody><tr><td align="center">$#</td><td align="center">代表文件传入的参数个数，如上面例子中的值为4</td></tr><tr><td align="center">$*</td><td align="center">由所有参数构成的用空格隔开的字符串，如“.&#x2F;test.sh wjw 18”</td></tr><tr><td align="center">$@</td><td align="center">每个参数用分别用双引号括起来，“.&#x2F;test.sh” “ wjw” “18”</td></tr><tr><td align="center">$$</td><td align="center">脚本当前运行的进程ID</td></tr><tr><td align="center"><strong>$?</strong></td><td align="center"><strong>上一条命令的退出状态，0表示正常，其他值表示错误</strong></td></tr><tr><td align="center"><strong>$(command)</strong></td><td align="center"><strong>返回command 这条命令的stdout(标准输出)</strong></td></tr><tr><td align="center"><strong>‘command’</strong></td><td align="center"><strong>返回command 这条命令的stdout(标准输出)</strong></td></tr></tbody></table><h1 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h1><p>数组可以存放多个不同类型的值，只支持一维数组，初始化不需要指明数组的大小</p><p><strong>下标从0开始</strong></p><h3 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">array&#x3D;(1 abc &quot;def&quot; wjw) #第一种方法array[0]&#x3D;1     #第二种方法array[1]&#x3D;abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②读取并输出"><a href="#②读取并输出" class="headerlink" title="②读取并输出"></a>②读取并输出</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo $&#123;array[index]&#125;  #读取并输出(隔行输出)echo $&#123;array[@ or *]&#125; #读取整个字符串(空格输出)#没有开到的空间用不上，例如array[0]&#x3D;wjwarray[1000]&#x3D;18echo $&#123;array[*]&#125;  #打印结果为wjw 18echo $&#123;#array[*]&#125; #打印结果为2(代表数组元素个数)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概论&quot;&gt;&lt;a href=&quot;#一、概论&quot; class=&quot;headerlink&quot; title=&quot;一、概论&quot;&gt;&lt;/a&gt;一、概论&lt;/h1&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;本篇好像在hexo网站看不了，请移步到CSDN网站观赏！！！！&lt;/font&gt;&lt;a hre</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>离散化操作</title>
    <link href="https://sample.com/2022/05/01/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
    <id>https://sample.com/2022/05/01/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-01T09:50:36.000Z</published>
    <updated>2022-05-01T10:26:22.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、离散化操作"><a href="#一、离散化操作" class="headerlink" title="一、离散化操作"></a>一、离散化操作</h1><p>什么是离散化操作，这里给一个简单的解答。</p><blockquote><p>假设给你一个数组，元素有1,2,200,30000,400000。按照元素的个数，将最终的数组变成1,2,3,4,5的操作就是离散化。离散化的操作有什么好处呢？</p><p>如果数据非常大，但是元素的个数非常小。我们离散化操作就会节省空间，同时通过这样的操作能够让我们优化时间复杂度！</p></blockquote><h1 id="二、实现方法"><a href="#二、实现方法" class="headerlink" title="二、实现方法"></a>二、实现方法</h1><p>为了满足这样的要求(假设有n个数)，我们只需要让每一个数对应一个下标，而这个下标就是离散化他对应的区间$[1,n]$里面的某一个数！这里主要采用c++的实现操作！下面是具体的实现方法</p><h4 id="①开一个vector数组"><a href="#①开一个vector数组" class="headerlink" title="①开一个vector数组"></a>①开一个vector数组</h4><p>因为后面需要用到库函数，所以会更方便解题，但是其实用哈希表对应也是可以的！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; allis;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="②数据放入数组之中"><a href="#②数据放入数组之中" class="headerlink" title="②数据放入数组之中"></a>②数据放入数组之中</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">allis.push_back(x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③排序之后去重"><a href="#③排序之后去重" class="headerlink" title="③排序之后去重"></a>③排序之后去重</h4><p>去重的目的只为了之后在找数的时候没有重复的数！(其实不去重可能也可以过)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;排序去重    sort(allis.begin(), allis.end());&#x2F;&#x2F;去重的库函数    allis.erase(unique(allis.begin(), allis.end()), allis.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④查找数所在的位置，最后返回应该映射的那一个数"><a href="#④查找数所在的位置，最后返回应该映射的那一个数" class="headerlink" title="④查找数所在的位置，最后返回应该映射的那一个数"></a>④查找数所在的位置，最后返回应该映射的那一个数</h4><p>这里也用了库函数，但是其实就是一个简单的二分，因为排序之后的数组是递增的，所以二分查找加快速度！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int finds(int x) &#123;    int id;    &#x2F;&#x2F;找到第一个大于等于x的数    &#x2F;&#x2F;加1是为了让下标从1开始    id &#x3D; lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;    return id;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④举例分析"><a href="#④举例分析" class="headerlink" title="④举例分析"></a>④举例分析</h4><blockquote><p>假设给你一个数组，元素有1,200,2。我们的第三步操作就会让这个数组变成，1,2,200。假设后续操作遍历需要200的时候，我们就会先利用finds函数，返回3，从而，从头开始遍历的时候数组就会呈现出1，3，2的形式。</p></blockquote><h1 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h1><h3 id="（1）例题1：区间求和"><a href="#（1）例题1：区间求和" class="headerlink" title="（1）例题1：区间求和"></a>（1）例题1：区间求和</h3><p><img src="https://img-blog.csdnimg.cn/676ec2fb1b404c4a9eec4670d784d133.png" alt="区间求和"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这一题乍一看其实就是一个前缀和，然后最后区间查询用前缀和的思想就好了。但是本题的难点就在区间和数的范围都是几乎接近了一个int的大小，如果我们直接用前缀和，从头到尾遍历一遍，首先数组不可能开那么大，其次是即使是O(N)的时间复杂度，因为N过大，也必然会超时。<font color="red">但是我们发现，n和m的值比较的小，所以从他们入手，把我们所有输入的数都进行一个离散化，最后其实就相当于最多求一个(n + 2m)那么多次的一个前缀和！</font>因为输入的数字有n个，然后有2m个断点值(左端点和右端点)。因此如果我们把他们转化到一个非常小的区间去求前缀和，就变得非常的简单！所以套用之前的离散化操作，这里直接给出代码！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 300005;typedef pair&lt;int, int&gt; PII;vector&lt;int&gt; allis;vector&lt;PII&gt; add, query;int a[N], sum[N];int n, m;int finds(int x) &#123;&#125;    int id;    id &#x3D; lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;    return id;    &#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int x, c;        cin &gt;&gt; x &gt;&gt; c;        allis.push_back(x);        add.push_back( &#123;x, c&#125; );        &#125;    for(int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        allis.push_back(l);        allis.push_back(r);        query.push_back( &#123;l, r&#125; );        &#125;        &#x2F;&#x2F;排序去重    sort(allis.begin(), allis.end());    allis.erase(unique(allis.begin(), allis.end()), allis.end());        &#x2F;&#x2F; for(auto alli : allis) cout &lt;&lt; alli &lt;&lt; &quot; &quot;;        &#x2F;&#x2F;处理插入    for(auto item : add) &#123;&#125;        int s &#x3D; finds(item.first);        a[s] +&#x3D; item.second;        &#125;        &#x2F;&#x2F;前缀和    for(int i &#x3D; 1; i &lt;&#x3D; allis.size(); i++) &#123;        sum[i] &#x3D; sum[i - 1] + a[i];        &#125;        &#x2F;&#x2F;查询    for(auto item : query) &#123;        int l &#x3D; finds(item.first), r &#x3D; finds(item.second);        int ans &#x3D; 0;        ans &#x3D; sum[r] - sum[l - 1];        cout &lt;&lt; ans &lt;&lt; endl;        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）例题2：区间合并"><a href="#（2）例题2：区间合并" class="headerlink" title="（2）例题2：区间合并"></a>（2）例题2：区间合并</h3><p><img src="https://img-blog.csdnimg.cn/543283207df9411d8490deea79b3f0ed.png" alt="区间合并"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>因为区间合并的相关知识已经写过博客了，对区间合并不了解的uu们，可以点击这里去看看<a href="https://blog.csdn.net/qq_60556896/article/details/124435766?spm=1001.2014.3001.5501">区间合并的刷题</a>。那么这题就是在区间合并的前提下，加上一个离散化操作，所以非常的简单哈！</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 200000 + 10;PII p[N];vector&lt;int&gt; allis;vector&lt;PII&gt; query;int finds(int x) &#123;    return lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    int count &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        allis.push_back(l);        allis.push_back(r);        query.push_back(&#123;l, r&#125;);    &#125;    &#x2F;&#x2F;去重排序    sort(allis.begin(), allis.end());    allis.erase(unique(allis.begin(), allis.end()), allis.end());    int t &#x3D; 0;    for(auto item : query) &#123;        int l &#x3D; finds(item.first), r &#x3D; finds(item.second);        p[t++] &#x3D; &#123;l, r&#125;;    &#125;    &#x2F;&#x2F;这个地方不能用sort(p.begin(),p.end());    sort(p, p + t);    int st &#x3D; -1, ed &#x3D; -1;    for(int i &#x3D; 0; i &lt; t; i++) &#123;        if(p[i].first &lt;&#x3D; ed) ed &#x3D; max(ed, p[i].second);        else &#123;            count++;            st &#x3D; p[i].first;            ed &#x3D; p[i].second;        &#125;    &#125;    cout &lt;&lt; count &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、离散化操作&quot;&gt;&lt;a href=&quot;#一、离散化操作&quot; class=&quot;headerlink&quot; title=&quot;一、离散化操作&quot;&gt;&lt;/a&gt;一、离散化操作&lt;/h1&gt;&lt;p&gt;什么是离散化操作，这里给一个简单的解答。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设给你一个数组，</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
