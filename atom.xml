<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sheepice的博客</title>
  
  <subtitle>感谢各位家人的访问，希望能跟大家成为朋友</subtitle>
  <link href="https://sample.com/atom.xml" rel="self"/>
  
  <link href="https://sample.com/"/>
  <updated>2022-05-15T12:34:11.845Z</updated>
  <id>https://sample.com/</id>
  
  <author>
    <name>sheepice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周总结7</title>
    <link href="https://sample.com/2022/05/15/%E5%91%A8%E6%80%BB%E7%BB%937/"/>
    <id>https://sample.com/2022/05/15/%E5%91%A8%E6%80%BB%E7%BB%937/</id>
    <published>2022-05-15T10:49:57.000Z</published>
    <updated>2022-05-15T12:34:11.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的<strong>CSDN博客地址</strong>：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！上周事情贼多，然后又加上周日的时候又在考试，所以上周的总结放到这周一起吧，虽然已经忘记了上周干了什么了哈哈哈！</p><p><font color="red">三叶姐也搭配了hexo地址，在这里强烈推荐<a href="https://sharingsource.github.io/about/">三叶姐的hexo</a></font></p><h3 id="二、算法学习"><a href="#二、算法学习" class="headerlink" title="二、算法学习"></a>二、算法学习</h3><p>这两周，总体来说，好像还是学了很多的算法的，也有蛮多是复习的！</p><p><font color="blue">下面是一些能想到学的和复习的算法</font></p><ol><li>最长公共子序列问题</li><li>最长上升子序列问题</li><li>与质数相关的问题(质数筛选，分解质因子)</li><li>dfs(邻接表存图，树的重心问题)</li><li>bfs(邻接表存图，树的层次问题)</li><li>拓扑排序(先处理入度为0的点)</li><li>并查集(路径压缩，有一道超级难的食物链问题)</li><li>字典树(Trie数):用二维数组模拟，idx表示节点</li><li>KMP算法(其实就是自己匹配自己)</li><li>字符串哈希，用unsigned long long 自动取余，经验值：131转换进制，好像还学了一个叫前缀哈希的东西，记得要减前缀的时候进行左移</li><li>堆排序(down操作，up操作，包括如果要维护第k个插入的数，有一个heap_swap操作！)</li></ol><p><strong>这么看来，这两周学的东西有点多啊，但是还是感觉没能够对模板熟记于心，每次看y总写代码的时候，就感觉特别得心应手，什么时候才能有这样一半的水平啊，好好的背模板吧！</strong></p><h3 id="三、Linux操作系统学习"><a href="#三、Linux操作系统学习" class="headerlink" title="三、Linux操作系统学习"></a>三、Linux操作系统学习</h3><ol><li>巩固了一下tmux和vim的相关用法</li><li>学了shell语法，然后内容比较多，已经在开始复习，后边会进行相关的复习！</li></ol><h3 id="四、生活"><a href="#四、生活" class="headerlink" title="四、生活"></a>四、生活</h3><p>感觉这两周虽然很忙，然后学校的内容很多很多吧，但是好像这两周心态调整的特别好哈哈，虽然每天都在熬夜，有的时候甚至4-5点才睡觉，但是一点也不累，还是比较放松一点的，我觉得好像就是放下了很多很多包袱就会特别放松。这两周也尝试了很多很多的方式，包括自己开一些腾讯会议和同学们去交流一些东西，自己也准备了很多开会用的东西，也希望能够把自己想讲的东西更好的能够传输出去。会议后得到的反馈也非常不错，目前来说，感觉非常好。然后也交了不少的朋友，只能说还蛮有成就感的吧。最开心的当然也是本周末的时候出去看了一个非常好看的电影，只能说真的非常好看，剧情无限反转，惊心动魄的感觉了属于是。然后还进到了5-6年都没进去好好吃过一餐的KFC，我再也不想因为痘痘满脸都是吃不到好吃的东西了，不过确实好贵啊，也正是因为贵，吃不了太多东西，我就没有长胖，这属于是回报性消费了对吧哈哈啊哈哈哈！嗯嗯呢，没想到因为疫情，周总结这个栏目直接在家里面写了整整已经2-3个月了哈哈哈，只能说，感触很大，就是觉得虽然作为一个程序员，好像每天对着电脑写写博客啊，写写算法啊，然后写一些工程，学一些框架就够了，但是总是还是会感受到身边少了一些什么东西吧，不知道在家的时间还需要持续多久吧，但是我真的非常非常希望赶快能够和好朋友们聚在一起，一起玩游戏，一起吃大餐，一起拼搏，因为那样的感觉真的真的非常非常的好，呜呜呜呜。最后的话，希望疫情早日结束，我们一起回到最初的美好吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的&lt;strong&gt;CSDN博客地址&lt;/strong&gt;：&lt;a href=&quot;https://blog.csdn.</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(4)</title>
    <link href="https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-4/"/>
    <id>https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-4/</id>
    <published>2022-05-09T10:55:53.000Z</published>
    <updated>2022-05-09T11:27:26.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、文件重定向"><a href="#一、文件重定向" class="headerlink" title="一、文件重定向"></a>一、文件重定向</h1><p>每个进程默认打开3个文件描述符：</p><ul><li><code>stdin</code>：标准输入，从命令行读取数据，文件描述符为0</li><li><code>stdout</code>：标准输出，从命令行输出数据，文件描述符为1</li><li><code>stderr</code>：标准错误输出，向命令行输出数据，文件描述符为2</li></ul><p>可以用文件重定向将这三个文件重定向到其他的文件当中</p><h3 id="①重定向命令列表"><a href="#①重定向命令列表" class="headerlink" title="①重定向命令列表"></a>①重定向命令列表</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">command &gt; file</td><td align="center">将stdout重定向到file文件内</td></tr><tr><td align="center">command &lt; file</td><td align="center">将stdin重定向到file文件内</td></tr><tr><td align="center">command &gt;&gt; file</td><td align="center">以stdout的形式追加到file文件内</td></tr><tr><td align="center">command n &gt; file</td><td align="center">将文件描述符n重定向到file中</td></tr><tr><td align="center">command n &gt;&gt; flie</td><td align="center">将文件描述符n追加到file文件中</td></tr></tbody></table><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><pre class="line-numbers language-shell"><code class="language-shell">echo -e "Hello \c" > output.txt  #将Hello重定向输出到fileecho "World" >> output.txt         #将World追加到文件后read str < output.txt             #将文件的内容读给strecho $str                         #输出Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="同时重定向输入输出"><a href="#同时重定向输入输出" class="headerlink" title="同时重定向输入输出"></a>同时重定向输入输出</h4><p>创建bash脚本</p><pre class="line-numbers language-shell"><code class="language-shell">#! /bin/bashread aread becho $(expr "$a" + "$b")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建input.txt,脸面的内容为</p><pre class="line-numbers language-shell"><code class="language-shell">34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行命令</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.sh   #添加可执行操作acs@2ba77538d358:~$ test.sh < input.txt > output.txt  acs@2ba77538d358:~$ cat output.txt   #里面内容为77<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="引入外部脚本"><a href="#引入外部脚本" class="headerlink" title="引入外部脚本"></a>引入外部脚本</h1><p>类似于c引入一个头文件</p><p>语法格式</p><pre class="line-numbers language-shell"><code class="language-shell">. filename  #注意有一个空格或者source filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><font color="blue">举一个例子</font></p><p>比如先创建一个bash脚本</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ vim test1.sh#然后在vim里面写东西#！ /bin/bashname=wjw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再创建一个新的脚本</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ vim test2.sh#然后在vim里面写东西#！ /bin/bashsource test1.shecho $name  #会输出wjw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、文件重定向&quot;&gt;&lt;a href=&quot;#一、文件重定向&quot; class=&quot;headerlink&quot; title=&quot;一、文件重定向&quot;&gt;&lt;/a&gt;一、文件重定向&lt;/h1&gt;&lt;p&gt;每个进程默认打开3个文件描述符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stdin&lt;/code&gt;：标</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(3)</title>
    <link href="https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-3/"/>
    <id>https://sample.com/2022/05/09/shell%E8%AF%AD%E6%B3%95-3/</id>
    <published>2022-05-09T09:17:34.000Z</published>
    <updated>2022-05-09T10:54:32.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、判断语句"><a href="#一、判断语句" class="headerlink" title="一、判断语句"></a>一、判断语句</h1><h3 id="①if…them形式"><a href="#①if…them形式" class="headerlink" title="①if…them形式"></a>①if…them形式</h3><pre class="line-numbers language-shell"><code class="language-shell">if conditionthen    语句1    语句2fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">a=3b=4if [ "$a" -lt "$b" ] && [ "$a" -gt 2 ]then    echo $&#123;a&#125;在范围内fi#输出，3在范围内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②单层if-else"><a href="#②单层if-else" class="headerlink" title="②单层if-else"></a>②单层if-else</h3><pre class="line-numbers language-shell"><code class="language-shell">if conditionthen    语句1    语句2else    语句1    语句2fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">a=3b=4if ! ["$a" -lt "$b"]    echo $&#123;a&#125;不小于$&#123;b&#125;else    echo $&#123;a&#125;小于$&#123;b&#125;fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③多层if-else"><a href="#③多层if-else" class="headerlink" title="③多层if-else"></a>③多层if-else</h3><pre class="line-numbers language-shell"><code class="language-shell">if conditionthen    语句elif conditionthen    语句else then    语句fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④case语句"><a href="#④case语句" class="headerlink" title="④case语句"></a>④case语句</h3><pre class="line-numbers language-shell"><code class="language-shell">case 变量($a) in    1)        语句        ;;    2)        语句        ;;    *)        语句        ;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a>二、循环结构</h1><h3 id="①-for-var-in-v1-v2-v3"><a href="#①-for-var-in-v1-v2-v3" class="headerlink" title="① for var in v1 v2 v3"></a>① for var in v1 v2 v3</h3><pre class="line-numbers language-shell"><code class="language-shell">#命令格式for var in v1 v2 v3do    语句1    语句2done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">for i in a 2 ccdo    echo $idone#输出a /n 2 /n cc#------------------------for file in 'ls'(''表示获取某个命令的stdout结果,等同于$())do    echo $filedone#输出当前目录下的文件名#------------------------for i in $(sec 1 10)do    echo $idone#输出1-10#------------------------for i in (1..20)  #可以输出字母，也可以反向输出do    echo $idone#输出1-20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②for-…-…-…"><a href="#②for-…-…-…" class="headerlink" title="②for ((…; …; …))"></a>②for ((…; …; …))</h3><pre class="line-numbers language-shell"><code class="language-shell">for ((i = 1; i <= 10; i++))do    echo $idone#输出1-10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③while…do…done"><a href="#③while…do…done" class="headerlink" title="③while…do…done"></a>③while…do…done</h3><pre class="line-numbers language-shell"><code class="language-shell">while read namedo    echo $namedone#读取什么就输出什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④untill…do…done"><a href="#④untill…do…done" class="headerlink" title="④untill…do…done"></a>④untill…do…done</h3><blockquote><p>当条件为真的时候才结束,否则一直循环,当然可以直接用Ctrl + c直接杀死现在的进程！</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">untill [ "$&#123;word&#125;" == "yes" ]do    read -p "please input yes" worddone#只有当用户输入yes的时候才会结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⑤死循环的处理方式"><a href="#⑤死循环的处理方式" class="headerlink" title="⑤死循环的处理方式"></a>⑤死循环的处理方式</h3><ol><li>如果终端可以打开该程序，输入<code>Ctrl +  c</code>就可以结束了！</li><li><ul><li>使用top命令找到该进程的PID，也就是第一列的数字</li><li>输入<code>kill -9 PID</code>即可关掉这个进程</li></ul></li></ol><h1 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h1><p><code>bash</code>中的函数类似于c中的函数，但是返回值是<code>exit code</code></p><p>如果想要获取函数最后的一个stdout的结果，可以通过<code>echo</code>输出到<code>stdout</code>中然后通过<code>$&#123;function_name&#125;</code>来获取stdout中的结果。</p><p>如果不写<code>return</code>的时候默认<code>return 0</code></p><pre class="line-numbers language-shell"><code class="language-shell">#示例1func() &#123;    name=wjw    echo "hello $name"&#125;func #直接调用，输出hello wjw#示例2func() &#123;    name=wjw    echo "$name"    return 123&#125;output=$(func)   #保存wjwret=$?             #保存123#示例3func() &#123;    if [$1 -le 0]    then        echo 0        return 0    fi    sum=$(func 'expr $1 - 1')    echo $(expr $sum + $1)&#125;echo $(func 10) #递归输出从0-10的累加和！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、exit命令"><a href="#四、exit命令" class="headerlink" title="四、exit命令"></a>四、exit命令</h1><ul><li><code>exit</code>命令用来退出当前<code>shell</code>进程，并返回一个退出状态</li><li><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态，如果不指定，默认为0</li><li>退出状态只能介于0-255之间的整数，只有0代表正常退出</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#! /bin/bashif [ $# -ne 1 ] #如果参数等于1就正常退出，不等于1就非正常退出then    echo "NO"    exit 1else    echo "YES"    exit 0fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">如果执行该脚本</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.shacs@2ba77538d358:~$ ./test.sh wjw 18acs@2ba77538d358:~$ echo $?  #输出的是1acs@2ba77538d358:~$ ./test.sh wjwacs@2ba77538d358:~$ echo $?  #输出的是0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、判断语句&quot;&gt;&lt;a href=&quot;#一、判断语句&quot; class=&quot;headerlink&quot; title=&quot;一、判断语句&quot;&gt;&lt;/a&gt;一、判断语句&lt;/h1&gt;&lt;h3 id=&quot;①if…them形式&quot;&gt;&lt;a href=&quot;#①if…them形式&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(2)</title>
    <link href="https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-2/"/>
    <id>https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-2/</id>
    <published>2022-05-06T11:47:13.000Z</published>
    <updated>2022-05-09T10:38:35.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、expr命令"><a href="#一、expr命令" class="headerlink" title="一、expr命令"></a>一、expr命令</h1><p><code>expr</code> 命令用户求表达式的值，格式如下</p><blockquote><p>expr 表达式</p></blockquote><p>表达式说明</p><ul><li>用空格隔开每一项</li><li>用\去转义一些特定字符</li><li>对包含空格和其他特殊字符的字符串要用引号括起来</li><li>最后是返回到stdout(标准输出)中输出结果：所以用$(command) 或者 ‘commmand’进行输出。</li><li>不仅会输出一个结果，同时也会有一个返回值(0代表真，1代表假)</li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">str=“Hello World”echo 'expr length "$str"'  #输出字符串长度12echo 'expr index "$str" aWd' #输出aWd任一个字符最先出现的位置，这里就是W出现在7(下标从1开始),如果找不到就输出0echo 'expr substr "$str" 2 3' #输出ell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="①整数表达式"><a href="#①整数表达式" class="headerlink" title="①整数表达式"></a>①整数表达式</h3><p><code>expr</code> 支持普通的算数操作！</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">a=3b=4echo 'expr $a + $b' #输出7echo 'expr $a \* $b' #输出12echo 'expr $a % $b' #输出3echo 'expr \( $a + 1 \) \* \( $b + 1 \)' #输出20，等同于(3+1)*(4+1)#除号，加号，减号，取模号都不需要转义#也可以用单引号让其识别不为关键字#比如'expr $a '*' $b'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②逻辑表达式"><a href="#②逻辑表达式" class="headerlink" title="②逻辑表达式"></a>②逻辑表达式</h3><p>和c++大致相同，但是返回值有点点不同，比如|，&amp;两个返回的不仅仅是0或1</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">a=3b=4c=0d=5echo 'expr $c \& $d'  #输出0不再计算decho 'expr $a \& $b'  #输出a的值,返回3echo 'expr $c \| $d'  #输出d的值,返回4echo 'expr $a \| $b'  #输出a的值,不再计算b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、read命令"><a href="#二、read命令" class="headerlink" title="二、read命令"></a>二、read命令</h1><p>从stdin里面读入单行数据,当读到文件结束符<code>Ctrl + d</code>的时候返回<code>exit code</code>,为1则继续读，为0则正常退出！</p><p>参数说明</p><ul><li>-p : 后面可以接提示的信息</li><li>-t : 后面跟秒数，超过该秒数后会自动忽略此行命令</li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">#! /bin/bashread -p "Please input your name: " -t 30 name #读入用户名，等待30s，用户不输入，自动跳过此命令#echo "hello,$name"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么在终端进行</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ ./test.shacs@2ba77538d358:~$ Please input your name: #提示用户输入acs@2ba77538d358:~$ wjw #用户进行输入(若30s内不输入则代表name为空，进入下一行命令)acs@2ba77538d358:~$ hello,wjw  #标准输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、echo命令"><a href="#三、echo命令" class="headerlink" title="三、echo命令"></a>三、echo命令</h1><h3 id="①显示普通字符串"><a href="#①显示普通字符串" class="headerlink" title="①显示普通字符串"></a>①显示普通字符串</h3><pre class="line-numbers language-shell"><code class="language-shell">echo wjw    #引号可以省略echo "wjw"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="②显示转义字符"><a href="#②显示转义字符" class="headerlink" title="②显示转义字符"></a>②显示转义字符</h3><pre class="line-numbers language-shell"><code class="language-shell">echo "\"hello\"wjw"  #输出“hello”wjwecho \"hello\"wjw    #不加外面引号也可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="③显示换行"><a href="#③显示换行" class="headerlink" title="③显示换行"></a>③显示换行</h3><pre class="line-numbers language-shell"><code class="language-shell">echo -e "hi\nwjw"  #-e开启转义#可以在终端用 man echo 打开帮助命令，查看一些参数#最后输出hiwjw# -c 强制不换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④显示结果到文件内"><a href="#④显示结果到文件内" class="headerlink" title="④显示结果到文件内"></a>④显示结果到文件内</h3><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ ./test.shacs@2ba77538d358:~$ echo "hello,world" > temp.txt#此时会在temp.txt多一个hello，world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="四、printf命令"><a href="#四、printf命令" class="headerlink" title="四、printf命令"></a>四、printf命令</h1><p><font color="red">此命令可能用的不是特别多</font></p><p>和c语言的差不多，只不过用空格去表示括号的内容</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">printf "%10d!\n" 123printf "%.2f!\n" 123.2345print "My name is %s\n" "wjw"  #字符串输出printf "%d * %d = %d\n" 2 3 'expr 2\* 3'  #表达式的值作为参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">输出结果</font></p><blockquote><p>​       123!</p><p>123.23</p><p>My name is wjw</p><p>2 * 3 &#x3D; 6</p></blockquote><h1 id="五、test命令"><a href="#五、test命令" class="headerlink" title="五、test命令"></a>五、test命令</h1><h3 id="①逻辑运算符-amp-amp-和-bash里面自带的"><a href="#①逻辑运算符-amp-amp-和-bash里面自带的" class="headerlink" title="①逻辑运算符&amp;&amp;和||(bash里面自带的)"></a>①逻辑运算符&amp;&amp;和||(bash里面自带的)</h3><ul><li>两者均有短路的特性（用来实现类似if，else的功能）</li><li>表达式最终的结果返回退出状态，<font color="red">如果为0则真，反之1则假!</font></li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.shacs@2ba77538d358:~$ test -e test.sh && echo "exist" || echo "not exist" #输出existacs@2ba77538d358:~$ test -e test2.sh && echo "exist" || echo "not exist" #输出not exist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>test命令用于判断文件的类型，以及对变量做比较。</p><p>test命令用<font color="red">exit code</font>作为返回状态！<font color="red">如果为0则真，反之1则假!</font></p></blockquote><h3 id="②命令格式"><a href="#②命令格式" class="headerlink" title="②命令格式"></a>②命令格式</h3><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">文件是否存在</td></tr><tr><td align="center">-f</td><td align="center">是否是文件</td></tr><tr><td align="center">-d</td><td align="center">是否是目录</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.shacs@2ba77538d358:~$ test -e test.shacs@2ba77538d358:~$ echo $? #返回上个命令的返回状态，输出0代表文件存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">文件是否可读</td></tr><tr><td align="center">-w</td><td align="center">文件是否可写</td></tr><tr><td align="center">-x</td><td align="center">文件是否可执行</td></tr><tr><td align="center">-s</td><td align="center">文件是否为空</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.sh output.txtacs@2ba77538d358:~$ test -x output.txtacs@2ba77538d358:~$ echo $? #返回上个命令的返回状态，输出1代表文件是不可以执行的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">a是否等于b</td></tr><tr><td align="center">-ne</td><td align="center">a是否不等于b</td></tr><tr><td align="center">-gt</td><td align="center">a是否大于b</td></tr><tr><td align="center">-lt</td><td align="center">a是否小于b</td></tr><tr><td align="center">-ge</td><td align="center">a是否大于等于b</td></tr><tr><td align="center">-le</td><td align="center">a是否小于等于b</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ test $a -eq $b    #判断a是否等于bacs@2ba77538d358:~$ test 3 -lt 4acs@2ba77538d358:~$ echo $?  #返回0，代表3小于4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-z CHAR</td><td align="center">判断字符串是否为空，为空则真</td></tr><tr><td align="center">-n CHAR</td><td align="center">判断字符串是否为非空，为非空则真，-n可以省略</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">判断两个字符串是否相等，相等为真</td></tr><tr><td align="center">!&#x3D;</td><td align="center">判断两个字符串是否不相等，不相等为真</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ test -z "wjw" && echo "T" || echo "N"#输出N，代表非空acs@2ba77538d358:~$ test -n "wjw" && echo "T" || echo "N"#输出Y，代表非空acs@2ba77538d358:~$ s1=yxcacs@2ba77538d358:~$ s2=wjwacs@2ba77538d358:~$ test "s1" == "s2" && echo "T" || echo "N"#输出N，代表两个字符串不相等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">两条件是否同时成立</td></tr><tr><td align="center">-o</td><td align="center">两条件是否至少一个成立</td></tr><tr><td align="center">!</td><td align="center">取反，如test ! -x test.txt,不可执行返回真</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework.txt test.shacs@2ba77538d358:~$ test -x test.sh -a -r homework.txtacs@2ba77538d358:~$ echo $?   #返回0，代表第一个文件可读，第二个文件可以执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③判断符号"><a href="#③判断符号" class="headerlink" title="③判断符号[]"></a>③判断符号[]</h3><p>与test的用法几乎是一模一样的，更常用与if语句之中,<font color="red">括号和命令之间也要加空格</font></p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ [ 2 -lt 3 ]acs@2ba77538d358:~$ echo $?  #返回0代表2是小于3的acs@2ba77538d358:~$ [ "s1" == "s2" ] && echo "T" || echo "N"#输出N，代表两个字符串不相等注意name=wjw wing#不能直接用[ $name == "wjw wing"]#需要加上双引号，把空格包含[ “$name” == "wjw wing"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、expr命令&quot;&gt;&lt;a href=&quot;#一、expr命令&quot; class=&quot;headerlink&quot; title=&quot;一、expr命令&quot;&gt;&lt;/a&gt;一、expr命令&lt;/h1&gt;&lt;p&gt;&lt;code&gt;expr&lt;/code&gt; 命令用户求表达式的值，格式如下&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell语法(1)</title>
    <link href="https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-1/"/>
    <id>https://sample.com/2022/05/06/shell%E8%AF%AD%E6%B3%95-1/</id>
    <published>2022-05-06T08:47:30.000Z</published>
    <updated>2022-05-09T09:30:59.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h1><p><font color="red">本篇好像在hexo网站看不了，请移步到CSDN网站观赏！！！！</font><a href="https://blog.csdn.net/qq_60556896/article/details/124619776?spm=1001.2014.3001.5502">CSDN网站入口</a></p><p>shell是我们通过命令行与操作系统沟通的语言。可以直接在命令行中运行，也可以将一套逻辑组织成一个文件，方便复用。</p><p>linux系统默认使用bash脚本</p><h3 id="①vim-test-sh文件之后-创建一个文件"><a href="#①vim-test-sh文件之后-创建一个文件" class="headerlink" title="①vim test.sh文件之后(创建一个文件)"></a>①<strong>vim test.sh</strong>文件之后(创建一个文件)</h3><pre class="line-numbers language-shell"><code class="language-shell">#首行指明bash为默认的脚本解释器#! /bin/bash#输出hello worldecho "hello world"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②运行方式"><a href="#②运行方式" class="headerlink" title="②运行方式"></a>②运行方式</h3><ol><li><p>bash + 文件名 ： bash test.sh</p></li><li><p>当 ls -l test.sh之后，会发现只有r,w的读写可以进行，需要先加入一个可以执行的操作</p><ul><li>chmod +x test.sh</li></ul><p>如果在当前路径的话: .&#x2F;test.sh</p><p>可以用绝对路径: &#x2F;home&#x2F;acs&#x2F;test.sh</p><p>也可以用相对路径:  ~&#x2F;test.sh #家目录下执行</p></li></ol><h1 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h1><h3 id="①单行注释"><a href="#①单行注释" class="headerlink" title="①单行注释"></a>①单行注释</h3><pre class="line-numbers language-shell"><code class="language-shell"># 这是一行注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="②多行注释"><a href="#②多行注释" class="headerlink" title="②多行注释"></a>②多行注释</h3><pre class="line-numbers language-shell"><code class="language-shell">:<<EDF注释1注释2注释n<<EOF# EOF可以用其他任意字符串都可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h3 id="①定义变量"><a href="#①定义变量" class="headerlink" title="①定义变量"></a>①定义变量</h3><p>定义变量不需要加$符号</p><pre class="line-numbers language-shell"><code class="language-shell">name1="wjw" #定义变量等号两边不能有空格name2='wjw' #单引号也可以定义name3=wjw #也可以不加引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②使用变量"><a href="#②使用变量" class="headerlink" title="②使用变量"></a>②使用变量</h3><p>使用变量的时候需要加上$或者 加上一个{};</p><pre class="line-numbers language-shell"><code class="language-shell">name=wjw #定义变量echo $&#123;name&#125; #输出wjwecho $&#123;name&#125;hhh #输出wjwhhh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="③只读变量"><a href="#③只读变量" class="headerlink" title="③只读变量"></a>③只读变量</h3><p>变量的值是没办法改变的</p><pre class="line-numbers language-shell"><code class="language-shell">name=wjwreadonly name #第一种写法declare -r name #第二种写法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="④删除变量"><a href="#④删除变量" class="headerlink" title="④删除变量"></a>④删除变量</h3><p>用unset可以删除变量</p><pre class="line-numbers language-shell"><code class="language-shell">name=wjwunset nameecho $name #输出空行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑤变量类型"><a href="#⑤变量类型" class="headerlink" title="⑤变量类型"></a>⑤变量类型</h3><ul><li>自定义变量(局部变量)<ul><li>子进程不能访问的变量</li></ul></li><li>环境变量(全局变量)<ul><li>子进程可以访问的变量</li></ul></li></ul><p>自定义变量改成环境变量(下面是在终端下进行操作)</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ name=wjw #定义变量acs@2ba77538d358:~$ export name #第一种方式acs@2ba77538d358:~$ declear -x name #第二种方式acs@2ba77538d358:~$ exit #退出当前进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>环境变量改成自定义变量</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ export name=wjw #定义环境变量acs@2ba77538d358:~$ declear +x name #改为自定义变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开一个子进程</p><pre class="line-numbers language-shell"><code class="language-shell">acs@2ba77538d358:~$ bash #开一个子进程#在子进程下，只可以访问环境变量acs@2ba77538d358:~$ exit 或者 [Ctrl + d]都可以退出子进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑥字符串"><a href="#⑥字符串" class="headerlink" title="⑥字符串"></a>⑥字符串</h3><p>单引号：原样输出，不会转义，也不会直接取值</p><p>双引号：(不加引号) 会转义也会取值</p><pre class="line-numbers language-shell"><code class="language-shell">name=wjwecho 'hello,$name \"hh\"'    #输出hello,$name \"hh\"echo "hello,$name \"hh\""    #输出hello,wjw "hh"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取字符串长度</p><p>&#96;&#96;&#96;shell</p><p>name&#x3D;”wjw”<br>echo $</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概论&quot;&gt;&lt;a href=&quot;#一、概论&quot; class=&quot;headerlink&quot; title=&quot;一、概论&quot;&gt;&lt;/a&gt;一、概论&lt;/h1&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;本篇好像在hexo网站看不了，请移步到CSDN网站观赏！！！！&lt;/font&gt;&lt;a hre</summary>
      
    
    
    
    <category term="linux" scheme="https://sample.com/categories/linux/"/>
    
    
    <category term="linux系统课堂笔记" scheme="https://sample.com/tags/linux%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>离散化操作</title>
    <link href="https://sample.com/2022/05/01/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
    <id>https://sample.com/2022/05/01/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-01T09:50:36.000Z</published>
    <updated>2022-05-01T10:26:22.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、离散化操作"><a href="#一、离散化操作" class="headerlink" title="一、离散化操作"></a>一、离散化操作</h1><p>什么是离散化操作，这里给一个简单的解答。</p><blockquote><p>假设给你一个数组，元素有1,2,200,30000,400000。按照元素的个数，将最终的数组变成1,2,3,4,5的操作就是离散化。离散化的操作有什么好处呢？</p><p>如果数据非常大，但是元素的个数非常小。我们离散化操作就会节省空间，同时通过这样的操作能够让我们优化时间复杂度！</p></blockquote><h1 id="二、实现方法"><a href="#二、实现方法" class="headerlink" title="二、实现方法"></a>二、实现方法</h1><p>为了满足这样的要求(假设有n个数)，我们只需要让每一个数对应一个下标，而这个下标就是离散化他对应的区间$[1,n]$里面的某一个数！这里主要采用c++的实现操作！下面是具体的实现方法</p><h4 id="①开一个vector数组"><a href="#①开一个vector数组" class="headerlink" title="①开一个vector数组"></a>①开一个vector数组</h4><p>因为后面需要用到库函数，所以会更方便解题，但是其实用哈希表对应也是可以的！</p><pre class="line-numbers language-c++"><code class="language-c++">vector<int> allis;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="②数据放入数组之中"><a href="#②数据放入数组之中" class="headerlink" title="②数据放入数组之中"></a>②数据放入数组之中</h4><pre class="line-numbers language-c++"><code class="language-c++">allis.push_back(x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③排序之后去重"><a href="#③排序之后去重" class="headerlink" title="③排序之后去重"></a>③排序之后去重</h4><p>去重的目的只为了之后在找数的时候没有重复的数！(其实不去重可能也可以过)</p><pre class="line-numbers language-c++"><code class="language-c++">//排序去重    sort(allis.begin(), allis.end());//去重的库函数    allis.erase(unique(allis.begin(), allis.end()), allis.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④查找数所在的位置，最后返回应该映射的那一个数"><a href="#④查找数所在的位置，最后返回应该映射的那一个数" class="headerlink" title="④查找数所在的位置，最后返回应该映射的那一个数"></a>④查找数所在的位置，最后返回应该映射的那一个数</h4><p>这里也用了库函数，但是其实就是一个简单的二分，因为排序之后的数组是递增的，所以二分查找加快速度！</p><pre class="line-numbers language-c++"><code class="language-c++">int finds(int x) &#123;    int id;    //找到第一个大于等于x的数    //加1是为了让下标从1开始    id = lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;    return id;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④举例分析"><a href="#④举例分析" class="headerlink" title="④举例分析"></a>④举例分析</h4><blockquote><p>假设给你一个数组，元素有1,200,2。我们的第三步操作就会让这个数组变成，1,2,200。假设后续操作遍历需要200的时候，我们就会先利用finds函数，返回3，从而，从头开始遍历的时候数组就会呈现出1，3，2的形式。</p></blockquote><h1 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h1><h3 id="（1）例题1：区间求和"><a href="#（1）例题1：区间求和" class="headerlink" title="（1）例题1：区间求和"></a>（1）例题1：区间求和</h3><p><img src="https://img-blog.csdnimg.cn/676ec2fb1b404c4a9eec4670d784d133.png" alt="区间求和"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这一题乍一看其实就是一个前缀和，然后最后区间查询用前缀和的思想就好了。但是本题的难点就在区间和数的范围都是几乎接近了一个int的大小，如果我们直接用前缀和，从头到尾遍历一遍，首先数组不可能开那么大，其次是即使是O(N)的时间复杂度，因为N过大，也必然会超时。<font color="red">但是我们发现，n和m的值比较的小，所以从他们入手，把我们所有输入的数都进行一个离散化，最后其实就相当于最多求一个(n + 2m)那么多次的一个前缀和！</font>因为输入的数字有n个，然后有2m个断点值(左端点和右端点)。因此如果我们把他们转化到一个非常小的区间去求前缀和，就变得非常的简单！所以套用之前的离散化操作，这里直接给出代码！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;const int N = 300005;typedef pair<int, int> PII;vector<int> allis;vector<PII> add, query;int a[N], sum[N];int n, m;int finds(int x) &#123;&#125;    int id;    id = lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;    return id;    &#125;int main() &#123;    cin >> n >> m;    for(int i = 1; i <= n; i++) &#123;        int x, c;        cin >> x >> c;        allis.push_back(x);        add.push_back( &#123;x, c&#125; );        &#125;    for(int i = 1; i <= m; i++) &#123;        int l, r;        cin >> l >> r;        allis.push_back(l);        allis.push_back(r);        query.push_back( &#123;l, r&#125; );        &#125;        //排序去重    sort(allis.begin(), allis.end());    allis.erase(unique(allis.begin(), allis.end()), allis.end());        // for(auto alli : allis) cout << alli << " ";        //处理插入    for(auto item : add) &#123;&#125;        int s = finds(item.first);        a[s] += item.second;        &#125;        //前缀和    for(int i = 1; i <= allis.size(); i++) &#123;        sum[i] = sum[i - 1] + a[i];        &#125;        //查询    for(auto item : query) &#123;        int l = finds(item.first), r = finds(item.second);        int ans = 0;        ans = sum[r] - sum[l - 1];        cout << ans << endl;        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）例题2：区间合并"><a href="#（2）例题2：区间合并" class="headerlink" title="（2）例题2：区间合并"></a>（2）例题2：区间合并</h3><p><img src="https://img-blog.csdnimg.cn/543283207df9411d8490deea79b3f0ed.png" alt="区间合并"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>因为区间合并的相关知识已经写过博客了，对区间合并不了解的uu们，可以点击这里去看看<a href="https://blog.csdn.net/qq_60556896/article/details/124435766?spm=1001.2014.3001.5501">区间合并的刷题</a>。那么这题就是在区间合并的前提下，加上一个离散化操作，所以非常的简单哈！</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;typedef pair<int, int> PII;const int N = 200000 + 10;PII p[N];vector<int> allis;vector<PII> query;int finds(int x) &#123;    return lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;&#125;int main() &#123;    int n;    cin >> n;    int count = 0;    for(int i = 1; i <= n; i++) &#123;        int l, r;        cin >> l >> r;        allis.push_back(l);        allis.push_back(r);        query.push_back(&#123;l, r&#125;);    &#125;    //去重排序    sort(allis.begin(), allis.end());    allis.erase(unique(allis.begin(), allis.end()), allis.end());    int t = 0;    for(auto item : query) &#123;        int l = finds(item.first), r = finds(item.second);        p[t++] = &#123;l, r&#125;;    &#125;    //这个地方不能用sort(p.begin(),p.end());    sort(p, p + t);    int st = -1, ed = -1;    for(int i = 0; i < t; i++) &#123;        if(p[i].first <= ed) ed = max(ed, p[i].second);        else &#123;            count++;            st = p[i].first;            ed = p[i].second;        &#125;    &#125;    cout << count << endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、离散化操作&quot;&gt;&lt;a href=&quot;#一、离散化操作&quot; class=&quot;headerlink&quot; title=&quot;一、离散化操作&quot;&gt;&lt;/a&gt;一、离散化操作&lt;/h1&gt;&lt;p&gt;什么是离散化操作，这里给一个简单的解答。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设给你一个数组，</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>周总结6</title>
    <link href="https://sample.com/2022/05/01/%E5%91%A8%E6%80%BB%E7%BB%936/"/>
    <id>https://sample.com/2022/05/01/%E5%91%A8%E6%80%BB%E7%BB%936/</id>
    <published>2022-05-01T09:15:58.000Z</published>
    <updated>2022-05-01T09:49:47.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的<strong>CSDN博客地址</strong>：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、算法学习"><a href="#二、算法学习" class="headerlink" title="二、算法学习"></a>二、算法学习</h3><p>这周因为课内要准备复习，所以好像这周对课外的东西没有看特别多，所以还是以算法学习为主吧！上周认识到了ACwing这个网站，然后知识付费了一下，和朋友购买了一个算法的课程，还挺不错的，<strong>基本是模板题目但是还是常做常新！</strong></p><p><font color="red">下面是这周的一个算法小结(选取一些之前没有写过博客的模板粘上去)：</font></p><h5 id="①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！"><a href="#①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！" class="headerlink" title="①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！"></a>①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！</h5><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;const int N = 100000 + 5;void quick_sort(vector<int> & q, int l, int r) &#123;    if(l >= r) return;    int m = (l + r) >> 1;    int mid = q[m];        int sd = l - 1, ed = r + 1;    while(sd < ed) &#123;        do sd++; while(q[sd] < mid);        do ed--; while(q[ed] > mid);        if(sd < ed) swap(q[sd], q[ed]);    &#125;    quick_sort(q, l, ed);    quick_sort(q, ed + 1, r);&#125;int main() &#123;    int n;    cin >> n;    vector<int> ss;    int num;    for(int i = 0; i < n; i++) &#123;        cin >> num;        ss.push_back(num);    &#125;    quick_sort(ss, 0, n - 1);    for(int i = 0; i < n; i++) cout << ss[i] << " ";&#125;作者：sheepice链接：https://www.acwing.com/activity/content/code/content/3347542/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="②归并排序-加求逆序对-树状数组求逆序对："><a href="#②归并排序-加求逆序对-树状数组求逆序对：" class="headerlink" title="②归并排序(加求逆序对) + 树状数组求逆序对："></a>②归并排序(加求逆序对) + 树状数组求逆序对：</h5><p>两种方式都尝试了一遍，具体代码链接如下：</p><p><a href="https://www.acwing.com/activity/content/code/content/3348147/">树状数组和归并排序求逆序对</a></p><h5 id="③一维，二维前缀和-一维，二维差分"><a href="#③一维，二维前缀和-一维，二维差分" class="headerlink" title="③一维，二维前缀和 + 一维，二维差分"></a>③一维，二维前缀和 + 一维，二维差分</h5><h5 id="④离散化操作-解决了区间和以及区间合并-：这里之后会总结一篇博客的！"><a href="#④离散化操作-解决了区间和以及区间合并-：这里之后会总结一篇博客的！" class="headerlink" title="④离散化操作(解决了区间和以及区间合并)：这里之后会总结一篇博客的！"></a>④离散化操作(解决了区间和以及区间合并)：这里之后会总结一篇博客的！</h5><blockquote><p>本周(其实就这两天)刷算法挺上头的,只能说能力在慢慢提升，之前以为刷的题越多越好，但是其实应该是巩固最起码的模板题目，然后再谈刷题，所以非常推荐y总的《算法基础课》，虽然有点小贵，但是钱得花在刀刃上，不是吗哈哈哈！</p></blockquote><p><font color="blue">附上这两天的刷题记录，上面真的总结到位了：</font></p><p><img src="https://img-blog.csdnimg.cn/25ec5ea3dd5a4a29a816eca74caf5339.png" alt="基础课第一节打卡完成"></p><h3 id="三、运动"><a href="#三、运动" class="headerlink" title="三、运动"></a>三、运动</h3><p><strong>本周的话，采用了一种运动方式，和家人们一起运动打卡，然后也一起听着歌，跑跑步啥的，真的非常的不错！</strong></p><img src="https://img-blog.csdnimg.cn/26c86d0ca32c4dbeb1cfac15f054067c.png" alt="运动打卡" style="zoom:33%;"><h3 id="四、小倾诉"><a href="#四、小倾诉" class="headerlink" title="四、小倾诉"></a>四、小倾诉</h3><p><strong>这周的话，有过不愉快的交谈。其实起因就是自己一直坚持一个比较虚伪的自己吧。明明运气的不公让你觉得自己的努力白费了两年，然后就会为了满足自己内心深处的那一点点自尊和不甘，编出一个让自己心安理得的谎言。然后被狠狠地揭穿了，其实那一刻我内心是无比的内疚和自责的，一个怪自己明明早就已经接受了现实，却还是无法放下过去。一个怪自己明明知道那么多道理，却还是在人面前加厚着自己的外衣。不过真的感谢用火把纸烧出洞的人吧，也许没有这么一个人出现的话，以后永远没有办法去正视在那一方面的自己吧！只可惜很多事情一旦发生，还是会产生各种各样的不堪的后果。这个谎言以后也不会再说了，虽然没有伤害他人，但是却真正地虚伪了不是自己的“我”，希望自己再多努力努力，之后不再嫉妒努力，而是享受那些一起拼搏的日子吧！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的&lt;strong&gt;CSDN博客地址&lt;/strong&gt;：&lt;a href=&quot;https://blog.csdn.</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AcWing刷题1</title>
    <link href="https://sample.com/2022/04/26/AcWing%E5%88%B7%E9%A2%981/"/>
    <id>https://sample.com/2022/04/26/AcWing%E5%88%B7%E9%A2%981/</id>
    <published>2022-04-26T11:12:00.000Z</published>
    <updated>2022-04-26T16:31:32.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近发现一个算法题目的宝藏平台，上面的题目其实都是比较偏向应用题了，所以可能更适合用来提高自己笔试的能力。在这里还没有入口的uu们可以在这里看一看哦：<a href="https://www.acwing.com/about/">AcWing刷题网站</a></p><p>今天其实做了上周的周赛的一个题目，才发现自己很多基础的算法模板都没有掌握，所以只能说我算法还是没有真正的入门吧!今天其实也少稍微的学习了一下，关于区间合并的一个模板问题，题目描述如下：</p><h3 id="二、题目描述"><a href="#二、题目描述" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p><img src="https://img-blog.csdnimg.cn/a6fb2e10963448ab9c51e7bdd31459ba.png" alt="构造数组"></p><h3 id="三、思路"><a href="#三、思路" class="headerlink" title="三、思路"></a>三、思路</h3><p>本题的思路需要一些推导，也不是特别难，我们可以看到假设a数组中的$a_i &#x3D; a_j$的话，那么由于$b_{i + 1}$对于$b_i$来说只有两种可能，要不然和他相同，要不然比他大一，<font color="red">因此对于$a_i &#x3D; a_j$来说，b数组中下标为$[i,j]$必须满足$b_{i} &#x3D; b_j$所以这个区间所有的数字必须相同才能满足条件，那么按照这样的分法，我们是一定可以把一整个区间划分成不同的小段，假设我们划分成了m个小段，对于第一个小段来说，由于题目的限定，$b_0&#x3D;0$因此第一段只可能是0，那么接下来的每一段都有两种选择，要不然等于前面一段的数，要不然等于前面的数加1，因此最后的结果为$2^{m - 1}$。</font></p><p>而在划分区域的时候，我们要进行合并区域的操作，即两个有交集的区间应该取他们两个的并集才能够正确的划分最终的区段。</p><p><font color="blue">举个栗子：</font></p><blockquote><p>假设a[5] &#x3D; {1,2,1,2,3},我们在合并的时候假设要划分到1的时候区间为[0,2],而划分2的时候是[1,3],我们发现这两个区间需要b数组在两个区间内的值要相同，就必须把两个区间合并成为[0,3]即在这整个区间上的b数组的值必须都相同，最后才是最正确的答案，而合并区间的操作，可以利用两个哈希表来进行。</p></blockquote><h3 id="四、合并区间"><a href="#四、合并区间" class="headerlink" title="四、合并区间"></a>四、合并区间</h3><p>我觉得还是有必要说一下如何去合并区间呢？</p><p>①首先我们要开两个哈希表L,R。这两个表代表的含义分别是第i个区间的左边界和右边界。于是我们可以用下面的代码将这些边界预处理到我们的哈希表里面。</p><pre class="line-numbers language-c++"><code class="language-c++">    //好像有可能展示不出,大家知道这个地方是开一个哈希表就好    map<int, int> L,R;    for(int i = 1; i <= n; i++) &#123;        int a;   //a代表数组的第i个数        cin >> a;        R[a] = i;        if(!L.count(a)) L[a] = i;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此在上面的操作之后，我们已经把区间的左边界和右边界预处理好了，接下来就是如何去合并区间呢？</p><p>②合并区间的话，<font color="blue">首先我们需要用一个pair键对将哈希表里面的第一个值存储下来，然后进行一个排序，这样可以让我们在判断区间是否合并的时候是从前往后一段一段的去进行的，就保证了答案的正确性。</font>在合并的过程中就不断的判断下一段的左边界和前一段的右边界的大小关系，从而确定两个集合是否有交集。这样说会有点难理解，所以直接给出代码，便于食用！</p><pre class="line-numbers language-c++"><code class="language-c++">    //m代表区间的数量，l表示前一段左边界，r表示前一段右边界    int m = 0, l = -1, r = -1;    //按照哈希表的第一个元素放到p数组里面    for(auto& [k, v] : L) &#123;        p[m++] = &#123;L[k], R[k]&#125;;    &#125;        sort(p, p + m);    int cnt = 0;    for(int i = 0; i < m; i++) &#123;        //如果后一段的左边界比前一段的右边界还小        if(p[i].x < r) r = max(r, p[i].y);        //否则已经进入到了下一个区间划分        else &#123;            cnt++;            l = p[i].x;            r = p[i].y;        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后进行结果的输出就好了！</p><h3 id="五、AC代码"><a href="#五、AC代码" class="headerlink" title="五、AC代码"></a>五、AC代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>#define x first#define y secondusing namespace std;typedef pair<int, int> PII;const int N = 200050;const int mod = 998244353;PII p[N];int main() &#123;    int n;    cin >> n;    //这里可以用unordered_map速度会很快，但是可能会被TLE       //解决方法就是给两个哈希表一个较大的存储值，比如300010;    //好像有可能展示不出,大家知道这个地方是开一个哈希表就好    map<int, int> L,R;        for(int i = 1; i <= n; i++) &#123;        int a;        cin >> a;        R[a] = i;        if(!L.count(a)) L[a] = i;    &#125;    //m代表区间的数量，l表示前一段左边界，r表示前一段右边界    int m = 0, l = -1, r = -1;    //按照哈希表的第一个元素放到p数组里面    for(auto& [k, v] : L) &#123;        p[m++] = &#123;L[k], R[k]&#125;;    &#125;        sort(p, p + m);    int cnt = 0;    for(int i = 0; i < m; i++) &#123;        //如果后一段的左边界比前一段的右边界还小        if(p[i].x < r) r = max(r, p[i].y);        //否则已经进入到了下一个区间划分        else &#123;            cnt++;            l = p[i].x;            r = p[i].y;        &#125;    &#125;    int res = 1;    for(int i = 0; i < cnt - 1; i++) &#123;       res = res * 2 % mod;    &#125;    cout << res << endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;最近发现一个算法题目的宝藏平台，上面的题目其实都是比较偏向应用题了，所以可能更适合用来提高自己笔试的能力。在这里还没有入口的</summary>
      
    
    
    
    <category term="AcWing刷题篇" scheme="https://sample.com/categories/AcWing%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="AcWing" scheme="https://sample.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>周总结5</title>
    <link href="https://sample.com/2022/04/24/%E5%91%A8%E6%80%BB%E7%BB%935/"/>
    <id>https://sample.com/2022/04/24/%E5%91%A8%E6%80%BB%E7%BB%935/</id>
    <published>2022-04-24T07:27:44.000Z</published>
    <updated>2022-04-24T08:30:24.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、学习"><a href="#二、学习" class="headerlink" title="二、学习"></a>二、学习</h3><h5 id="①算法学习"><a href="#①算法学习" class="headerlink" title="①算法学习"></a>①算法学习</h5><p>其实说实话，这周主要栽在算法上面好久好久，就是记得之前的Carl哥说<font color="blue">算法这个东西就是你觉得一段时间你提升特别快，但是一旦做起题目来的话，你就会发现你压根啥也不会。这周真的非常真实的体会到这个东西，也彻底让自己感到自己在算法上确实是没有任何天赋了，所以有什么办法呢？</font>只好乖乖的积累，希望之后能顺利过大厂的一个面试题就好了吧！</p><p>这里<strong>主要总结一下这周遇到蛮多题目以及链接吧！</strong>其实大部分都是板子题目，但是一旦自己板子不熟悉，压根就不敢动手去写，就比如我到现在还没在力扣上做成功一个线段树的题目呜呜好难受。下面的链接便于之后回来看的时候能够重新做一些题目！</p><hr><p><strong><font color="red">题目分类及链接：</font></strong></p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">统计数组逆序对(树状数组解法)</a></p><p><a href="https://leetcode-cn.com/problems/count-good-triplets-in-an-array/">数组逆序对和顺序对一起统计</a></p><p><a href="https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/">树状数组离散化</a></p><p><a href="https://leetcode-cn.com/problems/QO5KpG/">线段树离散化</a></p><p><a href="https://leetcode-cn.com/problems/erect-the-fence/">二维凸包，数学向量叉乘</a></p><p><a href="https://leetcode-cn.com/problems/course-schedule-iii/">单调队列加贪心维护最值</a></p><hr><blockquote><p>上面的题目大多数是比赛的时候有思路但是最终还是没有写对的，而且我觉得也算是表面模板上比较好的题目，我觉得自己可以之后找个时间，多刷几遍，把模板再仔细的温习。我有个朋友从18年开始到2022年，一年去写一遍线段树的板子，说真的这些板子东西真的很重要！要不然就要我一样，压根不敢写板子，因为太不熟练了！</p></blockquote><h4 id="②操作系统粗学"><a href="#②操作系统粗学" class="headerlink" title="②操作系统粗学"></a>②操作系统粗学</h4><p>因为上周的时候操作系统就已经学到了信号量去空着各个进程的共享和互斥的作用。这周就主要还是学习一些用P,V操作去进行一些题目的理解吧。比如<font color="blue">多消费者，生产者问题，吸烟者问题，哲学家用餐问题。以及初学了管程，管程其实有点像类，对程序员显性，对用户隐性，而且也避免了去思索P，V操作的顺序等等的问题。</font>说个笑话，那个时候我真的想问，那为什么还要学信号量，只是为了考试吗哈哈哈！QAQ</p><h4 id="③英语"><a href="#③英语" class="headerlink" title="③英语"></a>③英语</h4><p>说真的着了魔一样，虽然自己英语真的很差，但是还是听不下英语课，上英语课的时候真的就很迷茫。老师总是会上课提问，但是不好意思的是，每次提问我的页面总是停留在某个算法题目，或者某个课内作业之上。然后一回答就社死。<font color="blue">不过幸运的是，因为自己的社牛吧！直接把英语课上有印象很活跃的东西都加了一遍，然后问各种作业，当然很开心的是，居然加上了一个广西的老乡，这可是在学校上了一个学期都没碰到的事情。只能说老乡见老乡两眼泪汪汪哈哈哈。</font>然后就是英语六级的复习，说复习也没复习，每天听六级听力，一篇文章听2-3遍才能够勉勉强强的听懂，<font color="red">不知道有没有英语听力很好的uu们分享一下英语听力的技巧啊，很欢迎跟本英语蒟蒻的小菜鸟分享一下。</font>希望英语六级的成绩能够稍微好看一点吧呜呜呜！然后就是翻译，我一个连口语都表达不清楚的人，做翻译还是有点痛苦，好多词会，但是一翻译就想不起来了，哇，真的好难好难！</p><h4 id="④总结学习"><a href="#④总结学习" class="headerlink" title="④总结学习"></a>④总结学习</h4><p>这周真的是学到难的一周！果然一个悖论说得没错，你学得越多，你会发现你知道的就越少呜呜！</p><hr><h3 id="三、运动"><a href="#三、运动" class="headerlink" title="三、运动"></a>三、运动</h3><p>这周的话还是有氧运动多一点吧，就还是每天去跑跑步然后跳跳绳之类的，但是这周可恶的天气，让我至少有3天没有去外边运动了，那几天还刚好学的做的东西挺难的然后加上上周比较emo，心态上就调整的不是很好吧！好在这周运动量蛮大，每次运动完一身的汗真的非常的舒服。</p><hr><h3 id="四、音乐"><a href="#四、音乐" class="headerlink" title="四、音乐"></a>四、音乐</h3><p>说真的，其实本来说自己这次寒假回来的时候，要多去学一些编曲啊，乐器啥的，但是真的热度就在前半个月，然后后面两个月，就是啥也没干。我得谢谢上周的emo吧，最起码上一周的emo让我知道我应该去做什么解决我的一些不好的情绪，所以这周开始去弹弹电子琴，吉他，然后哼一些自己内心的旋律，其实之前自己也写过歌，也发行了，虽然是帮别人写的，但是很可惜的是，自己写的词的那个本子不见了，那个时候也没把词哼成曲子，所以还是没有足够热爱吧感觉。<font color="blue">有的时候真的觉得挺奇怪的，因为我明明挺喜欢音乐，也挺希望创造出属于自己的作品，但是每次想去学一个和弦，弹一个曲子，总是进不到一个痴迷的状态，好像练了半个小时就干别的事情去了，似乎从中得到的乐趣真没有和朋友们打上几把游戏来得高涨。感觉时间规划和自己的内心管理真的真的有点不到位。</font></p><hr><h4 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h4><p>最后的话，我这周3天没出去运动就胖了6斤.(真的只胖脸呜呜呜！)</p><p>然后特别特别开心，居然在疫情的时候还能交到新朋友！</p><p>最近的疫情又愈发的严重了，希望uu们都能够戴好口罩，希望我们见面的时候一定还是那健康的我们。</p><p>下周要准备准备考试了，毕竟好久没听课，还是有点慌张！</p><p><strong>所以，下周见咯！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>单调队列初探</title>
    <link href="https://sample.com/2022/04/18/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%88%9D%E6%8E%A2/"/>
    <id>https://sample.com/2022/04/18/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-18T09:15:50.000Z</published>
    <updated>2022-04-18T10:11:44.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天总结的一个东西叫做单调队列，其实单调队列这个名字一听就知道是跟数据结构有关。而之所以命名为这个，肯定说明了他代表队列里面的元素都是成为一个单调的形式存在在队列中的。今天主要介绍两种实现单调队列的方法吧。</p><p>首先考虑这样的一个题目：这是洛谷的P1886<a href="https://www.luogu.com.cn/problem/P1886">滑动窗口单调队列</a>。</p><h4 id="①题目描述如下："><a href="#①题目描述如下：" class="headerlink" title="①题目描述如下："></a>①题目描述如下：</h4><p><img src="https://img-blog.csdnimg.cn/7c11d13af76247afb2d61c477494a958.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="滑动窗口单调队列"></p><p>数据范围为：$1 &lt;&#x3D; n &lt;&#x3D; k &lt;&#x3D; 10^6$。</p><h4 id="②解题思路"><a href="#②解题思路" class="headerlink" title="②解题思路"></a>②解题思路</h4><p>我们不妨以求某个窗口的最小值为例子(最大值同理也可以那么推导)。我们首先做的事情就是，依次的放入元素，到一个我们设置好的队列之中，因为这个队列要满足最后输出的结果是最小值，<font color="red">此时我们的队列应当满足单调递增的顺序</font>，这样的话我们每次输出的结果就是在输出一个队首的元素，保证输出的结果是在队列里面是最小的。那么一旦我即将要入队的元素比我目前队尾的元素要小的话，那么队尾会直接弹出，这是因为队尾元素和即将入队的元素已经在一个窗口里面了，由于即将入队的元素小，那么肯定就会有此滑动窗口元素的最小值不可能是原先队尾的元素了。<font color="red">如果当队首元素的下标已经不包含在滑动窗口里面的话</font>，那么我们要进行一个队首出队的行为，保证后面答案的更新不包括滑动窗口以外的元素！</p><h4 id="③一些问题及举例说明"><a href="#③一些问题及举例说明" class="headerlink" title="③一些问题及举例说明"></a>③一些问题及举例说明</h4><blockquote><p>1.为什么队列要满足单调递增呢？</p><p>我们考虑题目中的样例，当我们1入队以后，3能不能入队呢？答案是能。因为我们无法保证3之后的数字会不会比3还大，假设3之后的数字是4，5，6，……，那么当我们输出第一个答案1之后，滑动窗口往后移动，此时最小值就是3了，所以保证队列是单调递增的。</p></blockquote><blockquote><p>2.如何去判断队首元素不在滑动窗口里面呢？</p><p>要判断队首元素在不在窗口，就是说其坐标是不是比窗口的左边边界要大。这就需要我们另外用方法记录下来队首元素的坐标，比如开一个数组进行坐标的记录。假设我们遍历到第i个元素了，那么滑动窗口的左边界其实就是(i - k),此时就判断他是否比队首元素坐标小就好，如果不是，就让队首元素弹出就好了。</p></blockquote><h1 id="二、实现方法1-数组模拟"><a href="#二、实现方法1-数组模拟" class="headerlink" title="二、实现方法1(数组模拟)"></a>二、实现方法1(数组模拟)</h1><p>其实数组模拟了一个比较底层的数据结构deque,也就是双向队列。这个队列之所以能够满足题目的要求，就是因为，队首和队尾元素都可以进行弹出的操作，也就像一个管道一样，你可以从管道的两头出去，而不仅仅像一个队列一样，只能队首进行弹出。</p><p>以下代码有相关注释，结合前言，大家可以试着走一下程序。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;const int N = 1e+6 + 5;int nums[N];int q[N];  //队列int p[N];  //下标 int main() &#123;    int n, k;    cin >> n >> k;    int head, tail;    for(int i = 0; i < n; i++) &#123;        cin >> nums[i];    &#125;    //输出滑动窗口最小值    head = 0, tail = -1;    for(int i = 0; i < n; i++) &#123;        //如果入队元素比队尾大，就队尾出队         while(head <= tail && q[tail] >= nums[i])        tail--;        //入队操作        q[++tail] = nums[i];        p[tail] = i;        //如果滑动窗口不包括队首元素，队首出队        if(head <= tail && i - k >= p[head])        head++;        //进行输出        if(i - k + 1 >= 0) cout << q[head] <<" ";     &#125;    cout << endl;        //输出滑动窗口最大值    memset(q, 0, sizeof(q));    memset(p, 0, sizeof(p));    head = 0, tail = -1;    for(int i = 0; i < n; i++) &#123;        //如果入队元素比队尾大，就队尾出队         while(head <= tail && q[tail] <= nums[i])        tail--;        //入队操作        q[++tail] = nums[i];        p[tail] = i;        //如果滑动窗口不包括队首元素，队首出队        if(head <= tail && i - k >= p[head])        head++;        //进行输出        if(i - k + 1 >= 0) cout << q[head] <<" ";     &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、实现方法2-deque"><a href="#三、实现方法2-deque" class="headerlink" title="三、实现方法2(deque)"></a>三、实现方法2(deque)</h1><p>我们可以直接用STL自带的deque底层队列进行模拟，这个地方，可以重新设置一下类，然后让队列的入队出队方式有一些细微的变化。这里的代码仅供参考，也是能过的，当然会稍微有点难理解吧,因为用到类和函数重置的相关知识了！</p><p>下面代码依次拼在一起就是最终的AC代码啦！</p><p>不知道为什么这里的代码不给我放到代码块里面，所以为了有更好的观感，可以去我的CSDN里面看这篇文章！</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124255565?spm=1001.2014.3001.5502">CSDN单调队列初探</a></p><blockquote><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int nums[10000005];<br>&#x2F;&#x2F;实现最大值的获取<br>class myqueuemax<br>{<br>   public:<br>       deque<int> que1;<br>       void pop(int value)<br>       {<br>           &#x2F;&#x2F;如果队首元素已经不在滑动窗口才弹出<br>           if(!que1.empty()&amp;&amp;value&#x3D;&#x3D;que1.front())<br>           que1.pop_front();<br>       }<br>       void push(int value)<br>       {<br>           &#x2F;&#x2F;加入的元素是否比队尾大就弹出队尾，保证单调递减<br>           while(!que1.empty()&amp;&amp;value&gt;que1.back())<br>           que1.pop_back();<br>           que1.push_back(value);<br>       }<br>       int front()<br>       {<br>           return que1.front();<br>       }<br>};</int></p><p>&#x2F;&#x2F;实现最小值的获取<br>class myqueuemin<br>{<br>   public:<br>       deque<int> que2;<br>       void pop(int value)<br>       {<br>           &#x2F;&#x2F;如果队首元素已经不在滑动窗口才弹出<br>           if(!que2.empty()&amp;&amp;value&#x3D;&#x3D;que2.front())<br>           que2.pop_front();<br>       }<br>       void push(int value)<br>       {<br>           &#x2F;&#x2F;加入的元素是否比队尾大就弹出队尾，保证单调递增<br>           while(!que2.empty()&amp;&amp;value&lt;que2.back())<br>           que2.pop_back();<br>           que2.push_back(value);<br>       }<br>       int front()<br>       {<br>           return que2.front();<br>       }<br>};</int></p><p>int main()<br>{<br>    myqueuemax que1;<br>    myqueuemin que2;<br>    int k,n;<br>    cin&gt;&gt;n&gt;&gt;k;<br>       &#x2F;&#x2F;最小值的输出<br>    for(int i&#x3D;0;i&lt;n;i++)<br>    {<br>        cin&gt;&gt;nums[i];<br>    }<br>     for(int i&#x3D;0;i&lt;k;i++)<br>    {<br>     que2.push(nums[i]);<br>    }<br>    cout&lt;&lt;que2.front()&lt;&lt;” “;<br>    for(int i&#x3D;k;i&lt;n;i++)<br>    {<br>        que2.pop(nums[i-k]);  &#x2F;&#x2F;直接利用下标对应的元素判断队首是否还在队列中<br>        que2.push(nums[i]);<br>        cout&lt;&lt;que2.front()&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>   &#x2F;&#x2F;最大值的输出<br>    for(int i&#x3D;0;i&lt;k;i++)<br>    {<br>     que1.push(nums[i]);<br>    }<br>    cout&lt;&lt;que1.front()&lt;&lt;” “;<br>    for(int i&#x3D;k;i&lt;n;i++)<br>    {<br>        que1.pop(nums[i-k]);  &#x2F;&#x2F;直接利用下标对应的元素判断队首是否还在队列中<br>        que1.push(nums[i]);<br>        cout&lt;&lt;que1.front()&lt;&lt;” “;<br>    }<br>}</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;今天总结的一个东西叫做单调队列，其实单调队列这个名字一听就知道是跟数据结构有关。而之所以命名为这个，肯定说明了他代表队列里面</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>周总结4</title>
    <link href="https://sample.com/2022/04/17/%E5%91%A8%E6%80%BB%E7%BB%934/"/>
    <id>https://sample.com/2022/04/17/%E5%91%A8%E6%80%BB%E7%BB%934/</id>
    <published>2022-04-17T07:43:50.000Z</published>
    <updated>2022-04-17T08:24:10.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、学习"><a href="#二、学习" class="headerlink" title="二、学习"></a>二、学习</h3><p>①c++prime看完了第12章</p><p>②英语每天留了40min的复习时间</p><p>③课内还是只听了微积分，课内作业也按时写完了</p><p>④学了线段树，这周写了有三篇博客：两篇线段树，一篇数位dp。</p><p>⑤操作系统学了信号量机制下怎么实现进程的同步和互斥，包括相关的问题（消费者，生产者进程）。</p><p>⑥力扣每日一题坚持到了59天</p><p>⑦参加了个人赛，AC了两个，排到2000多了，但是因为自己起晚了，好像比赛开始了1个半小时才去打的，第三题是线段树的一个写法，但是好像有点离散的思想在里面，导致学了线段树还是不是太会。</p><p>⑧知识星球的打卡取消了吧，感觉好像打卡只是一个形式，还是别浪费这个时间了。</p><h3 id="三、运动"><a href="#三、运动" class="headerlink" title="三、运动"></a>三、运动</h3><p>这周其实还是有坚持每天去外面跑步跳绳，然后让自己更加充满活力一点。但是周五开始一直到周日也就是今天，我们这边一直一直再下雨，所以这几天都没有运动，不过待会在家里面运动运动吧！</p><h3 id="四、杂言"><a href="#四、杂言" class="headerlink" title="四、杂言"></a>四、杂言</h3><p>其实上周说，要什么一天认真的去专注做好学习这一件事情，然后尝试了一下，发现自己还是没能够坚持下来。甚至有一些时间自己的精神高度紧绷了，然后导致晚上睡觉前怎么也睡不着，然后就刷手机看视频什么的，然后睡觉的时候，还多次冒冷汗，然后就醒来了。我也不知道怎么了，就可能一直想去学习更多的东西，但是有的时候，即使已经有了什么计划，我总是会觉得差了点什么东西。也许是我们计算机这个行业太卷了，我们是需要不断的学习新的东西就丰富自己各个方面的知识，但是也是因为这个想法，在学习知识的过程，好像兴趣越来越少了。有的时候，躺在床上，刷刷手机，和朋友们打打游戏，时间过去非常的快，但是我觉得那样的生活好像对于现在的我来说，真的比我像某段时间一样疯狂的学习充实得很多。我总觉得目前来说，身边还是少了些什么东西。也许是少了一些动力，又或者是少了一些陪伴。我挺知道这个行业或者说很多的行业都犹如行业本身一般，天生就是孤独的，可是这份孤独就真的有点如同现在飘在天上的乌云一般，如果你问他，你能不能快点走开啊！我现在的心情真的很烦很烦！他也许会看都不看你一眼，倔强着他那黑色到遮住天空的身体，然后吐了吐口水，天上瞬间就会下起倾盆的大雨。这一周的我真的好不喜欢下雨天，也许雨滴一直滴在我心中的某个地方，我一直在心里去找水滴的位置。可是有的时候，真就就是只能听到响声，还是找不到那个位置……这周疯狂的痴迷上了一个剧，其实很久很久之前就不会再去追一些什么《校园偶像剧》了，但是那部剧给我的感觉还是能找到一些让自己慰藉的感觉。虽然我觉得每个人的一生中，都很难去上演偶像剧一般的青春，偶像剧一般的爱情和友情，但是并不能妨碍你内心深处对看到的美好的一个期望吧！至此，还是希望能够慢慢去调整一下自己吧，我相信，会慢慢好起来的。</p><h3 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h3><p>贴上这周博客的网址吧</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124135034?spm=1001.2014.3001.5501">力扣刷题4</a></p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124178530?spm=1001.2014.3001.5501">力扣刷题5</a></p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124149805?spm=1001.2014.3001.5501">线段树详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题5</title>
    <link href="https://sample.com/2022/04/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%985/"/>
    <id>https://sample.com/2022/04/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%985/</id>
    <published>2022-04-14T09:32:12.000Z</published>
    <updated>2022-04-14T10:23:30.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解的灵感来源于我自己看了很多神犇的题解，真的会很有收获。</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h1 id="二、数位dp初刷"><a href="#二、数位dp初刷" class="headerlink" title="二、数位dp初刷"></a>二、数位dp初刷</h1><p><img src="https://img-blog.csdnimg.cn/372be999948a4fd587aa24b90da22d48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="组合题dp"></p><h1 id="三、思路"><a href="#三、思路" class="headerlink" title="三、思路"></a>三、思路</h1><p>这题其实如果用我们高中学的组合的思想，可以做。因为他本身就是一个组合的题目，也就是说，最简单的思路就是，分析不同位数情况下构成的小于n的情况。所以很容易得到，一共只有两种情况</p><ul><li>情况一：构成的数字比要求数字的位数小</li><li>情况二：构成的数字比要求数字的位数大</li></ul><h3 id="①情况一"><a href="#①情况一" class="headerlink" title="①情况一"></a>①情况一</h3><p><font color="red">对于情况一来说，我们很容易进行分析，就是假设当前需要构成的位数为i,我们可以选择的数就是digits数组的长度，因此这种情况的结果累加的代码比较简单，直接给出：</font></p><pre class="line-numbers language-c++"><code class="language-c++">//位数不相同的情况//m代表的是数字n的位数一共有多少位//m - 1就可以满足i所代表的位数一定小于n所代表的位数        for(int i = 1; i <= m - 1; i++) &#123;            ans += pow(lent,i);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②情况二的文字描述"><a href="#②情况二的文字描述" class="headerlink" title="②情况二的文字描述"></a>②情况二的文字描述</h3><p><font color="red"><del>对于情况二来说，由我们高中的知识就可以知道，我们可以依次的去比较每一位数在原digits的位置(由于数组是一个递增的情况)，所以当我们找到某个位置的时候，我们就能确定在位置之前的数，都是小于本位置，也就是可以进行一个选择。但是在这个地方，我们要知道不能完全依赖于这样的思想去写题目。</del></font></p><blockquote></blockquote><p><strong>就是假设我们现在选择到了4567的其中某一位且一定要从高位选起(也就是先选2所对应的位置)，这是为什么呢。比如我们给到的选择为1，2，3我们会发现在选择第一个高位的时候，无论我们选择什么，都能满足千位的数一定比4小，那根据乘法原理，很显然所有的答案其实就是$3×3×3×3$，也就是每个位置上都有3种选择</strong></p><p><strong>考虑一种情况，如果考虑$n&#x3D;4567$的时候给到的选择为2，4，8，9呢？此时我们发现如果选择4的时候，会有两种选择2，4但是出于考虑，我们并不能直接说第一个位置2，4都能选，因为我们无法保证选完4之后，是否后面的选择能够保证百位上的数比5小，因此在计算第一位的时候，我们必须只能选2，然后后面的三个位置任意选,也就是$1×3×3×3$,那么很多人在这里就不理解，那4如果作为第一位呢？其实他放到了后面的判断中去了，因为当把4前面的2选完以后，如果后面的操作还能进行，就已经固定了千位为4，然后再进行后面结果的积累。</strong></p><p><font color="red">所以最终的结果一定是不断的去更新每一位之后的选择可能性，因为我们已经确定好了位数之前的可能的结果，这也就是正确解答这个题目的一个顺序!当然如果大家不能理解的话，可以跟着后面的代码进行走一遍，然后多举一些例子辅助性的理解！</font></p><h3 id="③情况二的数学描述"><a href="#③情况二的数学描述" class="headerlink" title="③情况二的数学描述"></a>③情况二的数学描述</h3><p>跟据情况二的文字描述，下面把它用数学语言再进行描述一遍。假设一个数字为n，这个数字一共的位数为len,题目给我们选择的大小位changes(也就是digits数组的长度)。如果我们此时正在确定该位数的第k位时候的结果(也就是说前k位的结果已经被统计确认好了)。我们首先要找到digits数组中的一个位置l(数组已经转化为int类型了)，此位置满足$digits[l] &lt;&#x3D; n[k]$(其中n[k]代表第k位代表的数字)，会分为三种情况：</p><ul><li><p>①$digits[l] &lt; n[k]$：说明l位置包括l在内的数都可以填充这个位置，也就是这个位置有$l+1$种可能性(别忘了下标是从0开始的),当确定这个位置之后，剩余的位置可以任意的进行选择也就是有$pow(len-k,changes)$。所以累加的结果应该为:$(l+1)×pow(len-k,changes)$,此后的结果，因为已经被全部确认了，所以循环要直接<strong>break</strong>!!</p></li><li><p>②$digits[l] &#x3D; n[k]$：说明l位置不包括l在内的数都可以填充这个位置(因为l位置后面还是一个未知的结果，应该等到下一次循环再进行累加)，也就是这个位置有$l+1$种可能性(别忘了下标是从0开始的),当确定这个位置之后，剩余的位置可以任意的进行选择也就是有$pow(len-k,changes)$。所以累加的结果应该为:$(l+1)*pow(len-k,changes)$</p></li><li><p>③找不到满足$digits[l] &lt;&#x3D; n[k]$条件的数:直接break！</p></li></ul><h1 id="四、AC代码"><a href="#四、AC代码" class="headerlink" title="四、AC代码"></a>四、AC代码</h1><p>综上所述，最后把代码全部贴出来，仅供参考。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int atMostNGivenDigitSet(vector<string>& digits, int n) &#123;        int lent = digits.size();        vector<int> nums(lent, 0);        for(int i = 0; i < lent; i++) &#123;            nums[i] = digits[i][0] - '0';        &#125;        long long ans = 0;        //求出n的位数以及每一位数字上的数        vector<int> nmb;        while(n != 0) &#123;            nmb.push_back(n % 10);            n /= 10;        &#125;        int m = nmb.size();   //一共的位数        //位数不相同的情况        for(int i = 1; i <= m - 1; i++) &#123;            ans += pow(lent,i);        &#125;        //位数相同的情况        for(int i = m - 1, p = 1; i >= 0; i--, p++) &#123;            //因为数组的递增，可以用二分去寻找位置            //先找到小于等于此位数的第一个位置            //当然其实因为数组的常量比较小，直接循环找也没有问题的            int l = -1, r = lent;            while(l + 1 != r) &#123;                int mid = (l + r) >> 1;                if(nums[mid] > nmb[i]) r = mid;                else l = mid;            &#125;            if(l == -1) break;            else if(nums[l] == nmb[i]) &#123;                ans += l * pow(lent, m - p);                //如果就连最后一位都相等的时候，一定要记得加上与本身完全相同的那一个结果                //因为循环后不会再继续探索后面的结果了                //这里可以举一些例子帮助理解                if(i == 0) ans++;            &#125;            else &#123;                ans += (l + 1) * pow(lent, m - p);                //已经找到了所有结果了记得break                break;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="动态规划" scheme="https://sample.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线段树初探</title>
    <link href="https://sample.com/2022/04/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://sample.com/2022/04/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-13T00:48:46.000Z</published>
    <updated>2022-04-14T10:15:37.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线段树的相关概念"><a href="#一、线段树的相关概念" class="headerlink" title="一、线段树的相关概念"></a>一、线段树的相关概念</h1><h3 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h3><p>什么是线段树呢？首先默认很多同学已经知道树这个结构了。也就是说，我们要用树的每一个节点去存下每一段数，我觉得线段树的名字由来大概如此吧！我们可以看下的图</p><p><img src="https://img-blog.csdnimg.cn/f96a5cc24c4c4d86989ef7b0f60c4aea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树图解"></p><p><strong>上面的图就是线段树上的每一个节点所存的数代表的含义，比如一个线段的左编号为l，右编号为r，那么这个线段所代表的就是$\sum_ {i&#x3D;l}^{r}nums[i]$,最终呈现的一颗树如下图。</strong></p><p><img src="https://img-blog.csdnimg.cn/4437b4713e424355a0743e5902fa3564.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="整个线段树的图形"></p><blockquote><p>而蓝色标记的数字代表树上节点的编号，这个是在二叉树里面的编号，所以可以知道每一个节点左儿子和右儿子的编号，假设当前的编号k, 那么他的<font color="red">左儿子为：2k(k &lt;&lt; 1),右儿子为：2k+1(k&lt;&lt;1|1)</font>,这里加红的地方大家可以注意一下，因为一般来说，位运算能比较快的去遍历一整颗树，所以在后面的代码全部由位运算代替左右儿子的遍历。</p></blockquote><h3 id="②好处"><a href="#②好处" class="headerlink" title="②好处"></a>②好处</h3><p>首先呢，由于线段树是一个二叉树，因此它可以让时间复杂度为$O(N)$的代码降低为$log_2(N)$的时间复杂度，在数据大的时候，很有可能就是这样的时间差距，带来更多的收益。那么线段树到底会解决什么样的问题，那么复杂的一棵树，为什么我一定要拿来用呢？有几个点：<font color="red">如果我们多次修改某个区间，求区间和又或者是多次让某个区间变成一个数</font>,类似这样的问题是可以用线段树的。当然这些问题是可以用线段数组来写的，但是有的时候我们会不得不用线段树，比如多次将一个区间变成同一个数。当然线段树的很多功能可以通过树状数组来代替，如果能够使用树状数组写的题目，最好能够优先选择树状数组。所以为什么还要去学习线段树呢？我觉得在刚开始我一直很畏惧去学，但是经过一天的学习之后我发现，学习完线段树，不仅是多了一个解决问题的手段，多学了一个数据结构，更多的是对递归，分治的思想又加深了。所以建议uu们都可以去学习这样的一颗复杂但是优美的树！</p><h1 id="二、线段树的基本操作（1）"><a href="#二、线段树的基本操作（1）" class="headerlink" title="二、线段树的基本操作（1）"></a>二、线段树的基本操作（1）</h1><h3 id="①建树"><a href="#①建树" class="headerlink" title="①建树"></a>①建树</h3><p>毫无疑问对于这样的一个数据结构来说，我们肯定是得先要把它建出来。这样建树的过程其实在树的学习中，大家肯定都是会的，而因为线段树的定义不同，因此我们要在每次递归回溯的过程，让节点所代表的值加上他左子树和右子树的值，才最终代表某个节点是由下面子树的和而构建来的，具体代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②修改单个点的值"><a href="#②修改单个点的值" class="headerlink" title="②修改单个点的值"></a>②修改单个点的值</h3><p>如果题目要求让某个点加上一个val值的话，很显然，在更新一整颗树的时候，每一个线段带有该点都必须一起的进行更新，然后在更新的过程的时候，会有一个必要条件，也就是更新点的下标一定是会被包含在每次递归的左右区间之内的，所以有如下的代码。</p><pre class="line-numbers language-c++"><code class="language-c++">//进行单个数的加值void add(int k, int l, int r, int x, int val) &#123;    //改变的数根据递归肯定会在[l, r]的区间之内     sum[k] += val;    if(l == r) return;    int m = (l + r) >> 1;    //要改变的数在左子树     if(x <= m) &#123;        add(k << 1, l, m, x, val);    &#125;    //要改变的数在右子树     else &#123;        add(k << 1 | 1, m + 1, r, x, val);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完成上面的操作之后，就可以让每一颗树进行对应的更新了，因此如果在次基础上，如果我们要查询一段区间和的时候，我们其实只需要递归的去计算每个区间的和就好了</strong></p><h3 id="③针对只修改了单个点值的区间查询"><a href="#③针对只修改了单个点值的区间查询" class="headerlink" title="③针对只修改了单个点值的区间查询"></a>③针对只修改了单个点值的区间查询</h3><p><font color="red">这里可以注意一下标题，只针对修改了单个点值的区间查询，因为在这个前提下的计算和之后的计算有着不同的地方，所以先看一个点，再慢慢推进到后面的点。</font>这里的操作还是以下图为例子：</p><p><img src="https://img-blog.csdnimg.cn/f96a5cc24c4c4d86989ef7b0f60c4aea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树图解"></p><blockquote><p>因为对于这里的递归会有很多的不理解的地方，在这稍作提示。如果我们在做一个区间计算的时候，如果计算的区间刚好在左子树，那么我们最后只需要递归左子树的和就好了，比如在编号为①的时候，我们要查找$[1,2]$区间的和，那么其实只需要到编号为②的地方去计算，右子树同理。那么如果我们跨了区间怎么半呢？比如在上图我要查找$[2,4]$区间的和呢，也很简单，只不过就是左子树的区间$[2,3]$和右子树的区间$[3,4]$两个计算的结果加在一起，具体很多的注释加在代码内，建议读者可以用一些例子理解这个递归式子。而下面第一行注释的lazy标记是后面要介绍的内容！</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//计算某个区间的和，不含有lazy标记 int cal(int k, int l, int r, int x, int y) &#123;    if(l == x && r == y) &#123;        return sum[k];     &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return cal(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return cal(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return cal(k << 1, l, m, x, m) +         cal(k << 1 | 1, m + 1, r, m + 1, y);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④例题模板1"><a href="#④例题模板1" class="headerlink" title="④例题模板1"></a>④例题模板1</h3><p><img src="https://img-blog.csdnimg.cn/745ab82a49654f21a1ccc5b8c33fe9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="例题1"></p><p>​                                                                                             <a href="https://www.luogu.com.cn/problem/P3374">例题1入口</a></p><p><strong>这个例题将我们所说的结合起来就可以写了的，当然他是树状数组的一个板子，之所以用线段树去写，只是为了加深对线段树的熟悉度罢了。</strong></p><h3 id="⑤AC全部代码"><a href="#⑤AC全部代码" class="headerlink" title="⑤AC全部代码"></a>⑤AC全部代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;//开辟其他数组的时候最好为4n让数组不会产生越界的情况 int nums[500005];  //数据的存储 int sum[2000010];   //区间和的存储 int lz[2000010];     //lazy标记的存储int n, m;//进行线段树的构建 void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;//进行单个数的加值void add(int k, int l, int r, int x, int val) &#123;    //改变的数根据递归肯定会在[l, r]的区间之内     sum[k] += val;    if(l == r) return;    int m = (l + r) >> 1;    //要改变的数在左子树     if(x <= m) &#123;        add(k << 1, l, m, x, val);    &#125;    //要改变的数在右子树     else &#123;        add(k << 1 | 1, m + 1, r, x, val);     &#125;&#125;//计算某个区间的和，不含有laze标记 int cal(int k, int l, int r, int x, int y) &#123;    if(l == x && r == y) &#123;        return sum[k];     &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return cal(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return cal(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return cal(k << 1, l, m, x, m) +         cal(k << 1 | 1, m + 1, r, m + 1, y);    &#125;&#125;int main() &#123;    cin >> n >> m;    for(int i = 1; i <= n; i++) &#123;        cin >> nums[i];    &#125;    build_tree(1, 1, n);    for(int i = 1; i <=m; i++) &#123;        int cz, x, y;        cin >> cz >> x >> y;        if(cz == 1) &#123;            add(1, 1, n, x, y);        &#125;        else &#123;            cout << cal(1, 1, n, x, y) << endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、线段树的基本操作（2）不下传懒惰标记版本"><a href="#三、线段树的基本操作（2）不下传懒惰标记版本" class="headerlink" title="三、线段树的基本操作（2）不下传懒惰标记版本"></a>三、线段树的基本操作（2）不下传懒惰标记版本</h1><p>在上面的操作，我们只是进行了对线段树中的某一个值进行一个加减的过程，那么很显然不能体现线段树的好处。那么如果我们对一整个区间去进行操作呢？我们先看一下下面的引入：</p><h3 id="①引入懒惰标记"><a href="#①引入懒惰标记" class="headerlink" title="①引入懒惰标记"></a>①引入懒惰标记</h3><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记"></p><p><strong>如图所示，左边是我们最开始要构建的一颗树，右边是加入了懒惰标记的时候构建的一颗树，在这个地方我们看到了在两个地方我们由红色标记了一个东西，这就是我们的懒惰标记。由它的名字我们可以知道，就是我们可以偷懒，让程序不用去把所有的值进行修改，就可以得到我们最终的答案。也就是图中的下标为3，4的地方的并没有进行加1操作，但是他们的和是加上了2的，这是怎么偷懒的呢？</strong><font color="red">通俗来说，就是假设我们计算一个区间，如果线段树的那一段已经恰好完全包含了这个区间，正如[3,4]的区间被恰好包含在编号为3的子树上，那么我们就直接给他打上一个+1的标记，代表其实它的儿子是都需要加1的，但是由于我已经包含了他们，因此我们不再需要继续往下递归，因为它们的老爸已经把他们相加的结果记录好了，这个操作实现的代码如下：</font></p><pre class="line-numbers language-c++"><code class="language-c++">void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //先让能够满足所求区间为总区间的子区间的加上对应的区间和     sum[k] += (y - x + 1) * val;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②区间的查询"><a href="#②区间的查询" class="headerlink" title="②区间的查询"></a>②区间的查询</h3><p>好了那么我们要查询一个区间怎么办呢？首先这里由于我们是这里先介绍不把懒惰标记下传的写法，因此，下面的方法与后面把懒惰标记下传的方法会有些不同的地方，大家注意看一下区别。</p><p>回归正题，如果我们要查找一段区间，但是由于懒惰坐标并没有下传，这就会导致一个什么事情呢，就是在我们查询的时候，有一些孩子的值是并没有得到更新的，这就会导致，他们所存的sum值是没有得到更新的，还需要去加上之前积累的懒惰标记的值才行，这里还是以上图为例子。</p><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记计算1"></p><p>假设我们要查找的就是$[4,4]$这个区间呢？我们可以看到本身4下标的这个数字是要加1的，但是很遗憾的是，我们的第一步操作并没有达到我们想要满足的效果。那么我们可以关注一下，从下标为4的那个地方往上看，是不是可以看到一个懒惰标记，这个代表了什么呢？不就是代表了它上方如果存在懒惰标记的话，那么就代表因为太懒，本来它本身是需要加上懒惰标记的值但是没有加上，那么我们只需要把他上方所有积累的懒惰标记加起来，然后最后在计算本身的时候加上$(\sum{lz}*length(区间的长度))$就好了。这个地方会有点难理解为什么要加上上方所有的和，不急，可以在用一个图为例子：</p><p><img src="https://img-blog.csdnimg.cn/a867ad730ac34f0d9e84e2f799221706.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记计算2"></p><p><strong>假设在前面图的基础上让区间[1,4]都加上了一个1，很显然，因为恰好包含，除了根节点挂上一个+1的懒惰标记，其他地方都不会变化，那如果此时我们还要计算[4,4]的值呢？很显然我们要加上两个懒惰标记的值，因为4被连续加上了两次1。也就是说当我们不把懒惰标记下传的时候，我们是需要计算两部分的值才能最终确定一个区间的和。一个就是懒惰标记的积累和，另外就是本身的子树累计的和，代码如下，大家可以结合代码去走一遍图：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和//p代表当前下标的lazy值 int query(int k, int l, int r, int x, int y, int p) &#123;    //先进行lazy值的累加    p += lz[k];     //如果恰好包含    if(l == x && r == y) &#123;        return p * (y - x + 1) + sum[k];    &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return query(k << 1, l, m, x, y, p);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return query(k << 1 | 1, m + 1, r, x, y, p);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return query(k << 1, l, m, x, m, p) +         query(k << 1 | 1, m + 1, r, m + 1, y, p);    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③例题模板2"><a href="#③例题模板2" class="headerlink" title="③例题模板2"></a>③例题模板2</h3><p><img src="https://img-blog.csdnimg.cn/0209f12304fe4725896c1b92231635aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树模板"></p><p>​                                                                                                    <a href="https://www.luogu.com.cn/problem/P3372">题目2入口</a></p><h3 id="④AC完整代码"><a href="#④AC完整代码" class="headerlink" title="④AC完整代码"></a>④AC完整代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;//开辟其他数组的时候最好为4n让数组不会产生越界的情况 int nums[100001];  //数据的存储 long long sum[400010];   //区间和的存储 long long lz[400010];     //lazy标记的存储int n, m;//进行线段树的构建 void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;//进行区间的加值//函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //先让能够满足所求区间为总区间的子区间的加上对应的区间和     sum[k] += (y - x + 1) * val;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125; &#125;//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和//p代表当前下标的lazy值 long long query(int k, int l, int r, int x, int y, long long p) &#123;    //先进行lazy值的累加    p += lz[k];     //如果恰好包含    if(l == x && r == y) &#123;        return p * (y - x + 1) + sum[k];    &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return query(k << 1, l, m, x, y, p);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return query(k << 1 | 1, m + 1, r, x, y, p);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return query(k << 1, l, m, x, m, p) +         query(k << 1 | 1, m + 1, r, m + 1, y, p);    &#125; &#125;int main() &#123;    scanf("%d%d", &n, &m);    for(int i = 1; i <= n; i++) &#123;        scanf("%d", &nums[i]);    &#125;    build_tree(1, 1, n);    for(int i = 1; i <=m; i++) &#123;        int cz;        scanf("%d", &cz);        if(cz == 1) &#123;            int x,y;            long long k;            scanf("%d%d%lld", &x, &y, &k);            insert(1, 1, n, x, y, k);        &#125;        else &#123;            int x,y;            scanf("%d%d", &x, &y);            printf("%lld\n", query(1, 1, n, x, y, 0));        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、线段树的基本操作（2）下传懒惰标记版本"><a href="#四、线段树的基本操作（2）下传懒惰标记版本" class="headerlink" title="四、线段树的基本操作（2）下传懒惰标记版本"></a>四、线段树的基本操作（2）下传懒惰标记版本</h1><h3 id="①引言"><a href="#①引言" class="headerlink" title="①引言"></a>①引言</h3><p>这里其实就是说会根据很多人的不同习惯有很多不同的写法，所以仅供大家参考目前我在慢慢习惯的一个写法。</p><p>下传懒惰标记其实就是说，我们不要去管计算的时候，一个区间上面的懒惰标记，假设还是如图</p><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记下传"></p><p>如果我们还是要去计算[4,4]的值，我们不妨在访问和为9的那个线段的时候，直接把它的懒惰标记传给它的左右孩子，然后它本身的懒惰标记变成0。这样的话，我们计算值的时候就不用管上面懒惰标记的和了，因为都是0。那么我们其实就是在计算本层的一个值加上本身就应该加上的懒惰标记的值，其实和之前的方法就是一个过程了相当于，就是思维上稍微有点不同。<font color="red">比如在这个地方，因为计算的时候有可能会把懒惰标记下传，这样的过程会导致什么呢？会导致上方的值因为懒惰标记的下传，上面的值得不到一个更新，因此很简单的思路就是。在递归回溯的过程中，让上方的值不断的进行一个更新，也就是和我们文章最初开头的一种方式是一样的了！</font></p><h3 id="②插入的操作-懒惰标记下传"><a href="#②插入的操作-懒惰标记下传" class="headerlink" title="②插入的操作(懒惰标记下传)"></a>②插入的操作(懒惰标记下传)</h3><pre class="line-numbers language-c++"><code class="language-c++">//进行区间的加值//函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;     int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125;    //最后递归回溯的时候不断更新上面的值    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②查询的操作-懒惰标记下传"><a href="#②查询的操作-懒惰标记下传" class="headerlink" title="②查询的操作(懒惰标记下传)"></a>②查询的操作(懒惰标记下传)</h3><pre class="line-numbers language-c++"><code class="language-c++">//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和long long query(int k, int l, int r, int x, int y) &#123;    //如果恰好包含    if(l == x && r == y) &#123;        return sum[k] + lz[k] * (r - l + 1);    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;    int m = (l + r) >> 1;    long long ret = 0;    //区间完全在左子树     if(y <= m) &#123;        ret = query(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         ret = query(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         ret = query(k << 1, l, m, x, m) +         query(k << 1 | 1, m + 1, r, m + 1, y);    &#125;    //最后递归回溯的时候不断更新上面的值    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];     return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">这里为什么要另外设计一个ret变量对结果进行保存呢？对比不下传的方法，我们可以看到，本次的方法会边回溯边更新答案，因此在我们回溯的过程中，我们才会得到正确的答案，因此回溯的过程要把区间的左右记录下来，最后完成区间和的更新才是我们最终的答案。而方法二为什么不用这个呢？就是因为方法二是不断的往下去更新，然后遇到可以不用更新的地方就直接回溯了，但是我们发现在向下递归的时候，就已经对答案进行了更新，也就是方法三的一个逆过程！</font></p><h3 id="③AC代码"><a href="#③AC代码" class="headerlink" title="③AC代码"></a>③AC代码</h3><p>因为题目还是方法二的，因此这里直接贴上不同版本的代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;//开辟其他数组的时候最好为4n让数组不会产生越界的情况 long long nums[100001];  //数据的存储 long long sum[400010];   //区间和的存储 long long lz[400010];     //lazy标记的存储int n, m;//进行线段树的构建 void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;//进行区间的加值//函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;     int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125;    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];&#125;//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和long long query(int k, int l, int r, int x, int y) &#123;    //如果恰好包含    if(l == x && r == y) &#123;        return sum[k] + lz[k] * (r - l + 1);    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;    int m = (l + r) >> 1;    long long ret = 0;    //区间完全在左子树     if(y <= m) &#123;        ret = query(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         ret = query(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         ret = query(k << 1, l, m, x, m) +         query(k << 1 | 1, m + 1, r, m + 1, y);    &#125;    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];     return ret;&#125;int main() &#123;    cin >> n >> m;    for(int i = 1; i <= n; i++) &#123;        cin >> nums[i];    &#125;    build_tree(1, 1, n);    for(int i = 1; i <=m; i++) &#123;        int cz, x, y;        long long k;        cin >> cz;        if(cz == 1) &#123;            cin >> x >> y >> k;            insert(1, 1, n, x, y, k);        &#125;        else &#123;            cin >> x >> y;            cout << query(1, 1, n, x, y) << endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总而言之，线段树会有很多不同的写法，本文仅提供目前学到的这种，uu们可以找到自己习惯的写法，然后经常复习一下，我觉得对线段树就会慢慢不陌生了！！！</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">线段树详解</a></p><p><a href="https://www.bilibili.com/video/BV1uS4y1m7zY?spm_id_from=333.788.header_right.history_list.click">wls的b站视频</a></p><p>感谢各大佬写的博客，发的视频的帮助！</p><p>本文章的问题也希望读者们指出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线段树的相关概念&quot;&gt;&lt;a href=&quot;#一、线段树的相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、线段树的相关概念&quot;&gt;&lt;/a&gt;一、线段树的相关概念&lt;/h1&gt;&lt;h3 id=&quot;①定义&quot;&gt;&lt;a href=&quot;#①定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="线段树" scheme="https://sample.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题4</title>
    <link href="https://sample.com/2022/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%984/"/>
    <id>https://sample.com/2022/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%984/</id>
    <published>2022-04-12T02:49:55.000Z</published>
    <updated>2022-04-14T10:20:02.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解的灵感来源于我自己看了很多神犇的题解，真的会很有收获。</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h1 id="二、力扣的某“简单题”"><a href="#二、力扣的某“简单题”" class="headerlink" title="二、力扣的某“简单题”"></a>二、力扣的某“简单题”</h1><p><img src="https://img-blog.csdnimg.cn/ec95219d02954e7fb50cbc622d3e0efe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="检查整数是否被全部覆盖"></p><p><strong>这个题目其实说真的，刚开始觉得真的挺难的，然后看到是个简单题我就知道数据的范围肯定给的非常的小，果不其然，数据范围只给了50，哈哈哈，所以第一次做这个题目的时候，这不就是简单的暴力枚举的题目吧，因为这题是三叶姐给到的“-+”题，然后看了看，好家伙，居然有可能上升为一个困难题（<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490741&idx=1&sn=cd4ab8ff1852c379223efb66d5e904ab">三叶姐关于本题的解答</a>）,awsl,于是乎我觉得今天去学习一下线段树的基本东西！！</strong></p><h1 id="三、一题多解"><a href="#三、一题多解" class="headerlink" title="三、一题多解"></a>三、一题多解</h1><h2 id="①暴力哈希"><a href="#①暴力哈希" class="headerlink" title="①暴力哈希"></a>①暴力哈希</h2><p>这里其实可以很容易想到，把所有题目中给到的range范围中的数，直接存储下来，然后呢直接进行一次$[left, right]$区间的一个遍历，看看区间内的元素是否满足在区间之内就好了！</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    map<int, int> nums;    bool isCovered(vector<vector<int>>& ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            for(auto i = range[0]; i <= range[1]; i++) &#123;                nums[i]++;            &#125;        &#125;        for(int i = left; i <= right; i++) &#123;            if(!nums.count(i)) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>暴力解法的时间复杂度为$O(N)$，由于这里开了一个哈希表，所以空间复杂度为$O(N)$。当然这里的数据因为比较小嘛，直接开一个常数的52一个数组去记录数字是否存在，空间复杂度就变成$O(C)$了哈哈。</p><h2 id="②差分数组加前缀和"><a href="#②差分数组加前缀和" class="headerlink" title="②差分数组加前缀和"></a>②差分数组加前缀和</h2><p>关于差分的思想和前缀和的计算，相信很多同学已经会了，在此不多加赘述，那么这一题的差分思想在哪呢？其实就是我们去计算一个一个区间所存在数字的时候.先设置一个差分数组$diff[52]$,假设我们要计算区间$[1,10]$之内，保证这之间的数都出现过也就不为0，那么我们只需要让$diff[1]+1$然后让$diff[11]-1$，之后对区间做一次前缀和我们可以发现区间$[1,10]$内的$diff$数组就会全部变成1，代表数字出现在区间内，这样虽然并没有大大的优化时间复杂度。<font color="red">但是我们不难发现，如果当题目所给的区间有重复的时候，我们是可以通过这样的方法去计算出每一个数字被重复的次数，也就是在整个区间里面重复出现了多少次，这个可能也对日后碰到这样的题目提供了一个非常不错的思路！</font></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int diff[52];    bool isCovered(vector<vector<int>>& ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            diff[range[0]]++;            diff[range[1] + 1]--;            &#125;        for(int i = 1; i < 52; i++) &#123;            diff[i] += diff[i - 1];        &#125;        for(int i = left; i <= right; i++) &#123;            if(diff[i] <= 0) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为$O(N)$，空间复杂度就变成$O(C)$。</p><h2 id="③树状数组"><a href="#③树状数组" class="headerlink" title="③树状数组"></a>③树状数组</h2><p><strong>本题采用线状数组其实无非就是会和第二种解法一样，只不过在树状数组的add操作里面，每次加入的是代表此元素出现的次数，最后利用差分的思想，可以直接得到某元素出现的次数，其实和方法二大同小异，但是希望自己再练一遍树状数组，所以呢，就还是写了一遍代码。如果对树状数组不了解的同学，sheepice也写了一篇博客，仅供uu们进行参考.</strong><a href="https://sheepice.github.io/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/">树状数组初探</a>！！</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int n = 55;    int sum[55];    int lowbit(int x) &#123;        return x & (-x);    &#125;    void add(int index, int value) &#123;        for(int i = index; i <= n - 1; i += lowbit(i)) &#123;            sum[i] += value;        &#125;    &#125;    int query(int index) &#123;        int ans = 0;        for(int i = index; i > 0; i -= lowbit(i)) &#123;            ans += sum[i];        &#125;        return ans;    &#125;    bool isCovered(vector<vector<int>>& ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            for(auto i = range[0]; i <= range[1]; i++) &#123;                add(i, 1);            &#125;            &#125;        for(int i = left; i <= right; i++) &#123;            if(query(i) - query(i - 1) <= 0) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xxxxxxxxxx &#x2F;&#x2F;c++版本的解答class Solution {public:    int maxProduct(vector<string>&amp; words) {        int n &#x3D; words.size();        vector<int> dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) {            for(int j &#x3D; 0; j &lt; words[i].size(); j++) {                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - ‘a’));              }        }        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) {            for(int j &#x3D; i+1; j &lt; n; j++) {                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) {&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                }            }        }        return ans;    }};c++</int></string></p><h2 id="④线段树"><a href="#④线段树" class="headerlink" title="④线段树"></a>④线段树</h2><p>线段树应该是解决所有树状数组能够解决的一些相关问题，同时也是解决绝大部分的区间求和和查询的一个最有利的手段，有关线段树的学习，大家可以参考此篇：<a href="https://blog.csdn.net/huangzihaoal/article/details/81813454?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164973450016780366523945%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164973450016780366523945&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-81813454.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">线段树和树状数组</a>。本篇下面的代码仅供参考，因为sheepicce今天才稍微懂一点线段树，<font color="red"><strong>预计这周会总结一下线段树的一些东西哦！</strong></font></p><blockquote><p>const int N &#x3D; 55;<br>class Solution {<br>public:<br>struct Node {<br>       int l, r, cnt;<br>   };<br>   Node tr [N * 4];<br>   void pushup(int u) {<br>       tr[u].cnt &#x3D; tr[u &lt;&lt; 1].cnt + tr[u &lt;&lt; 1 | 1].cnt;<br>   }<br>   void build(int u, int l, int r) {<br>       tr[u].l &#x3D; l, tr[u].r &#x3D; r, tr[u].cnt &#x3D; 0;<br>       if(l !&#x3D; r)<br>       {<br>           int mid &#x3D; (l + r) &gt;&gt; 1;<br>           build(u &lt;&lt; 1, l, mid);<br>           build(u &lt;&lt; 1 | 1, mid + 1, r);<br>           pushup(u);<br>       }<br>   }<br>   &#x2F;&#x2F; 从 tr 数组的下标 u 开始，在数值 x 的位置进行标记<br>   void update(int u, int x) {<br>       if (tr[u].l &#x3D;&#x3D; x &amp;&amp; tr[u].r &#x3D;&#x3D; x) {<br>           tr[u].cnt &#x3D; 1;<br>       } else {<br>           int mid &#x3D; (tr[u].l + tr[u].r) &gt;&gt; 1;<br>           if (x &lt;&#x3D; mid) update(u &lt;&lt; 1, x);<br>           else update(u &lt;&lt; 1 | 1, x);<br>           pushup(u);<br>       }<br>   }<br>   &#x2F;&#x2F; 从 tr 数组的下标 u 开始，查询 [l,r] 范围内有多少个数值被标记<br>   int query(int u, int l, int r) {<br>       if (l &lt;&#x3D; tr[u].l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].cnt;<br>       int mid &#x3D; (tr[u].l + tr[u].r) &gt;&gt; 1;<br>       int ans &#x3D; 0;<br>       if (l &lt;&#x3D; mid) ans +&#x3D; query(u &lt;&lt; 1, l, r);<br>       if (r &gt; mid) ans +&#x3D; query(u &lt;&lt; 1 | 1, l, r);<br>       return ans;<br>   }<br>   bool isCovered(vector &lt;vector <int>&gt; &amp; rs, int l, int r) {<br>       build(1, 1, N);<br>       for (auto &amp;  cur : rs) {<br>           int a &#x3D; cur[0], b &#x3D; cur[1];<br>           for (int i &#x3D; a; i &lt;&#x3D; b; i++) {<br>               update(1, i);<br>           }<br>       }<br>       int tot &#x3D; r - l + 1 , cnt &#x3D; query(1, l, r);<br>       return tot &#x3D;&#x3D; cnt;<br>   }<br>};</int></p></blockquote><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>总之，虽然是一个简单的题目，但是还是有很多可以拓展的地方，这也是我需要慢慢去学习的！加油啊！冲鸭！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="树状数组" scheme="https://sample.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="线段树" scheme="https://sample.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>周总结-3</title>
    <link href="https://sample.com/2022/04/10/%E5%91%A8%E6%80%BB%E7%BB%93-3/"/>
    <id>https://sample.com/2022/04/10/%E5%91%A8%E6%80%BB%E7%BB%93-3/</id>
    <published>2022-04-10T08:55:51.000Z</published>
    <updated>2022-04-10T09:24:28.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、力扣的刷题"><a href="#二、力扣的刷题" class="headerlink" title="二、力扣的刷题"></a>二、力扣的刷题</h3><p>这周感觉上，是在数据结构上面下了点功夫吧，对c++的一些容器的概念还有一些用法有了更加清楚的一个认识，然后现在使用迭代器的时候也能够敢去用一些以前不敢用的一些写法。比如<font color="red">auto</font>的使用，迭代器中<font color="red">begin（）</font>的一些使用了，感觉还是比较好的。今天周日好像已经是坚持力扣刷题的第53天了，不知不觉这两个多月的时间吧，力扣的题目已经刷了120多道了，虽然自己还是挺菜的吧，但是感觉比之前有所进步了！</p><h4 id="①数据结构的学习"><a href="#①数据结构的学习" class="headerlink" title="①数据结构的学习"></a>①数据结构的学习</h4><p>这周主要学了一些数据结构，比如怎么用两个栈实现一个队列，链表的数组存取，链式存取，对于一颗树的BFS搜索的进行等。然后跟着做了三叶姐的很多“-+”题，我还记得就是那时候刷奇偶数的遍历的时候，虽然可能难度比当天每日一题的大吧，但是那个时候真的就看着看着就会了，虽然树这个数据结构还是没有去细学吧，骚年继续加油啊！</p><h4 id="②算法的学习"><a href="#②算法的学习" class="headerlink" title="②算法的学习"></a>②算法的学习</h4><p>这周对于算法应该大题来说有新也有旧，新的是学了一下<strong>树状的数组</strong>，但是线段树还没有去学，树状数组可能对于现在的我来说可能还没有特别的习惯，争取下次遇到题目的时候再多复习总结一下。然后就是旧的背包知识，之前对于一维背包知识的一个遍历顺序其实还是会有对应的存疑的，但是看了<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzU4NDE3MTEyMA==&scene=23&album_id=1751702161341628417&count=3#wechat_redirect">三叶姐这方面的总结</a>感觉对基础的背包有了比较深的印象了，当然看了一下状压dp，虽然看不懂呜呜，但是我相信以后会看得懂的哈哈哈！！</p><h3 id="三、课内任务"><a href="#三、课内任务" class="headerlink" title="三、课内任务"></a>三、课内任务</h3><h4 id="①c语言程序设计实验完成："><a href="#①c语言程序设计实验完成：" class="headerlink" title="①c语言程序设计实验完成："></a>①c语言程序设计实验完成：</h4><p>说真的这个实验花了蛮多的时间，其实还是因为自己太菜了，比如对于一些字符串连接，字符串寻找的函数使用非常的不熟悉，导致再重新学这一方面的时候花了蛮多额外的时间，就感觉基础没有大佬。在实验中遇到了很多的问题说真的，比如变量的重复定义，文件目录的创建等等，虽然最后通过各种询问解决了一些问题，但是我现在心里其实还是没有底的，毕竟很多东西查完之后，感觉我没有很彻底的了解到程序最底层的东西吧，希望后面能够在看c++prime的时候继续的巩固。</p><h4 id="②英语6级的复习："><a href="#②英语6级的复习：" class="headerlink" title="②英语6级的复习："></a>②英语6级的复习：</h4><p>其实按理来说我不应该说这个复习的事情的，因为我可能根本就没有复习。就好像6天有4天坚持了听了40min，还是因为自己听力太差了，所以拿听力的原文听了一遍又一遍，最终还是没能听出正确答案呜呜，然后有的时候就是本来说晚上做完事就听听力，然后一到十点多的时候，感觉一天好像学了不少东西，就玩玩手机，刷b站的视频，时间一晃而过，我的天，这周我感觉对时间的管理特别特别的差真的。</p><h3 id="四、一点决心"><a href="#四、一点决心" class="headerlink" title="四、一点决心"></a>四、一点决心</h3><p>其实之前在看星球的各位和我一样为了以后能够进一个好一点的大厂的人打卡和提问，这周印象最深的是北邮的一个同学吧，她现在大一，但是已经有了3个项目的参与，多个程序设计的奖项，然后每天会花5个小时在课内，5个小时在课外，而且已经刚刚通过了阿里的二面。说到这其实不是为了去把自己和这位大佬进行比较吧，但是当时看到的时候，真的感觉自己在时间管理方面，做得是真的挺差的。下周开始，我希望自己能够克服一些娱乐吧。就是先从小事做起，做到一天以内至少8个小时心思是完全在学习上的，而不是说，写完一题就看会微信聊会天，看会书就看点b站什么的吧！我希望下周日的总结日记，写到我的改变！毕竟时间还多，只要想去改变，那么什么时候都不算晚！！！</p><h3 id="五、新球打卡"><a href="#五、新球打卡" class="headerlink" title="五、新球打卡"></a>五、新球打卡</h3><h4 id="①周一"><a href="#①周一" class="headerlink" title="①周一"></a>①周一</h4><p>leetcode每日一题<br>大概懂了树状数组，并且自己实现了一遍</p><p>c++prime越看越看不懂了，特别看到类那一块，星球的uu们能给点建议吗？感觉看那个都有点劝退了。</p><p>操作系统看了线程</p><h4 id="②周二"><a href="#②周二" class="headerlink" title="②周二"></a>②周二</h4><p>英语六级听力40min，好像现在听力有点感觉了</p><p>力扣每日一题照常，开始刷数据结构的leetbook了，刷了3题今天</p><p>写了一篇树状数组的博客，下面有csdn关于这篇博客的网址，uu们可以看看，虽然我写得比较水</p><p>计算机操作系统看了三个调度算法（FCFS,SJF,HRRN），感觉还是比较有趣的</p><p>c++prime水完了第七章，类那一块真的有点不太懂，但是大概懂了点构造函数那一块，包括链表内部那个构造函数，知道怎么记忆了。</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/123967025?spm=1001.2014.3001.5501">树状数组初学_sheep.ice的博客-CSDN博客</a> </p><h4 id="③周三"><a href="#③周三" class="headerlink" title="③周三"></a>③周三</h4><p>课内为主，上了一天课，补了补作业<br>力扣那题图论想不出好办法 明天进攻图论我说的<br>居然就没了哈哈哈哈</p><h4 id="④周四"><a href="#④周四" class="headerlink" title="④周四"></a>④周四</h4><p>被学校的数据文件实验继续折磨<br>开始看《算法竞赛入门》，对各种迭代器的使用又加深了一点<br>力扣照常每日一题<br>英语30min</p><h4 id="⑤周五"><a href="#⑤周五" class="headerlink" title="⑤周五"></a>⑤周五</h4><p>c++prime第八章<br>英语40min<br>两道bfs树的遍历<br>看了下竞赛入门经典一些数据结构</p><h4 id="⑥周六"><a href="#⑥周六" class="headerlink" title="⑥周六"></a>⑥周六</h4><p>终于搞完学校c语言设计的一个实验 写完了实验报告<br>每日一题（简单题）<br>看了三叶姐背包问题看了7章 对背包理解更深了<br>写了3h课内的东西<br>英语今天没看呜呜</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>树状数组初探</title>
    <link href="https://sample.com/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/"/>
    <id>https://sample.com/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-05T04:46:11.000Z</published>
    <updated>2022-04-14T10:15:29.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、树状数组的初学"><a href="#一、树状数组的初学" class="headerlink" title="一、树状数组的初学"></a>一、树状数组的初学</h1><p>之前学习过前缀和和差分的一些知识就觉得挺神奇的，然后昨天刷到力扣的每日一题之后发现，好像&#x3D;&#x3D;树状数组&#x3D;&#x3D;在多区间的修改和查询方面很神奇，包括之后要学习的&#x3D;&#x3D;线段树&#x3D;&#x3D;（能解决所有树状数组的问题）可能会更加有收获吧。😁😁</p><hr><h1 id="二、一些小小的理解"><a href="#二、一些小小的理解" class="headerlink" title="二、一些小小的理解"></a>二、一些小小的理解</h1><h3 id="①lowbit的理解"><a href="#①lowbit的理解" class="headerlink" title="①lowbit的理解"></a>①lowbit的理解</h3><p>在线段数组里面有这么一个重要的函数，也是能够构造整个树状数组的<font color="red">核心</font>吧！代码只有一行，但是对于我这种萌新来说，刚开始还是很难理解的。代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">//寻找一个数最低位的1int lowbit(int x) &#123;        return x & -x;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个比较简单的例子，一个数为3，他的二进制表示为11，那么根据负数二进制的要求，-3的二进制，我们先求他的反码为00，最后+1得到补码为01，最后让11 &amp; 01 便取得 01，也就是最低位的第一个1，<strong>大家可以试一下，利用这个函数，最后得到的结果一定只会含有一个1在整个数里面</strong>;</p><hr><h1 id="三、树状数组的构建"><a href="#三、树状数组的构建" class="headerlink" title="三、树状数组的构建"></a>三、树状数组的构建</h1><p><img src="https://img-blog.csdnimg.cn/00946e0b43e9458e843fd7c0b90696d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树状数组"><br>大家可以看到，树状数组首先对应一个s数组（假设有8个元素），也就是一个求总和的数组，这个数组里面对应装下一些前缀和，而每一个s对应数都是连续的，这也就为我们后面提供区间和利用<strong>前缀和</strong>的思想提供了很好的办法！<br>&#x3D;&#x3D;当然这里有要注意的点：&#x3D;&#x3D; 就是我们的s数组必须从1作为下标开始，也就是8个元素我们要开s[9]的空间，因为lowbit(0)是不存在最低位1的会造成<strong>无限循环</strong>的风险。大家可能不太理解，这个数组里面为什么能够按照这样的数字进行相加，我们看下面的图：<br><img src="https://img-blog.csdnimg.cn/5c68b3ed52e0422f9a8dde06069d7c9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="二进制表示"><br>从上面的图，我们可以知道，每个s对应的下标，都是从某个下标i，通过加上lowbit(i),并且在每次演变的时候，让$S_i$加上对应的num[i - 1] 的数(因为num数中的下标是从0开始的)，最后就变成了第一张图的样子，也就是接下来要讲的区间的更新。</p><hr><h1 id="四、区间的查询以及更新"><a href="#四、区间的查询以及更新" class="headerlink" title="四、区间的查询以及更新"></a>四、区间的查询以及更新</h1><h3 id="①区间的更新："><a href="#①区间的更新：" class="headerlink" title="①区间的更新："></a>①区间的更新：</h3><p>因为有了上面的铺垫，我们直接放上，s数组更新的一个代码，也就是如何让s数组存上对应相关的值。</p><pre class="line-numbers language-c++"><code class="language-c++">//添加和到对应的树状数组    void add(int x, int val) &#123;        for(int i = x; i <= n; i += lowbit(i)) &#123;            sum[i] +=  val;   //这里的val其实就是num[i - 1];        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过上面的操作之后，我们就<font color="green">完成了s数组的构建</font>，那么如果题目要求，改掉num数组里面的某个数的话，我们只需要让那个数所在的s也同时的更新就好，像下面一样:</p><pre class="line-numbers language-c++"><code class="language-c++">void update(int index, int val) &#123;        //这里的index要+1，因为num数组的下标从0开始        add(index + 1, val - nums[index]);        nums[index] = val;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②区间的查询"><a href="#②区间的查询" class="headerlink" title="②区间的查询"></a>②区间的查询</h3><p>区间的查询，其实有点像更新的逆过程，比如我们要知道$\sum_{i&#x3D;0}^{6}num[i]$的总和也就是说如何要求出$ S_7 +  S_6  + S_4 $的值（这里大家可以对照一下上面的图）。<strong>7 - 6 - 4 不就是 111 - 110 - 100</strong>的过程吗？那其实就是每次让下标为i的数减去lowbit(i)，<font color="red">然后在此过程中去加上S[i]的值，最后就可以得到原始下标为index的前缀和了，根据区间前缀和计算的方式，最终就可以知道一段区间的和了。</font></p><pre class="line-numbers language-c++"><code class="language-c++">//计算从下标0- x-1的前缀和int query(int x) &#123;        int s = 0;        for(int i = x; i > 0; i -= lowbit(i)) &#123;            s += sum[i];        &#125;        return s;    &#125;//计算区间的和(不了解前缀和的同学可以先了解一下前缀和)int sumRange(int left, int right) &#123;        //因为原始的下标从0开始，那么对应区间和的下标要加1        return query(right + 1) - query(left);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="五、力扣的原题"><a href="#五、力扣的原题" class="headerlink" title="五、力扣的原题"></a>五、力扣的原题</h1><h3 id="①原题贴图"><a href="#①原题贴图" class="headerlink" title="①原题贴图"></a>①原题贴图</h3><p><img src="https://img-blog.csdnimg.cn/48adae96d9104c9c9c868b5332bb8eb0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树状数组模板题"></p><h3 id="②AC的代码全贴"><a href="#②AC的代码全贴" class="headerlink" title="②AC的代码全贴"></a>②AC的代码全贴</h3><pre class="line-numbers language-c++"><code class="language-c++">class NumArray &#123;public:    vector<int> sum;    //记录最低位的1    int lowbit(int x) &#123;        return x & -x;    &#125;    //添加和到对应的树状数组    void add(int x, int val) &#123;        for(int i = x; i <= n; i += lowbit(i)) &#123;            sum[i] +=  val;        &#125;    &#125;    int query(int x) &#123;        int s = 0;        for(int i = x; i > 0; i -= lowbit(i)) &#123;            s += sum[i];        &#125;        return s;    &#125;    vector<int> nums;    int n;    NumArray(vector<int>& nums) &#123;        this->nums = nums;        n = nums.size();        sum.resize(n + 1, 0);        for(int i = 0; i < n; i++) &#123;            add(i + 1, nums[i]);        &#125;    &#125;        void update(int index, int val) &#123;        add(index + 1, val - nums[index]);        nums[index] = val;    &#125;        int sumRange(int left, int right) &#123;        return query(right + 1) - query(left);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="六、-参考文档"><a href="#六、-参考文档" class="headerlink" title="六、 参考文档"></a>六、 参考文档</h1><p><a href="https://blog.csdn.net/bestsort/article/details/80796531">参考1 树状数组的详细教程</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/">参考2 力扣胡歌的题解</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">参考3 力扣三叶姐的题解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、树状数组的初学&quot;&gt;&lt;a href=&quot;#一、树状数组的初学&quot; class=&quot;headerlink&quot; title=&quot;一、树状数组的初学&quot;&gt;&lt;/a&gt;一、树状数组的初学&lt;/h1&gt;&lt;p&gt;之前学习过前缀和和差分的一些知识就觉得挺神奇的，然后昨天刷到力扣的每日一题之后发现，</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="树状数组" scheme="https://sample.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>周总结(2)</title>
    <link href="https://sample.com/2022/04/03/%E5%91%A8%E6%80%BB%E7%BB%93-2/"/>
    <id>https://sample.com/2022/04/03/%E5%91%A8%E6%80%BB%E7%BB%93-2/</id>
    <published>2022-04-03T12:28:55.000Z</published>
    <updated>2022-04-03T13:59:23.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><hr><h3 id="二、leetbook的完结"><a href="#二、leetbook的完结" class="headerlink" title="二、leetbook的完结"></a>二、leetbook的完结</h3><p>算是看完了的第一本leetbook吧，还是很支持三叶姐的。看完这本书的最大感受就是对动态规划有了更加深刻的一个理解吧，准备下周开始看三叶姐的背包问题的总结了。希望能够变得越来越强吧！</p><p>极力推荐**<a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/rt49s5/">三叶姐的第一本leetbook</a>**！！</p><p><img src="https://img-blog.csdnimg.cn/a2ca59a49a0c4c39a46d978111403d41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h3 id="三、知识星球的打卡"><a href="#三、知识星球的打卡" class="headerlink" title="三、知识星球的打卡"></a>三、知识星球的打卡</h3><h5 id="①Day-5，周一"><a href="#①Day-5，周一" class="headerlink" title="①Day 5，周一"></a>①Day 5，周一</h5><p>平平无奇的一天，但又是重新启航的一天。早上的时候终于把博客初步搭建好了，然后啥事也没干。<br>中午的时候忘记调闹钟了，一觉睡到了3点多，然后起来开始刷力扣，这是第39天了，加油啊骚年。写完力扣的题目，做了三叶姐的拓展，写了篇博客<a href="https://sheepice.github.io/">https://sheepice.github.io/</a><br>大家可以看看<br>晚上就继续看c++prime，看了两个多小时，好像对c++的容器还有一些变量的设置有了一点眉目，希望这一周可以好好总结一下，发一篇新的博客<br>呆会手机锁机<br>我要开始复习六级啦！</p><h5 id="②Day6，周二"><a href="#②Day6，周二" class="headerlink" title="②Day6，周二"></a>②Day6，周二</h5><p>今天的力扣每日一题很可惜没能第一时间想出来，当知道是滑动窗口的一个模板题的时候，狠狠的觉得自己题目刷少了哈哈哈。当然还是写了一篇博客的：<a href="https://sheepice.github.io/%E2%80%8B%E2%80%8B">https://sheepice.github.io/​​</a></p><p>早上起来听了六级听力，我从来没有发现英语那么难学啊呜呜。</p><p>下午的时候把c++prime的第四章看完了。</p><p>哦对了，早上的时候，我看了操作系统看了差不多1个多小时的视频，刚开始还觉得这样的课程比较无聊，但是王道那个老师举的例子真的好好玩啊哈哈哈！</p><p>晚上的话就是自己的姨妈生日，翘了一节计算机思维课去帮她过生日，不过好像那一节课讲完了好多c++的东西[流泪]。不过我也是好好的展现了一波社交能力[呲牙]</p><p>回来的时候觉得今天好像一天都没干什么，就花了点时间看了一下数据结构和算法分析，对时间复杂度有了更深刻的理解。然后看到了那个最大子序列和用递归的写法，不得不说，递归这个东西神秘而又奇妙啊[呲牙]</p><p>待会再背背单词还有写写英语翻译，几天都没睡好了，争取今天能睡一个好好的觉[呲牙]</p><h5 id="③Day7-周三"><a href="#③Day7-周三" class="headerlink" title="③Day7 周三"></a>③Day7 周三</h5><p>今天发了一篇生活的博客，有兴趣的uu们可以去看看sheepice的博客​​</p><p>c++prime看了第六章还差一点</p><p>每日一题摆烂，有思路但是对数据结构不太熟悉啊，不太知道怎么用优先队列</p><p>英语听力40min 待会还会背单词</p><p>操作系统看完第一章</p><p>今天好摆啊<img src="file:///C:\Users\0604520\AppData\Roaming\Tencent\QQTempSys\CE_6{RQP]3{T@BAJGTH{IW4.png" alt="img"></p><h5 id="④Day8-周四"><a href="#④Day8-周四" class="headerlink" title="④Day8 周四"></a>④Day8 周四</h5><p>英语听力40min，总共25错7，继续努力<br>lc三月打卡目标完成<br>三叶姐的最短路径和2（困难），记录最小和第二小元素<br>c++prime第六章扫完<br>数据结构看了点列表，那本书有点难，打算开leetbook结合一下<br>操作系统看了进程：了解了一些进程组织，进程状态和进程转换的知识，包括对操作系统内核的原语有了初步印象<br>大物第五章习题刷完，大物慕课刷完</p><h5 id="⑤Day9-周五"><a href="#⑤Day9-周五" class="headerlink" title="⑤Day9 周五"></a>⑤Day9 周五</h5><p>每日一题，写了篇博客<a href="https://sheepice.github.io/%E2%80%8B%E2%80%8B">https://sheepice.github.io/​​</a></p><p>最短路径二hard题目，记忆化搜索</p><p>栈和队列的实现，链表的索引实现<br>今天想休息会，待会和朋友打游戏去了</p><h5 id="⑥Day10-周六"><a href="#⑥Day10-周六" class="headerlink" title="⑥Day10 周六"></a>⑥Day10 周六</h5><p>被电工技术折磨住了<br>刷了一个记忆化搜索题<br>三叶姐的路径leetbook明天可以刷完<br>英语单词<br>摆烂休息</p><hr><h3 id="四、运动任务"><a href="#四、运动任务" class="headerlink" title="四、运动任务"></a>四、运动任务</h3><p>中规中矩吧，每天跑跑步，跳跳绳什么的，每天坚持一点运动还是很不错滴！</p><hr><h3 id="五、一点小倾诉"><a href="#五、一点小倾诉" class="headerlink" title="五、一点小倾诉"></a>五、一点小倾诉</h3><p>就今天不是一周的最后一天了嘛，其实从前天开始，就感觉到自己明显的有点不在状态了。就感觉有好多我自己说不清楚的压力在我的身上，无论是学业的还是生活上的，也不知道是不是因为太久没有和身边的人进行沟通了，太久没有和朋友们进行相聚了，内心老是感觉憋着无数的话说不出来，突然就觉得好像有些累了。不知道大家有没有这样一种情况，就是会突然那一下没有了动力，然后就感觉莫名其妙的空虚感，有的uu们可以来一起聊聊天哈！就其实一直想做一个很乐观很乐观的人，但是可能自己性格的缘故，越想着去说，想把一些开心或者自己想说的话说出去，但是就会有点想展示自己，就是我无比感受到这样的展现挺空虚的，我估计还是心灵在作祟吧！可恶的疫情啊，你什么时候能够对我们善良一点，我真的很想回到自己的学校，见到熟悉的朋友。到那时，也许望着天边的一片片云，都觉得很有味道吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题3</title>
    <link href="https://sample.com/2022/04/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%983/"/>
    <id>https://sample.com/2022/04/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%983/</id>
    <published>2022-04-01T03:42:11.000Z</published>
    <updated>2022-04-14T10:15:41.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h3 id="二、leetcode每日一题"><a href="#二、leetcode每日一题" class="headerlink" title="二、leetcode每日一题"></a>二、leetcode每日一题</h3><p>今天的每日一题难度不大，主要想记录一下关系哈希表的容器相关写法吧！</p><p><img src="https://img-blog.csdnimg.cn/3f3ea20f3f3246cb883ad941a49020dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h5 id="①思路："><a href="#①思路：" class="headerlink" title="①思路："></a>①思路：</h5><p>采用哈希表记录下来所有出现过的数和对应的次数，然后利用<strong>绝对值大小进行排序</strong>（这个排序可以方便我们对表进行一次遍历，只需要看arr[i]对应的arr[i] * 2的次数是不是比前者大，即满足前者能够充分的匹配后者，然后一旦不满足就return false就好了的。</p><hr><h5 id="②解答："><a href="#②解答：" class="headerlink" title="②解答："></a>②解答：</h5><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    bool canReorderDoubled(vector<int>& arr) &#123;         unordered_map<int, int> cnt;        for (int x : arr) &#123;            ++cnt[x];        &#125;        if (cnt[0] % 2) &#123;            return false;        &#125;        vector<int> vals;        vals.reserve(cnt.size());        for (auto &[x, y] : cnt) &#123;            vals.push_back(x);        &#125;        sort(vals.begin(), vals.end(), [](int a, int b) &#123; return abs(a) < abs(b); &#125;);        for (int x : vals) &#123;            if (cnt[2 * x] < cnt[x]) &#123; // 无法找到足够的 2x 与 x 配对                return false;            &#125;            cnt[2 * x] -= cnt[x];        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="③学到的东西"><a href="#③学到的东西" class="headerlink" title="③学到的东西"></a>③学到的东西</h5><pre class="line-numbers language-c++"><code class="language-c++">//应该都是容器的相关知识，但是我还没看到，就先记录一下1.    //将哈希表里面的第一个元素放到数组里面，    for (auto &[x, y] : cnt) &#123;            vals.push_back(x);        &#125;2.    //直接在sort里面进行比较函数的书写    sort(vals.begin(), vals.end(), [](int a, int b) &#123; return abs(a) < abs(b); &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、三叶姐的题解"><a href="#三、三叶姐的题解" class="headerlink" title="三、三叶姐的题解"></a>三、三叶姐的题解</h3><p>xxxxxxxxxx &#x2F;&#x2F;c++版本的解答class Solution {public:    int maxProduct(vector<string>&amp; words) {        int n &#x3D; words.size();        vector<int> dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) {            for(int j &#x3D; 0; j &lt; words[i].size(); j++) {                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - ‘a’));              }        }        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) {            for(int j &#x3D; i+1; j &lt; n; j++) {                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) {&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                }            }        }        return ans;    }};c++</int></string></p><p><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/">三叶姐的题解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>生活分享1</title>
    <link href="https://sample.com/2022/03/30/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB1/"/>
    <id>https://sample.com/2022/03/30/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB1/</id>
    <published>2022-03-30T11:42:24.000Z</published>
    <updated>2022-04-13T00:56:00.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p>一直认为生活不应该只有学业还有各种方面的压力，一定要有属于自己的诗和远方，开启生活篇的博客就是希望能够分享一下sheepice在生活里面遇到的很多很多事情吧！也相当于没有写技术博客的一个补充吧哈哈！</p><h3 id="二、《朋友请听好》"><a href="#二、《朋友请听好》" class="headerlink" title="二、《朋友请听好》"></a>二、《朋友请听好》</h3><p><img src="https://pics1.baidu.com/feed/d788d43f8794a4c2f670bf9a1b00dfdcac6e3929.jpeg?token=8b27736236d409e565c7c4c01d6aa0cd"></p><p>这是一档我很喜欢的综艺，说是一个综艺节目但是我更觉得它的意义在于一个情感上的慰藉港湾，在这里面有很多很多温暖的声音，有很多很多暖心的故事。当然在这里面我也收获了很多很多的慰藉！</p><h5 id="①“永远要相信世上的善意”"><a href="#①“永远要相信世上的善意”" class="headerlink" title="①“永远要相信世上的善意”"></a>①“永远要相信世上的善意”</h5><p>一位打电话来的女生，因为是自己一人在外打拼，所以自己就租了一个单间的房子，而有段时间她和邻居发生了争执。邻居住着一家，有着一个已经哑了的老奶奶，还有一个可爱的小孩。女生每次回家的时候，都会发现自己的家门口摆放着一双干净但又很破旧的皮鞋，因为是一个人，回家看到这样的情况，一定会有些恐惧的感觉。有一天，女生也没忍住，就去敲了邻居家的门，对着奶奶(情绪激动地)说到这样的事情，也许是因为太突然，女生觉得可能吓到老奶奶了，她看着老奶奶好像被吓得说不出话，因此也没有继续激动下去，而是提醒之后就走了。可是当天回来之后，那一双皮鞋依旧整整齐齐地摆放在自己家的门前，女生正无语的时候，看到鞋子里面有着一张小孩子写的纸条:”阿姨你好，我的奶奶她不能说话。我的爷爷走了，家里就剩下爷爷的这一双皮鞋，奶奶知道你是一个人住在这里，担心你的安全，所以把爷爷的皮鞋放在你的门口…….”</p><p><strong>我的描述可能不会太感动，但是当时听到最后的纸条内容的时候，我是真的一下也没有绷住，眼泪很自热而然地就流了下来。那时的我就突然觉得这个世界真的很好，真的很好，无论是最亲近的人还是陌生的人，他们也许无时无刻地在对你表示着善意，而请我们也要同样地对这个世界，对这个世界的每一个人保持善意！</strong></p><h5 id="②”你愿意和我建造一个图书馆吗？“"><a href="#②”你愿意和我建造一个图书馆吗？“" class="headerlink" title="②”你愿意和我建造一个图书馆吗？“"></a>②”你愿意和我建造一个图书馆吗？“</h5><p>因为故事很长，所以希望看到此篇博客的uu们可以到<a href="https://b23.tv/qzMpMH7">朋友请听好</a>这里去看！我深深被女生最后的英文誓词感动了，不知道是不是一时兴起，但是我觉得英文得好好学：</p><ul><li><p>英文誓词</p><ul><li><p>For the first, I love you deeply and passionately that I have felt for no one else in this life.</p></li><li><p>You said “早上好” this morning with your awkward Chinese. And I thought I can’t imagine myself love you more than I do today. But I thought the same way yesterday.</p></li><li><p>And if it astonished you, it almost frightened me as well.</p></li><li><p>It’s just. I was not such an fool even once hoped. Aspired, dreamed that one could find everything one want in a person.</p></li><li><p>And yet in you, I found everything.</p><p>…….</p></li></ul></li></ul><p><strong>读至此，我渴望着自己也能够变得更加的温柔，善良等等，因为一生的遇见，遇见的所有人，还有你，是多么多么的不容易啊。就像最后唱到的《慢慢喜欢你》,歌曲温柔，听着听着，就幻想到了后面的一生。</strong></p><h3 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h3><p>虽然当下的人包括自己真的在很多很多时候，想要快一点，再快一点。也许是快一点找到喜欢的一份工作，也许是快一点找到自己喜欢的人，可是殊不知，美好是一直在身边的。走得越快，真的能够抓住吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h3&gt;&lt;p&gt;一直认为生活不应该只有学业还有各种方面的压力，一定要有属于自己的诗和远方，开启生活篇的博客就是希望能够分享一</summary>
      
    
    
    
    <category term="生活篇" scheme="https://sample.com/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/"/>
    
    
    <category term="生活" scheme="https://sample.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题2</title>
    <link href="https://sample.com/2022/03/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%982/"/>
    <id>https://sample.com/2022/03/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%982/</id>
    <published>2022-03-29T05:47:02.000Z</published>
    <updated>2022-04-18T09:19:23.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><hr><h3 id="二、leetcode每日一题"><a href="#二、leetcode每日一题" class="headerlink" title="二、leetcode每日一题"></a>二、leetcode每日一题</h3><p><img src="https://img-blog.csdnimg.cn/39df104b32574cbbac56a8e175e46cc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="滑动窗口题目"></p><p>说实话，这一题在刚开始用双指针的时候，是有些地方没有想明白的，比如当最后的右指针移动到某个位置把k次数用完后，左指针应该移动到哪个位置，所以开始死磕了好久，最后也是积累了这样一种滑动窗口的办法吧。其实就是不要等右指针移到位才开始计算结果，边移动的时候就可以开始计算了，利用维护一个sum值，当sum依然小于k的时候，右指针就可以一直往后面移动，sum也一直++，知道他大于k的那一刻，我们的left就需要移动到他等于k的地方。那么这一题和后面要-+(三叶姐的简单题加餐)的题目是几乎一样的，只不过这题是需要计算最多有多少个“F”和“T”最后取两者的最大值就是答案啦！</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string s;    int jl;    int maxConsecutiveAnswers(string answerKey, int k) &#123;        s = answerKey;        jl = k;        int ans = 0;        ans = max(getmax('T'), getmax('F'));        return ans;    &#125;    int getmax(char ss) &#123;        int n = s.size();        int sum = 0;        int as = 0;        for(int i = 0, j = 0; j < n; j++) &#123;            //不等于ss时，翻牌操作++；            sum += (s[j] != ss);            //翻牌的操作已经用空了            while(sum > jl) &#123;                sum -= (s[i] != ss);                i++;            &#125;            //边走边记录下来答案            as = max(as, j - i + 1);        &#125;        return as;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、-套餐（简单题加餐）"><a href="#三、-套餐（简单题加餐）" class="headerlink" title="三、-+套餐（简单题加餐）"></a>三、-+套餐（简单题加餐）</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486241&idx=1&sn=609ca05e6e21a72023172b52d0af0a75&chksm=fd9ca03ecaeb2928018ef5b2faf20b170ae123813eec30962d2ea2d3c93e78e54ddde0d51c87&cur_album_id=1805384400772087811&scene=189#wechat_redirect">最大连续1的个数</a></p><p>上方来自三叶姐的题解，里面涉及到dp做法；二分加前缀和；还有今天的滑动窗口，非常的厉害！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
</feed>
