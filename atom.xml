<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sheepice的博客</title>
  
  <subtitle>感谢各位家人的访问，希望能跟大家成为朋友</subtitle>
  <link href="https://sample.com/atom.xml" rel="self"/>
  
  <link href="https://sample.com/"/>
  <updated>2022-04-14T10:23:30.160Z</updated>
  <id>https://sample.com/</id>
  
  <author>
    <name>sheepice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣刷题5</title>
    <link href="https://sample.com/2022/04/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%985/"/>
    <id>https://sample.com/2022/04/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%985/</id>
    <published>2022-04-14T09:32:12.000Z</published>
    <updated>2022-04-14T10:23:30.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解的灵感来源于我自己看了很多神犇的题解，真的会很有收获。</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h1 id="二、数位dp初刷"><a href="#二、数位dp初刷" class="headerlink" title="二、数位dp初刷"></a>二、数位dp初刷</h1><p><img src="https://img-blog.csdnimg.cn/372be999948a4fd587aa24b90da22d48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="组合题dp"></p><h1 id="三、思路"><a href="#三、思路" class="headerlink" title="三、思路"></a>三、思路</h1><p>这题其实如果用我们高中学的组合的思想，可以做。因为他本身就是一个组合的题目，也就是说，最简单的思路就是，分析不同位数情况下构成的小于n的情况。所以很容易得到，一共只有两种情况</p><ul><li>情况一：构成的数字比要求数字的位数小</li><li>情况二：构成的数字比要求数字的位数大</li></ul><h3 id="①情况一"><a href="#①情况一" class="headerlink" title="①情况一"></a>①情况一</h3><p><font color="red">对于情况一来说，我们很容易进行分析，就是假设当前需要构成的位数为i,我们可以选择的数就是digits数组的长度，因此这种情况的结果累加的代码比较简单，直接给出：</font></p><pre class="line-numbers language-c++"><code class="language-c++">//位数不相同的情况//m代表的是数字n的位数一共有多少位//m - 1就可以满足i所代表的位数一定小于n所代表的位数        for(int i = 1; i <= m - 1; i++) &#123;            ans += pow(lent,i);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②情况二的文字描述"><a href="#②情况二的文字描述" class="headerlink" title="②情况二的文字描述"></a>②情况二的文字描述</h3><p><font color="red"><del>对于情况二来说，由我们高中的知识就可以知道，我们可以依次的去比较每一位数在原digits的位置(由于数组是一个递增的情况)，所以当我们找到某个位置的时候，我们就能确定在位置之前的数，都是小于本位置，也就是可以进行一个选择。但是在这个地方，我们要知道不能完全依赖于这样的思想去写题目。</del></font></p><blockquote></blockquote><p><strong>就是假设我们现在选择到了4567的其中某一位且一定要从高位选起(也就是先选2所对应的位置)，这是为什么呢。比如我们给到的选择为1，2，3我们会发现在选择第一个高位的时候，无论我们选择什么，都能满足千位的数一定比4小，那根据乘法原理，很显然所有的答案其实就是$3×3×3×3$，也就是每个位置上都有3种选择</strong></p><p><strong>考虑一种情况，如果考虑$n&#x3D;4567$的时候给到的选择为2，4，8，9呢？此时我们发现如果选择4的时候，会有两种选择2，4但是出于考虑，我们并不能直接说第一个位置2，4都能选，因为我们无法保证选完4之后，是否后面的选择能够保证百位上的数比5小，因此在计算第一位的时候，我们必须只能选2，然后后面的三个位置任意选,也就是$1×3×3×3$,那么很多人在这里就不理解，那4如果作为第一位呢？其实他放到了后面的判断中去了，因为当把4前面的2选完以后，如果后面的操作还能进行，就已经固定了千位为4，然后再进行后面结果的积累。</strong></p><p><font color="red">所以最终的结果一定是不断的去更新每一位之后的选择可能性，因为我们已经确定好了位数之前的可能的结果，这也就是正确解答这个题目的一个顺序!当然如果大家不能理解的话，可以跟着后面的代码进行走一遍，然后多举一些例子辅助性的理解！</font></p><h3 id="③情况二的数学描述"><a href="#③情况二的数学描述" class="headerlink" title="③情况二的数学描述"></a>③情况二的数学描述</h3><p>跟据情况二的文字描述，下面把它用数学语言再进行描述一遍。假设一个数字为n，这个数字一共的位数为len,题目给我们选择的大小位changes(也就是digits数组的长度)。如果我们此时正在确定该位数的第k位时候的结果(也就是说前k位的结果已经被统计确认好了)。我们首先要找到digits数组中的一个位置l(数组已经转化为int类型了)，此位置满足$digits[l] &lt;&#x3D; n[k]$(其中n[k]代表第k位代表的数字)，会分为三种情况：</p><ul><li><p>①$digits[l] &lt; n[k]$：说明l位置包括l在内的数都可以填充这个位置，也就是这个位置有$l+1$种可能性(别忘了下标是从0开始的),当确定这个位置之后，剩余的位置可以任意的进行选择也就是有$pow(len-k,changes)$。所以累加的结果应该为:$(l+1)×pow(len-k,changes)$,此后的结果，因为已经被全部确认了，所以循环要直接<strong>break</strong>!!</p></li><li><p>②$digits[l] &#x3D; n[k]$：说明l位置不包括l在内的数都可以填充这个位置(因为l位置后面还是一个未知的结果，应该等到下一次循环再进行累加)，也就是这个位置有$l+1$种可能性(别忘了下标是从0开始的),当确定这个位置之后，剩余的位置可以任意的进行选择也就是有$pow(len-k,changes)$。所以累加的结果应该为:$(l+1)*pow(len-k,changes)$</p></li><li><p>③找不到满足$digits[l] &lt;&#x3D; n[k]$条件的数:直接break！</p></li></ul><h1 id="四、AC代码"><a href="#四、AC代码" class="headerlink" title="四、AC代码"></a>四、AC代码</h1><p>综上所述，最后把代码全部贴出来，仅供参考。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int atMostNGivenDigitSet(vector<string>& digits, int n) &#123;        int lent = digits.size();        vector<int> nums(lent, 0);        for(int i = 0; i < lent; i++) &#123;            nums[i] = digits[i][0] - '0';        &#125;        long long ans = 0;        //求出n的位数以及每一位数字上的数        vector<int> nmb;        while(n != 0) &#123;            nmb.push_back(n % 10);            n /= 10;        &#125;        int m = nmb.size();   //一共的位数        //位数不相同的情况        for(int i = 1; i <= m - 1; i++) &#123;            ans += pow(lent,i);        &#125;        //位数相同的情况        for(int i = m - 1, p = 1; i >= 0; i--, p++) &#123;            //因为数组的递增，可以用二分去寻找位置            //先找到小于等于此位数的第一个位置            //当然其实因为数组的常量比较小，直接循环找也没有问题的            int l = -1, r = lent;            while(l + 1 != r) &#123;                int mid = (l + r) >> 1;                if(nums[mid] > nmb[i]) r = mid;                else l = mid;            &#125;            if(l == -1) break;            else if(nums[l] == nmb[i]) &#123;                ans += l * pow(lent, m - p);                //如果就连最后一位都相等的时候，一定要记得加上与本身完全相同的那一个结果                //因为循环后不会再继续探索后面的结果了                //这里可以举一些例子帮助理解                if(i == 0) ans++;            &#125;            else &#123;                ans += (l + 1) * pow(lent, m - p);                //已经找到了所有结果了记得break                break;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="动态规划" scheme="https://sample.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线段树初探</title>
    <link href="https://sample.com/2022/04/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://sample.com/2022/04/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-13T00:48:46.000Z</published>
    <updated>2022-04-14T10:15:37.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线段树的相关概念"><a href="#一、线段树的相关概念" class="headerlink" title="一、线段树的相关概念"></a>一、线段树的相关概念</h1><h3 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h3><p>什么是线段树呢？首先默认很多同学已经知道树这个结构了。也就是说，我们要用树的每一个节点去存下每一段数，我觉得线段树的名字由来大概如此吧！我们可以看下的图</p><p><img src="https://img-blog.csdnimg.cn/f96a5cc24c4c4d86989ef7b0f60c4aea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树图解"></p><p><strong>上面的图就是线段树上的每一个节点所存的数代表的含义，比如一个线段的左编号为l，右编号为r，那么这个线段所代表的就是$\sum_ {i&#x3D;l}^{r}nums[i]$,最终呈现的一颗树如下图。</strong></p><p><img src="https://img-blog.csdnimg.cn/4437b4713e424355a0743e5902fa3564.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="整个线段树的图形"></p><blockquote><p>而蓝色标记的数字代表树上节点的编号，这个是在二叉树里面的编号，所以可以知道每一个节点左儿子和右儿子的编号，假设当前的编号k, 那么他的<font color="red">左儿子为：2k(k &lt;&lt; 1),右儿子为：2k+1(k&lt;&lt;1|1)</font>,这里加红的地方大家可以注意一下，因为一般来说，位运算能比较快的去遍历一整颗树，所以在后面的代码全部由位运算代替左右儿子的遍历。</p></blockquote><h3 id="②好处"><a href="#②好处" class="headerlink" title="②好处"></a>②好处</h3><p>首先呢，由于线段树是一个二叉树，因此它可以让时间复杂度为$O(N)$的代码降低为$log_2(N)$的时间复杂度，在数据大的时候，很有可能就是这样的时间差距，带来更多的收益。那么线段树到底会解决什么样的问题，那么复杂的一棵树，为什么我一定要拿来用呢？有几个点：<font color="red">如果我们多次修改某个区间，求区间和又或者是多次让某个区间变成一个数</font>,类似这样的问题是可以用线段树的。当然这些问题是可以用线段数组来写的，但是有的时候我们会不得不用线段树，比如多次将一个区间变成同一个数。当然线段树的很多功能可以通过树状数组来代替，如果能够使用树状数组写的题目，最好能够优先选择树状数组。所以为什么还要去学习线段树呢？我觉得在刚开始我一直很畏惧去学，但是经过一天的学习之后我发现，学习完线段树，不仅是多了一个解决问题的手段，多学了一个数据结构，更多的是对递归，分治的思想又加深了。所以建议uu们都可以去学习这样的一颗复杂但是优美的树！</p><h1 id="二、线段树的基本操作（1）"><a href="#二、线段树的基本操作（1）" class="headerlink" title="二、线段树的基本操作（1）"></a>二、线段树的基本操作（1）</h1><h3 id="①建树"><a href="#①建树" class="headerlink" title="①建树"></a>①建树</h3><p>毫无疑问对于这样的一个数据结构来说，我们肯定是得先要把它建出来。这样建树的过程其实在树的学习中，大家肯定都是会的，而因为线段树的定义不同，因此我们要在每次递归回溯的过程，让节点所代表的值加上他左子树和右子树的值，才最终代表某个节点是由下面子树的和而构建来的，具体代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②修改单个点的值"><a href="#②修改单个点的值" class="headerlink" title="②修改单个点的值"></a>②修改单个点的值</h3><p>如果题目要求让某个点加上一个val值的话，很显然，在更新一整颗树的时候，每一个线段带有该点都必须一起的进行更新，然后在更新的过程的时候，会有一个必要条件，也就是更新点的下标一定是会被包含在每次递归的左右区间之内的，所以有如下的代码。</p><pre class="line-numbers language-c++"><code class="language-c++">//进行单个数的加值void add(int k, int l, int r, int x, int val) &#123;    //改变的数根据递归肯定会在[l, r]的区间之内     sum[k] += val;    if(l == r) return;    int m = (l + r) >> 1;    //要改变的数在左子树     if(x <= m) &#123;        add(k << 1, l, m, x, val);    &#125;    //要改变的数在右子树     else &#123;        add(k << 1 | 1, m + 1, r, x, val);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完成上面的操作之后，就可以让每一颗树进行对应的更新了，因此如果在次基础上，如果我们要查询一段区间和的时候，我们其实只需要递归的去计算每个区间的和就好了</strong></p><h3 id="③针对只修改了单个点值的区间查询"><a href="#③针对只修改了单个点值的区间查询" class="headerlink" title="③针对只修改了单个点值的区间查询"></a>③针对只修改了单个点值的区间查询</h3><p><font color="red">这里可以注意一下标题，只针对修改了单个点值的区间查询，因为在这个前提下的计算和之后的计算有着不同的地方，所以先看一个点，再慢慢推进到后面的点。</font>这里的操作还是以下图为例子：</p><p><img src="https://img-blog.csdnimg.cn/f96a5cc24c4c4d86989ef7b0f60c4aea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树图解"></p><blockquote><p>因为对于这里的递归会有很多的不理解的地方，在这稍作提示。如果我们在做一个区间计算的时候，如果计算的区间刚好在左子树，那么我们最后只需要递归左子树的和就好了，比如在编号为①的时候，我们要查找$[1,2]$区间的和，那么其实只需要到编号为②的地方去计算，右子树同理。那么如果我们跨了区间怎么半呢？比如在上图我要查找$[2,4]$区间的和呢，也很简单，只不过就是左子树的区间$[2,3]$和右子树的区间$[3,4]$两个计算的结果加在一起，具体很多的注释加在代码内，建议读者可以用一些例子理解这个递归式子。而下面第一行注释的lazy标记是后面要介绍的内容！</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//计算某个区间的和，不含有lazy标记 int cal(int k, int l, int r, int x, int y) &#123;    if(l == x && r == y) &#123;        return sum[k];     &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return cal(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return cal(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return cal(k << 1, l, m, x, m) +         cal(k << 1 | 1, m + 1, r, m + 1, y);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④例题模板1"><a href="#④例题模板1" class="headerlink" title="④例题模板1"></a>④例题模板1</h3><p><img src="https://img-blog.csdnimg.cn/745ab82a49654f21a1ccc5b8c33fe9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="例题1"></p><p>​                                                                                             <a href="https://www.luogu.com.cn/problem/P3374">例题1入口</a></p><p><strong>这个例题将我们所说的结合起来就可以写了的，当然他是树状数组的一个板子，之所以用线段树去写，只是为了加深对线段树的熟悉度罢了。</strong></p><h3 id="⑤AC全部代码"><a href="#⑤AC全部代码" class="headerlink" title="⑤AC全部代码"></a>⑤AC全部代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;//开辟其他数组的时候最好为4n让数组不会产生越界的情况 int nums[500005];  //数据的存储 int sum[2000010];   //区间和的存储 int lz[2000010];     //lazy标记的存储int n, m;//进行线段树的构建 void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;//进行单个数的加值void add(int k, int l, int r, int x, int val) &#123;    //改变的数根据递归肯定会在[l, r]的区间之内     sum[k] += val;    if(l == r) return;    int m = (l + r) >> 1;    //要改变的数在左子树     if(x <= m) &#123;        add(k << 1, l, m, x, val);    &#125;    //要改变的数在右子树     else &#123;        add(k << 1 | 1, m + 1, r, x, val);     &#125;&#125;//计算某个区间的和，不含有laze标记 int cal(int k, int l, int r, int x, int y) &#123;    if(l == x && r == y) &#123;        return sum[k];     &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return cal(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return cal(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return cal(k << 1, l, m, x, m) +         cal(k << 1 | 1, m + 1, r, m + 1, y);    &#125;&#125;int main() &#123;    cin >> n >> m;    for(int i = 1; i <= n; i++) &#123;        cin >> nums[i];    &#125;    build_tree(1, 1, n);    for(int i = 1; i <=m; i++) &#123;        int cz, x, y;        cin >> cz >> x >> y;        if(cz == 1) &#123;            add(1, 1, n, x, y);        &#125;        else &#123;            cout << cal(1, 1, n, x, y) << endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、线段树的基本操作（2）不下传懒惰标记版本"><a href="#三、线段树的基本操作（2）不下传懒惰标记版本" class="headerlink" title="三、线段树的基本操作（2）不下传懒惰标记版本"></a>三、线段树的基本操作（2）不下传懒惰标记版本</h1><p>在上面的操作，我们只是进行了对线段树中的某一个值进行一个加减的过程，那么很显然不能体现线段树的好处。那么如果我们对一整个区间去进行操作呢？我们先看一下下面的引入：</p><h3 id="①引入懒惰标记"><a href="#①引入懒惰标记" class="headerlink" title="①引入懒惰标记"></a>①引入懒惰标记</h3><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记"></p><p><strong>如图所示，左边是我们最开始要构建的一颗树，右边是加入了懒惰标记的时候构建的一颗树，在这个地方我们看到了在两个地方我们由红色标记了一个东西，这就是我们的懒惰标记。由它的名字我们可以知道，就是我们可以偷懒，让程序不用去把所有的值进行修改，就可以得到我们最终的答案。也就是图中的下标为3，4的地方的并没有进行加1操作，但是他们的和是加上了2的，这是怎么偷懒的呢？</strong><font color="red">通俗来说，就是假设我们计算一个区间，如果线段树的那一段已经恰好完全包含了这个区间，正如[3,4]的区间被恰好包含在编号为3的子树上，那么我们就直接给他打上一个+1的标记，代表其实它的儿子是都需要加1的，但是由于我已经包含了他们，因此我们不再需要继续往下递归，因为它们的老爸已经把他们相加的结果记录好了，这个操作实现的代码如下：</font></p><pre class="line-numbers language-c++"><code class="language-c++">void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //先让能够满足所求区间为总区间的子区间的加上对应的区间和     sum[k] += (y - x + 1) * val;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②区间的查询"><a href="#②区间的查询" class="headerlink" title="②区间的查询"></a>②区间的查询</h3><p>好了那么我们要查询一个区间怎么办呢？首先这里由于我们是这里先介绍不把懒惰标记下传的写法，因此，下面的方法与后面把懒惰标记下传的方法会有些不同的地方，大家注意看一下区别。</p><p>回归正题，如果我们要查找一段区间，但是由于懒惰坐标并没有下传，这就会导致一个什么事情呢，就是在我们查询的时候，有一些孩子的值是并没有得到更新的，这就会导致，他们所存的sum值是没有得到更新的，还需要去加上之前积累的懒惰标记的值才行，这里还是以上图为例子。</p><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记计算1"></p><p>假设我们要查找的就是$[4,4]$这个区间呢？我们可以看到本身4下标的这个数字是要加1的，但是很遗憾的是，我们的第一步操作并没有达到我们想要满足的效果。那么我们可以关注一下，从下标为4的那个地方往上看，是不是可以看到一个懒惰标记，这个代表了什么呢？不就是代表了它上方如果存在懒惰标记的话，那么就代表因为太懒，本来它本身是需要加上懒惰标记的值但是没有加上，那么我们只需要把他上方所有积累的懒惰标记加起来，然后最后在计算本身的时候加上$(\sum{lz}*length(区间的长度))$就好了。这个地方会有点难理解为什么要加上上方所有的和，不急，可以在用一个图为例子：</p><p><img src="https://img-blog.csdnimg.cn/a867ad730ac34f0d9e84e2f799221706.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记计算2"></p><p><strong>假设在前面图的基础上让区间[1,4]都加上了一个1，很显然，因为恰好包含，除了根节点挂上一个+1的懒惰标记，其他地方都不会变化，那如果此时我们还要计算[4,4]的值呢？很显然我们要加上两个懒惰标记的值，因为4被连续加上了两次1。也就是说当我们不把懒惰标记下传的时候，我们是需要计算两部分的值才能最终确定一个区间的和。一个就是懒惰标记的积累和，另外就是本身的子树累计的和，代码如下，大家可以结合代码去走一遍图：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和//p代表当前下标的lazy值 int query(int k, int l, int r, int x, int y, int p) &#123;    //先进行lazy值的累加    p += lz[k];     //如果恰好包含    if(l == x && r == y) &#123;        return p * (y - x + 1) + sum[k];    &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return query(k << 1, l, m, x, y, p);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return query(k << 1 | 1, m + 1, r, x, y, p);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return query(k << 1, l, m, x, m, p) +         query(k << 1 | 1, m + 1, r, m + 1, y, p);    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③例题模板2"><a href="#③例题模板2" class="headerlink" title="③例题模板2"></a>③例题模板2</h3><p><img src="https://img-blog.csdnimg.cn/0209f12304fe4725896c1b92231635aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树模板"></p><p>​                                                                                                    <a href="https://www.luogu.com.cn/problem/P3372">题目2入口</a></p><h3 id="④AC完整代码"><a href="#④AC完整代码" class="headerlink" title="④AC完整代码"></a>④AC完整代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;//开辟其他数组的时候最好为4n让数组不会产生越界的情况 int nums[100001];  //数据的存储 long long sum[400010];   //区间和的存储 long long lz[400010];     //lazy标记的存储int n, m;//进行线段树的构建 void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;//进行区间的加值//函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //先让能够满足所求区间为总区间的子区间的加上对应的区间和     sum[k] += (y - x + 1) * val;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125; &#125;//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和//p代表当前下标的lazy值 long long query(int k, int l, int r, int x, int y, long long p) &#123;    //先进行lazy值的累加    p += lz[k];     //如果恰好包含    if(l == x && r == y) &#123;        return p * (y - x + 1) + sum[k];    &#125;    int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        return query(k << 1, l, m, x, y, p);    &#125;    //区间完全在右子树     else if(x > m) &#123;         return query(k << 1 | 1, m + 1, r, x, y, p);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         return query(k << 1, l, m, x, m, p) +         query(k << 1 | 1, m + 1, r, m + 1, y, p);    &#125; &#125;int main() &#123;    scanf("%d%d", &n, &m);    for(int i = 1; i <= n; i++) &#123;        scanf("%d", &nums[i]);    &#125;    build_tree(1, 1, n);    for(int i = 1; i <=m; i++) &#123;        int cz;        scanf("%d", &cz);        if(cz == 1) &#123;            int x,y;            long long k;            scanf("%d%d%lld", &x, &y, &k);            insert(1, 1, n, x, y, k);        &#125;        else &#123;            int x,y;            scanf("%d%d", &x, &y);            printf("%lld\n", query(1, 1, n, x, y, 0));        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、线段树的基本操作（2）下传懒惰标记版本"><a href="#四、线段树的基本操作（2）下传懒惰标记版本" class="headerlink" title="四、线段树的基本操作（2）下传懒惰标记版本"></a>四、线段树的基本操作（2）下传懒惰标记版本</h1><h3 id="①引言"><a href="#①引言" class="headerlink" title="①引言"></a>①引言</h3><p>这里其实就是说会根据很多人的不同习惯有很多不同的写法，所以仅供大家参考目前我在慢慢习惯的一个写法。</p><p>下传懒惰标记其实就是说，我们不要去管计算的时候，一个区间上面的懒惰标记，假设还是如图</p><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记下传"></p><p>如果我们还是要去计算[4,4]的值，我们不妨在访问和为9的那个线段的时候，直接把它的懒惰标记传给它的左右孩子，然后它本身的懒惰标记变成0。这样的话，我们计算值的时候就不用管上面懒惰标记的和了，因为都是0。那么我们其实就是在计算本层的一个值加上本身就应该加上的懒惰标记的值，其实和之前的方法就是一个过程了相当于，就是思维上稍微有点不同。<font color="red">比如在这个地方，因为计算的时候有可能会把懒惰标记下传，这样的过程会导致什么呢？会导致上方的值因为懒惰标记的下传，上面的值得不到一个更新，因此很简单的思路就是。在递归回溯的过程中，让上方的值不断的进行一个更新，也就是和我们文章最初开头的一种方式是一样的了！</font></p><h3 id="②插入的操作-懒惰标记下传"><a href="#②插入的操作-懒惰标记下传" class="headerlink" title="②插入的操作(懒惰标记下传)"></a>②插入的操作(懒惰标记下传)</h3><pre class="line-numbers language-c++"><code class="language-c++">//进行区间的加值//函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;     int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125;    //最后递归回溯的时候不断更新上面的值    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②查询的操作-懒惰标记下传"><a href="#②查询的操作-懒惰标记下传" class="headerlink" title="②查询的操作(懒惰标记下传)"></a>②查询的操作(懒惰标记下传)</h3><pre class="line-numbers language-c++"><code class="language-c++">//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和long long query(int k, int l, int r, int x, int y) &#123;    //如果恰好包含    if(l == x && r == y) &#123;        return sum[k] + lz[k] * (r - l + 1);    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;    int m = (l + r) >> 1;    long long ret = 0;    //区间完全在左子树     if(y <= m) &#123;        ret = query(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         ret = query(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         ret = query(k << 1, l, m, x, m) +         query(k << 1 | 1, m + 1, r, m + 1, y);    &#125;    //最后递归回溯的时候不断更新上面的值    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];     return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">这里为什么要另外设计一个ret变量对结果进行保存呢？对比不下传的方法，我们可以看到，本次的方法会边回溯边更新答案，因此在我们回溯的过程中，我们才会得到正确的答案，因此回溯的过程要把区间的左右记录下来，最后完成区间和的更新才是我们最终的答案。而方法二为什么不用这个呢？就是因为方法二是不断的往下去更新，然后遇到可以不用更新的地方就直接回溯了，但是我们发现在向下递归的时候，就已经对答案进行了更新，也就是方法三的一个逆过程！</font></p><h3 id="③AC代码"><a href="#③AC代码" class="headerlink" title="③AC代码"></a>③AC代码</h3><p>因为题目还是方法二的，因此这里直接贴上不同版本的代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;//开辟其他数组的时候最好为4n让数组不会产生越界的情况 long long nums[100001];  //数据的存储 long long sum[400010];   //区间和的存储 long long lz[400010];     //lazy标记的存储int n, m;//进行线段树的构建 void build_tree(int k, int l, int r) &#123;    if(l == r) &#123;        sum[k] = nums[l];        return;     &#125;    int m = (l + r) >> 1; //取l，r的中点    //递归左子树，然后k<<1相当于2*k     build_tree(k << 1, l, m);    //递归右子树，然后k << 1 | 1相当于2*k+1     build_tree(k << 1 | 1, m + 1, r);     //进行区间的求和累积(左子树和右子树的和)    sum[k] = sum[k << 1] + sum[k << 1 | 1]; &#125;//进行区间的加值//函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;    //如果刚好区域被包含在[l,r]的区间内     if(l == x && r == y) &#123;         //给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数          lz[k] += val;           return;    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;     int m = (l + r) >> 1;    //区间完全在左子树     if(y <= m) &#123;        insert(k << 1, l, m, x, y, val);    &#125;    //区间完全在右子树     else if(x > m) &#123;         insert(k << 1 | 1, m + 1, r, x, y, val);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         insert(k << 1, l, m, x, m, val);        insert(k << 1 | 1, m + 1, r, m + 1, y, val);    &#125;    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];&#125;//进行区间的查询//函数的意思：在[l,r]上的[x,y]区间所有数的和long long query(int k, int l, int r, int x, int y) &#123;    //如果恰好包含    if(l == x && r == y) &#123;        return sum[k] + lz[k] * (r - l + 1);    &#125;    //如果此处有标记，向下传    if(lz[k]) &#123;        lz[k << 1] += lz[k];        lz[k << 1 | 1] += lz[k];        lz[k] = 0; //记得懒惰标记的清0     &#125;    int m = (l + r) >> 1;    long long ret = 0;    //区间完全在左子树     if(y <= m) &#123;        ret = query(k << 1, l, m, x, y);    &#125;    //区间完全在右子树     else if(x > m) &#123;         ret = query(k << 1 | 1, m + 1, r, x, y);    &#125;    //区间跨越了左右子树    else &#123;        //合并左右子树的结果         ret = query(k << 1, l, m, x, m) +         query(k << 1 | 1, m + 1, r, m + 1, y);    &#125;    sum[k] = sum[k << 1] + (m - l + 1) * lz[k << 1]                + sum[k << 1 | 1] + (r - m) * lz[k << 1 | 1];     return ret;&#125;int main() &#123;    cin >> n >> m;    for(int i = 1; i <= n; i++) &#123;        cin >> nums[i];    &#125;    build_tree(1, 1, n);    for(int i = 1; i <=m; i++) &#123;        int cz, x, y;        long long k;        cin >> cz;        if(cz == 1) &#123;            cin >> x >> y >> k;            insert(1, 1, n, x, y, k);        &#125;        else &#123;            cin >> x >> y;            cout << query(1, 1, n, x, y) << endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总而言之，线段树会有很多不同的写法，本文仅提供目前学到的这种，uu们可以找到自己习惯的写法，然后经常复习一下，我觉得对线段树就会慢慢不陌生了！！！</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">线段树详解</a></p><p><a href="https://www.bilibili.com/video/BV1uS4y1m7zY?spm_id_from=333.788.header_right.history_list.click">wls的b站视频</a></p><p>感谢各大佬写的博客，发的视频的帮助！</p><p>本文章的问题也希望读者们指出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线段树的相关概念&quot;&gt;&lt;a href=&quot;#一、线段树的相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、线段树的相关概念&quot;&gt;&lt;/a&gt;一、线段树的相关概念&lt;/h1&gt;&lt;h3 id=&quot;①定义&quot;&gt;&lt;a href=&quot;#①定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="线段树" scheme="https://sample.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题4</title>
    <link href="https://sample.com/2022/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%984/"/>
    <id>https://sample.com/2022/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%984/</id>
    <published>2022-04-12T02:49:55.000Z</published>
    <updated>2022-04-14T10:20:02.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解的灵感来源于我自己看了很多神犇的题解，真的会很有收获。</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h1 id="二、力扣的某“简单题”"><a href="#二、力扣的某“简单题”" class="headerlink" title="二、力扣的某“简单题”"></a>二、力扣的某“简单题”</h1><p><img src="https://img-blog.csdnimg.cn/ec95219d02954e7fb50cbc622d3e0efe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="检查整数是否被全部覆盖"></p><p><strong>这个题目其实说真的，刚开始觉得真的挺难的，然后看到是个简单题我就知道数据的范围肯定给的非常的小，果不其然，数据范围只给了50，哈哈哈，所以第一次做这个题目的时候，这不就是简单的暴力枚举的题目吧，因为这题是三叶姐给到的“-+”题，然后看了看，好家伙，居然有可能上升为一个困难题（<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490741&idx=1&sn=cd4ab8ff1852c379223efb66d5e904ab">三叶姐关于本题的解答</a>）,awsl,于是乎我觉得今天去学习一下线段树的基本东西！！</strong></p><h1 id="三、一题多解"><a href="#三、一题多解" class="headerlink" title="三、一题多解"></a>三、一题多解</h1><h2 id="①暴力哈希"><a href="#①暴力哈希" class="headerlink" title="①暴力哈希"></a>①暴力哈希</h2><p>这里其实可以很容易想到，把所有题目中给到的range范围中的数，直接存储下来，然后呢直接进行一次$[left, right]$区间的一个遍历，看看区间内的元素是否满足在区间之内就好了！</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    map<int, int> nums;    bool isCovered(vector<vector<int>>& ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            for(auto i = range[0]; i <= range[1]; i++) &#123;                nums[i]++;            &#125;        &#125;        for(int i = left; i <= right; i++) &#123;            if(!nums.count(i)) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>暴力解法的时间复杂度为$O(N)$，由于这里开了一个哈希表，所以空间复杂度为$O(N)$。当然这里的数据因为比较小嘛，直接开一个常数的52一个数组去记录数字是否存在，空间复杂度就变成$O(C)$了哈哈。</p><h2 id="②差分数组加前缀和"><a href="#②差分数组加前缀和" class="headerlink" title="②差分数组加前缀和"></a>②差分数组加前缀和</h2><p>关于差分的思想和前缀和的计算，相信很多同学已经会了，在此不多加赘述，那么这一题的差分思想在哪呢？其实就是我们去计算一个一个区间所存在数字的时候.先设置一个差分数组$diff[52]$,假设我们要计算区间$[1,10]$之内，保证这之间的数都出现过也就不为0，那么我们只需要让$diff[1]+1$然后让$diff[11]-1$，之后对区间做一次前缀和我们可以发现区间$[1,10]$内的$diff$数组就会全部变成1，代表数字出现在区间内，这样虽然并没有大大的优化时间复杂度。<font color="red">但是我们不难发现，如果当题目所给的区间有重复的时候，我们是可以通过这样的方法去计算出每一个数字被重复的次数，也就是在整个区间里面重复出现了多少次，这个可能也对日后碰到这样的题目提供了一个非常不错的思路！</font></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int diff[52];    bool isCovered(vector<vector<int>>& ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            diff[range[0]]++;            diff[range[1] + 1]--;            &#125;        for(int i = 1; i < 52; i++) &#123;            diff[i] += diff[i - 1];        &#125;        for(int i = left; i <= right; i++) &#123;            if(diff[i] <= 0) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为$O(N)$，空间复杂度就变成$O(C)$。</p><h2 id="③树状数组"><a href="#③树状数组" class="headerlink" title="③树状数组"></a>③树状数组</h2><p><strong>本题采用线状数组其实无非就是会和第二种解法一样，只不过在树状数组的add操作里面，每次加入的是代表此元素出现的次数，最后利用差分的思想，可以直接得到某元素出现的次数，其实和方法二大同小异，但是希望自己再练一遍树状数组，所以呢，就还是写了一遍代码。如果对树状数组不了解的同学，sheepice也写了一篇博客，仅供uu们进行参考.</strong><a href="https://sheepice.github.io/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/">树状数组初探</a>！！</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int n = 55;    int sum[55];    int lowbit(int x) &#123;        return x & (-x);    &#125;    void add(int index, int value) &#123;        for(int i = index; i <= n - 1; i += lowbit(i)) &#123;            sum[i] += value;        &#125;    &#125;    int query(int index) &#123;        int ans = 0;        for(int i = index; i > 0; i -= lowbit(i)) &#123;            ans += sum[i];        &#125;        return ans;    &#125;    bool isCovered(vector<vector<int>>& ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            for(auto i = range[0]; i <= range[1]; i++) &#123;                add(i, 1);            &#125;            &#125;        for(int i = left; i <= right; i++) &#123;            if(query(i) - query(i - 1) <= 0) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xxxxxxxxxx &#x2F;&#x2F;c++版本的解答class Solution {public:    int maxProduct(vector<string>&amp; words) {        int n &#x3D; words.size();        vector<int> dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) {            for(int j &#x3D; 0; j &lt; words[i].size(); j++) {                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - ‘a’));              }        }        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) {            for(int j &#x3D; i+1; j &lt; n; j++) {                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) {&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                }            }        }        return ans;    }};c++</int></string></p><h2 id="④线段树"><a href="#④线段树" class="headerlink" title="④线段树"></a>④线段树</h2><p>线段树应该是解决所有树状数组能够解决的一些相关问题，同时也是解决绝大部分的区间求和和查询的一个最有利的手段，有关线段树的学习，大家可以参考此篇：<a href="https://blog.csdn.net/huangzihaoal/article/details/81813454?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164973450016780366523945%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164973450016780366523945&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-81813454.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">线段树和树状数组</a>。本篇下面的代码仅供参考，因为sheepicce今天才稍微懂一点线段树，<font color="red"><strong>预计这周会总结一下线段树的一些东西哦！</strong></font></p><blockquote><p>const int N &#x3D; 55;<br>class Solution {<br>public:<br>struct Node {<br>       int l, r, cnt;<br>   };<br>   Node tr [N * 4];<br>   void pushup(int u) {<br>       tr[u].cnt &#x3D; tr[u &lt;&lt; 1].cnt + tr[u &lt;&lt; 1 | 1].cnt;<br>   }<br>   void build(int u, int l, int r) {<br>       tr[u].l &#x3D; l, tr[u].r &#x3D; r, tr[u].cnt &#x3D; 0;<br>       if(l !&#x3D; r)<br>       {<br>           int mid &#x3D; (l + r) &gt;&gt; 1;<br>           build(u &lt;&lt; 1, l, mid);<br>           build(u &lt;&lt; 1 | 1, mid + 1, r);<br>           pushup(u);<br>       }<br>   }<br>   &#x2F;&#x2F; 从 tr 数组的下标 u 开始，在数值 x 的位置进行标记<br>   void update(int u, int x) {<br>       if (tr[u].l &#x3D;&#x3D; x &amp;&amp; tr[u].r &#x3D;&#x3D; x) {<br>           tr[u].cnt &#x3D; 1;<br>       } else {<br>           int mid &#x3D; (tr[u].l + tr[u].r) &gt;&gt; 1;<br>           if (x &lt;&#x3D; mid) update(u &lt;&lt; 1, x);<br>           else update(u &lt;&lt; 1 | 1, x);<br>           pushup(u);<br>       }<br>   }<br>   &#x2F;&#x2F; 从 tr 数组的下标 u 开始，查询 [l,r] 范围内有多少个数值被标记<br>   int query(int u, int l, int r) {<br>       if (l &lt;&#x3D; tr[u].l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].cnt;<br>       int mid &#x3D; (tr[u].l + tr[u].r) &gt;&gt; 1;<br>       int ans &#x3D; 0;<br>       if (l &lt;&#x3D; mid) ans +&#x3D; query(u &lt;&lt; 1, l, r);<br>       if (r &gt; mid) ans +&#x3D; query(u &lt;&lt; 1 | 1, l, r);<br>       return ans;<br>   }<br>   bool isCovered(vector &lt;vector <int>&gt; &amp; rs, int l, int r) {<br>       build(1, 1, N);<br>       for (auto &amp;  cur : rs) {<br>           int a &#x3D; cur[0], b &#x3D; cur[1];<br>           for (int i &#x3D; a; i &lt;&#x3D; b; i++) {<br>               update(1, i);<br>           }<br>       }<br>       int tot &#x3D; r - l + 1 , cnt &#x3D; query(1, l, r);<br>       return tot &#x3D;&#x3D; cnt;<br>   }<br>};</int></p></blockquote><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>总之，虽然是一个简单的题目，但是还是有很多可以拓展的地方，这也是我需要慢慢去学习的！加油啊！冲鸭！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="树状数组" scheme="https://sample.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="线段树" scheme="https://sample.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>周总结-3</title>
    <link href="https://sample.com/2022/04/10/%E5%91%A8%E6%80%BB%E7%BB%93-3/"/>
    <id>https://sample.com/2022/04/10/%E5%91%A8%E6%80%BB%E7%BB%93-3/</id>
    <published>2022-04-10T08:55:51.000Z</published>
    <updated>2022-04-10T09:24:28.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、力扣的刷题"><a href="#二、力扣的刷题" class="headerlink" title="二、力扣的刷题"></a>二、力扣的刷题</h3><p>这周感觉上，是在数据结构上面下了点功夫吧，对c++的一些容器的概念还有一些用法有了更加清楚的一个认识，然后现在使用迭代器的时候也能够敢去用一些以前不敢用的一些写法。比如<font color="red">auto</font>的使用，迭代器中<font color="red">begin（）</font>的一些使用了，感觉还是比较好的。今天周日好像已经是坚持力扣刷题的第53天了，不知不觉这两个多月的时间吧，力扣的题目已经刷了120多道了，虽然自己还是挺菜的吧，但是感觉比之前有所进步了！</p><h4 id="①数据结构的学习"><a href="#①数据结构的学习" class="headerlink" title="①数据结构的学习"></a>①数据结构的学习</h4><p>这周主要学了一些数据结构，比如怎么用两个栈实现一个队列，链表的数组存取，链式存取，对于一颗树的BFS搜索的进行等。然后跟着做了三叶姐的很多“-+”题，我还记得就是那时候刷奇偶数的遍历的时候，虽然可能难度比当天每日一题的大吧，但是那个时候真的就看着看着就会了，虽然树这个数据结构还是没有去细学吧，骚年继续加油啊！</p><h4 id="②算法的学习"><a href="#②算法的学习" class="headerlink" title="②算法的学习"></a>②算法的学习</h4><p>这周对于算法应该大题来说有新也有旧，新的是学了一下<strong>树状的数组</strong>，但是线段树还没有去学，树状数组可能对于现在的我来说可能还没有特别的习惯，争取下次遇到题目的时候再多复习总结一下。然后就是旧的背包知识，之前对于一维背包知识的一个遍历顺序其实还是会有对应的存疑的，但是看了<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzU4NDE3MTEyMA==&scene=23&album_id=1751702161341628417&count=3#wechat_redirect">三叶姐这方面的总结</a>感觉对基础的背包有了比较深的印象了，当然看了一下状压dp，虽然看不懂呜呜，但是我相信以后会看得懂的哈哈哈！！</p><h3 id="三、课内任务"><a href="#三、课内任务" class="headerlink" title="三、课内任务"></a>三、课内任务</h3><h4 id="①c语言程序设计实验完成："><a href="#①c语言程序设计实验完成：" class="headerlink" title="①c语言程序设计实验完成："></a>①c语言程序设计实验完成：</h4><p>说真的这个实验花了蛮多的时间，其实还是因为自己太菜了，比如对于一些字符串连接，字符串寻找的函数使用非常的不熟悉，导致再重新学这一方面的时候花了蛮多额外的时间，就感觉基础没有大佬。在实验中遇到了很多的问题说真的，比如变量的重复定义，文件目录的创建等等，虽然最后通过各种询问解决了一些问题，但是我现在心里其实还是没有底的，毕竟很多东西查完之后，感觉我没有很彻底的了解到程序最底层的东西吧，希望后面能够在看c++prime的时候继续的巩固。</p><h4 id="②英语6级的复习："><a href="#②英语6级的复习：" class="headerlink" title="②英语6级的复习："></a>②英语6级的复习：</h4><p>其实按理来说我不应该说这个复习的事情的，因为我可能根本就没有复习。就好像6天有4天坚持了听了40min，还是因为自己听力太差了，所以拿听力的原文听了一遍又一遍，最终还是没能听出正确答案呜呜，然后有的时候就是本来说晚上做完事就听听力，然后一到十点多的时候，感觉一天好像学了不少东西，就玩玩手机，刷b站的视频，时间一晃而过，我的天，这周我感觉对时间的管理特别特别的差真的。</p><h3 id="四、一点决心"><a href="#四、一点决心" class="headerlink" title="四、一点决心"></a>四、一点决心</h3><p>其实之前在看星球的各位和我一样为了以后能够进一个好一点的大厂的人打卡和提问，这周印象最深的是北邮的一个同学吧，她现在大一，但是已经有了3个项目的参与，多个程序设计的奖项，然后每天会花5个小时在课内，5个小时在课外，而且已经刚刚通过了阿里的二面。说到这其实不是为了去把自己和这位大佬进行比较吧，但是当时看到的时候，真的感觉自己在时间管理方面，做得是真的挺差的。下周开始，我希望自己能够克服一些娱乐吧。就是先从小事做起，做到一天以内至少8个小时心思是完全在学习上的，而不是说，写完一题就看会微信聊会天，看会书就看点b站什么的吧！我希望下周日的总结日记，写到我的改变！毕竟时间还多，只要想去改变，那么什么时候都不算晚！！！</p><h3 id="五、新球打卡"><a href="#五、新球打卡" class="headerlink" title="五、新球打卡"></a>五、新球打卡</h3><h4 id="①周一"><a href="#①周一" class="headerlink" title="①周一"></a>①周一</h4><p>leetcode每日一题<br>大概懂了树状数组，并且自己实现了一遍</p><p>c++prime越看越看不懂了，特别看到类那一块，星球的uu们能给点建议吗？感觉看那个都有点劝退了。</p><p>操作系统看了线程</p><h4 id="②周二"><a href="#②周二" class="headerlink" title="②周二"></a>②周二</h4><p>英语六级听力40min，好像现在听力有点感觉了</p><p>力扣每日一题照常，开始刷数据结构的leetbook了，刷了3题今天</p><p>写了一篇树状数组的博客，下面有csdn关于这篇博客的网址，uu们可以看看，虽然我写得比较水</p><p>计算机操作系统看了三个调度算法（FCFS,SJF,HRRN），感觉还是比较有趣的</p><p>c++prime水完了第七章，类那一块真的有点不太懂，但是大概懂了点构造函数那一块，包括链表内部那个构造函数，知道怎么记忆了。</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/123967025?spm=1001.2014.3001.5501">树状数组初学_sheep.ice的博客-CSDN博客</a> </p><h4 id="③周三"><a href="#③周三" class="headerlink" title="③周三"></a>③周三</h4><p>课内为主，上了一天课，补了补作业<br>力扣那题图论想不出好办法 明天进攻图论我说的<br>居然就没了哈哈哈哈</p><h4 id="④周四"><a href="#④周四" class="headerlink" title="④周四"></a>④周四</h4><p>被学校的数据文件实验继续折磨<br>开始看《算法竞赛入门》，对各种迭代器的使用又加深了一点<br>力扣照常每日一题<br>英语30min</p><h4 id="⑤周五"><a href="#⑤周五" class="headerlink" title="⑤周五"></a>⑤周五</h4><p>c++prime第八章<br>英语40min<br>两道bfs树的遍历<br>看了下竞赛入门经典一些数据结构</p><h4 id="⑥周六"><a href="#⑥周六" class="headerlink" title="⑥周六"></a>⑥周六</h4><p>终于搞完学校c语言设计的一个实验 写完了实验报告<br>每日一题（简单题）<br>看了三叶姐背包问题看了7章 对背包理解更深了<br>写了3h课内的东西<br>英语今天没看呜呜</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>树状数组初探</title>
    <link href="https://sample.com/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/"/>
    <id>https://sample.com/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-05T04:46:11.000Z</published>
    <updated>2022-04-14T10:15:29.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、树状数组的初学"><a href="#一、树状数组的初学" class="headerlink" title="一、树状数组的初学"></a>一、树状数组的初学</h1><p>之前学习过前缀和和差分的一些知识就觉得挺神奇的，然后昨天刷到力扣的每日一题之后发现，好像&#x3D;&#x3D;树状数组&#x3D;&#x3D;在多区间的修改和查询方面很神奇，包括之后要学习的&#x3D;&#x3D;线段树&#x3D;&#x3D;（能解决所有树状数组的问题）可能会更加有收获吧。😁😁</p><hr><h1 id="二、一些小小的理解"><a href="#二、一些小小的理解" class="headerlink" title="二、一些小小的理解"></a>二、一些小小的理解</h1><h3 id="①lowbit的理解"><a href="#①lowbit的理解" class="headerlink" title="①lowbit的理解"></a>①lowbit的理解</h3><p>在线段数组里面有这么一个重要的函数，也是能够构造整个树状数组的<font color="red">核心</font>吧！代码只有一行，但是对于我这种萌新来说，刚开始还是很难理解的。代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">//寻找一个数最低位的1int lowbit(int x) &#123;        return x & -x;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个比较简单的例子，一个数为3，他的二进制表示为11，那么根据负数二进制的要求，-3的二进制，我们先求他的反码为00，最后+1得到补码为01，最后让11 &amp; 01 便取得 01，也就是最低位的第一个1，<strong>大家可以试一下，利用这个函数，最后得到的结果一定只会含有一个1在整个数里面</strong>;</p><hr><h1 id="三、树状数组的构建"><a href="#三、树状数组的构建" class="headerlink" title="三、树状数组的构建"></a>三、树状数组的构建</h1><p><img src="https://img-blog.csdnimg.cn/00946e0b43e9458e843fd7c0b90696d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树状数组"><br>大家可以看到，树状数组首先对应一个s数组（假设有8个元素），也就是一个求总和的数组，这个数组里面对应装下一些前缀和，而每一个s对应数都是连续的，这也就为我们后面提供区间和利用<strong>前缀和</strong>的思想提供了很好的办法！<br>&#x3D;&#x3D;当然这里有要注意的点：&#x3D;&#x3D; 就是我们的s数组必须从1作为下标开始，也就是8个元素我们要开s[9]的空间，因为lowbit(0)是不存在最低位1的会造成<strong>无限循环</strong>的风险。大家可能不太理解，这个数组里面为什么能够按照这样的数字进行相加，我们看下面的图：<br><img src="https://img-blog.csdnimg.cn/5c68b3ed52e0422f9a8dde06069d7c9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="二进制表示"><br>从上面的图，我们可以知道，每个s对应的下标，都是从某个下标i，通过加上lowbit(i),并且在每次演变的时候，让$S_i$加上对应的num[i - 1] 的数(因为num数中的下标是从0开始的)，最后就变成了第一张图的样子，也就是接下来要讲的区间的更新。</p><hr><h1 id="四、区间的查询以及更新"><a href="#四、区间的查询以及更新" class="headerlink" title="四、区间的查询以及更新"></a>四、区间的查询以及更新</h1><h3 id="①区间的更新："><a href="#①区间的更新：" class="headerlink" title="①区间的更新："></a>①区间的更新：</h3><p>因为有了上面的铺垫，我们直接放上，s数组更新的一个代码，也就是如何让s数组存上对应相关的值。</p><pre class="line-numbers language-c++"><code class="language-c++">//添加和到对应的树状数组    void add(int x, int val) &#123;        for(int i = x; i <= n; i += lowbit(i)) &#123;            sum[i] +=  val;   //这里的val其实就是num[i - 1];        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过上面的操作之后，我们就<font color="green">完成了s数组的构建</font>，那么如果题目要求，改掉num数组里面的某个数的话，我们只需要让那个数所在的s也同时的更新就好，像下面一样:</p><pre class="line-numbers language-c++"><code class="language-c++">void update(int index, int val) &#123;        //这里的index要+1，因为num数组的下标从0开始        add(index + 1, val - nums[index]);        nums[index] = val;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②区间的查询"><a href="#②区间的查询" class="headerlink" title="②区间的查询"></a>②区间的查询</h3><p>区间的查询，其实有点像更新的逆过程，比如我们要知道$\sum_{i&#x3D;0}^{6}num[i]$的总和也就是说如何要求出$ S_7 +  S_6  + S_4 $的值（这里大家可以对照一下上面的图）。<strong>7 - 6 - 4 不就是 111 - 110 - 100</strong>的过程吗？那其实就是每次让下标为i的数减去lowbit(i)，<font color="red">然后在此过程中去加上S[i]的值，最后就可以得到原始下标为index的前缀和了，根据区间前缀和计算的方式，最终就可以知道一段区间的和了。</font></p><pre class="line-numbers language-c++"><code class="language-c++">//计算从下标0- x-1的前缀和int query(int x) &#123;        int s = 0;        for(int i = x; i > 0; i -= lowbit(i)) &#123;            s += sum[i];        &#125;        return s;    &#125;//计算区间的和(不了解前缀和的同学可以先了解一下前缀和)int sumRange(int left, int right) &#123;        //因为原始的下标从0开始，那么对应区间和的下标要加1        return query(right + 1) - query(left);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="五、力扣的原题"><a href="#五、力扣的原题" class="headerlink" title="五、力扣的原题"></a>五、力扣的原题</h1><h3 id="①原题贴图"><a href="#①原题贴图" class="headerlink" title="①原题贴图"></a>①原题贴图</h3><p><img src="https://img-blog.csdnimg.cn/48adae96d9104c9c9c868b5332bb8eb0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树状数组模板题"></p><h3 id="②AC的代码全贴"><a href="#②AC的代码全贴" class="headerlink" title="②AC的代码全贴"></a>②AC的代码全贴</h3><pre class="line-numbers language-c++"><code class="language-c++">class NumArray &#123;public:    vector<int> sum;    //记录最低位的1    int lowbit(int x) &#123;        return x & -x;    &#125;    //添加和到对应的树状数组    void add(int x, int val) &#123;        for(int i = x; i <= n; i += lowbit(i)) &#123;            sum[i] +=  val;        &#125;    &#125;    int query(int x) &#123;        int s = 0;        for(int i = x; i > 0; i -= lowbit(i)) &#123;            s += sum[i];        &#125;        return s;    &#125;    vector<int> nums;    int n;    NumArray(vector<int>& nums) &#123;        this->nums = nums;        n = nums.size();        sum.resize(n + 1, 0);        for(int i = 0; i < n; i++) &#123;            add(i + 1, nums[i]);        &#125;    &#125;        void update(int index, int val) &#123;        add(index + 1, val - nums[index]);        nums[index] = val;    &#125;        int sumRange(int left, int right) &#123;        return query(right + 1) - query(left);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="六、-参考文档"><a href="#六、-参考文档" class="headerlink" title="六、 参考文档"></a>六、 参考文档</h1><p><a href="https://blog.csdn.net/bestsort/article/details/80796531">参考1 树状数组的详细教程</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/">参考2 力扣胡歌的题解</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">参考3 力扣三叶姐的题解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、树状数组的初学&quot;&gt;&lt;a href=&quot;#一、树状数组的初学&quot; class=&quot;headerlink&quot; title=&quot;一、树状数组的初学&quot;&gt;&lt;/a&gt;一、树状数组的初学&lt;/h1&gt;&lt;p&gt;之前学习过前缀和和差分的一些知识就觉得挺神奇的，然后昨天刷到力扣的每日一题之后发现，</summary>
      
    
    
    
    <category term="模板" scheme="https://sample.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="树状数组" scheme="https://sample.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="模板" scheme="https://sample.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>周总结(2)</title>
    <link href="https://sample.com/2022/04/03/%E5%91%A8%E6%80%BB%E7%BB%93-2/"/>
    <id>https://sample.com/2022/04/03/%E5%91%A8%E6%80%BB%E7%BB%93-2/</id>
    <published>2022-04-03T12:28:55.000Z</published>
    <updated>2022-04-03T13:59:23.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><hr><h3 id="二、leetbook的完结"><a href="#二、leetbook的完结" class="headerlink" title="二、leetbook的完结"></a>二、leetbook的完结</h3><p>算是看完了的第一本leetbook吧，还是很支持三叶姐的。看完这本书的最大感受就是对动态规划有了更加深刻的一个理解吧，准备下周开始看三叶姐的背包问题的总结了。希望能够变得越来越强吧！</p><p>极力推荐**<a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/rt49s5/">三叶姐的第一本leetbook</a>**！！</p><p><img src="https://img-blog.csdnimg.cn/a2ca59a49a0c4c39a46d978111403d41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h3 id="三、知识星球的打卡"><a href="#三、知识星球的打卡" class="headerlink" title="三、知识星球的打卡"></a>三、知识星球的打卡</h3><h5 id="①Day-5，周一"><a href="#①Day-5，周一" class="headerlink" title="①Day 5，周一"></a>①Day 5，周一</h5><p>平平无奇的一天，但又是重新启航的一天。早上的时候终于把博客初步搭建好了，然后啥事也没干。<br>中午的时候忘记调闹钟了，一觉睡到了3点多，然后起来开始刷力扣，这是第39天了，加油啊骚年。写完力扣的题目，做了三叶姐的拓展，写了篇博客<a href="https://sheepice.github.io/">https://sheepice.github.io/</a><br>大家可以看看<br>晚上就继续看c++prime，看了两个多小时，好像对c++的容器还有一些变量的设置有了一点眉目，希望这一周可以好好总结一下，发一篇新的博客<br>呆会手机锁机<br>我要开始复习六级啦！</p><h5 id="②Day6，周二"><a href="#②Day6，周二" class="headerlink" title="②Day6，周二"></a>②Day6，周二</h5><p>今天的力扣每日一题很可惜没能第一时间想出来，当知道是滑动窗口的一个模板题的时候，狠狠的觉得自己题目刷少了哈哈哈。当然还是写了一篇博客的：<a href="https://sheepice.github.io/%E2%80%8B%E2%80%8B">https://sheepice.github.io/​​</a></p><p>早上起来听了六级听力，我从来没有发现英语那么难学啊呜呜。</p><p>下午的时候把c++prime的第四章看完了。</p><p>哦对了，早上的时候，我看了操作系统看了差不多1个多小时的视频，刚开始还觉得这样的课程比较无聊，但是王道那个老师举的例子真的好好玩啊哈哈哈！</p><p>晚上的话就是自己的姨妈生日，翘了一节计算机思维课去帮她过生日，不过好像那一节课讲完了好多c++的东西[流泪]。不过我也是好好的展现了一波社交能力[呲牙]</p><p>回来的时候觉得今天好像一天都没干什么，就花了点时间看了一下数据结构和算法分析，对时间复杂度有了更深刻的理解。然后看到了那个最大子序列和用递归的写法，不得不说，递归这个东西神秘而又奇妙啊[呲牙]</p><p>待会再背背单词还有写写英语翻译，几天都没睡好了，争取今天能睡一个好好的觉[呲牙]</p><h5 id="③Day7-周三"><a href="#③Day7-周三" class="headerlink" title="③Day7 周三"></a>③Day7 周三</h5><p>今天发了一篇生活的博客，有兴趣的uu们可以去看看sheepice的博客​​</p><p>c++prime看了第六章还差一点</p><p>每日一题摆烂，有思路但是对数据结构不太熟悉啊，不太知道怎么用优先队列</p><p>英语听力40min 待会还会背单词</p><p>操作系统看完第一章</p><p>今天好摆啊<img src="file:///C:\Users\0604520\AppData\Roaming\Tencent\QQTempSys\CE_6{RQP]3{T@BAJGTH{IW4.png" alt="img"></p><h5 id="④Day8-周四"><a href="#④Day8-周四" class="headerlink" title="④Day8 周四"></a>④Day8 周四</h5><p>英语听力40min，总共25错7，继续努力<br>lc三月打卡目标完成<br>三叶姐的最短路径和2（困难），记录最小和第二小元素<br>c++prime第六章扫完<br>数据结构看了点列表，那本书有点难，打算开leetbook结合一下<br>操作系统看了进程：了解了一些进程组织，进程状态和进程转换的知识，包括对操作系统内核的原语有了初步印象<br>大物第五章习题刷完，大物慕课刷完</p><h5 id="⑤Day9-周五"><a href="#⑤Day9-周五" class="headerlink" title="⑤Day9 周五"></a>⑤Day9 周五</h5><p>每日一题，写了篇博客<a href="https://sheepice.github.io/%E2%80%8B%E2%80%8B">https://sheepice.github.io/​​</a></p><p>最短路径二hard题目，记忆化搜索</p><p>栈和队列的实现，链表的索引实现<br>今天想休息会，待会和朋友打游戏去了</p><h5 id="⑥Day10-周六"><a href="#⑥Day10-周六" class="headerlink" title="⑥Day10 周六"></a>⑥Day10 周六</h5><p>被电工技术折磨住了<br>刷了一个记忆化搜索题<br>三叶姐的路径leetbook明天可以刷完<br>英语单词<br>摆烂休息</p><hr><h3 id="四、运动任务"><a href="#四、运动任务" class="headerlink" title="四、运动任务"></a>四、运动任务</h3><p>中规中矩吧，每天跑跑步，跳跳绳什么的，每天坚持一点运动还是很不错滴！</p><hr><h3 id="五、一点小倾诉"><a href="#五、一点小倾诉" class="headerlink" title="五、一点小倾诉"></a>五、一点小倾诉</h3><p>就今天不是一周的最后一天了嘛，其实从前天开始，就感觉到自己明显的有点不在状态了。就感觉有好多我自己说不清楚的压力在我的身上，无论是学业的还是生活上的，也不知道是不是因为太久没有和身边的人进行沟通了，太久没有和朋友们进行相聚了，内心老是感觉憋着无数的话说不出来，突然就觉得好像有些累了。不知道大家有没有这样一种情况，就是会突然那一下没有了动力，然后就感觉莫名其妙的空虚感，有的uu们可以来一起聊聊天哈！就其实一直想做一个很乐观很乐观的人，但是可能自己性格的缘故，越想着去说，想把一些开心或者自己想说的话说出去，但是就会有点想展示自己，就是我无比感受到这样的展现挺空虚的，我估计还是心灵在作祟吧！可恶的疫情啊，你什么时候能够对我们善良一点，我真的很想回到自己的学校，见到熟悉的朋友。到那时，也许望着天边的一片片云，都觉得很有味道吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题3</title>
    <link href="https://sample.com/2022/04/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%983/"/>
    <id>https://sample.com/2022/04/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%983/</id>
    <published>2022-04-01T03:42:11.000Z</published>
    <updated>2022-04-14T10:15:41.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h3 id="二、leetcode每日一题"><a href="#二、leetcode每日一题" class="headerlink" title="二、leetcode每日一题"></a>二、leetcode每日一题</h3><p>今天的每日一题难度不大，主要想记录一下关系哈希表的容器相关写法吧！</p><p><img src="https://img-blog.csdnimg.cn/3f3ea20f3f3246cb883ad941a49020dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h5 id="①思路："><a href="#①思路：" class="headerlink" title="①思路："></a>①思路：</h5><p>采用哈希表记录下来所有出现过的数和对应的次数，然后利用<strong>绝对值大小进行排序</strong>（这个排序可以方便我们对表进行一次遍历，只需要看arr[i]对应的arr[i] * 2的次数是不是比前者大，即满足前者能够充分的匹配后者，然后一旦不满足就return false就好了的。</p><hr><h5 id="②解答："><a href="#②解答：" class="headerlink" title="②解答："></a>②解答：</h5><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    bool canReorderDoubled(vector<int>& arr) &#123;         unordered_map<int, int> cnt;        for (int x : arr) &#123;            ++cnt[x];        &#125;        if (cnt[0] % 2) &#123;            return false;        &#125;        vector<int> vals;        vals.reserve(cnt.size());        for (auto &[x, y] : cnt) &#123;            vals.push_back(x);        &#125;        sort(vals.begin(), vals.end(), [](int a, int b) &#123; return abs(a) < abs(b); &#125;);        for (int x : vals) &#123;            if (cnt[2 * x] < cnt[x]) &#123; // 无法找到足够的 2x 与 x 配对                return false;            &#125;            cnt[2 * x] -= cnt[x];        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="③学到的东西"><a href="#③学到的东西" class="headerlink" title="③学到的东西"></a>③学到的东西</h5><pre class="line-numbers language-c++"><code class="language-c++">//应该都是容器的相关知识，但是我还没看到，就先记录一下1.    //将哈希表里面的第一个元素放到数组里面，    for (auto &[x, y] : cnt) &#123;            vals.push_back(x);        &#125;2.    //直接在sort里面进行比较函数的书写    sort(vals.begin(), vals.end(), [](int a, int b) &#123; return abs(a) < abs(b); &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、三叶姐的题解"><a href="#三、三叶姐的题解" class="headerlink" title="三、三叶姐的题解"></a>三、三叶姐的题解</h3><p>xxxxxxxxxx &#x2F;&#x2F;c++版本的解答class Solution {public:    int maxProduct(vector<string>&amp; words) {        int n &#x3D; words.size();        vector<int> dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) {            for(int j &#x3D; 0; j &lt; words[i].size(); j++) {                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - ‘a’));              }        }        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) {            for(int j &#x3D; i+1; j &lt; n; j++) {                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) {&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                }            }        }        return ans;    }};c++</int></string></p><p><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/">三叶姐的题解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>生活分享1</title>
    <link href="https://sample.com/2022/03/30/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB1/"/>
    <id>https://sample.com/2022/03/30/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB1/</id>
    <published>2022-03-30T11:42:24.000Z</published>
    <updated>2022-04-13T00:56:00.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p>一直认为生活不应该只有学业还有各种方面的压力，一定要有属于自己的诗和远方，开启生活篇的博客就是希望能够分享一下sheepice在生活里面遇到的很多很多事情吧！也相当于没有写技术博客的一个补充吧哈哈！</p><h3 id="二、《朋友请听好》"><a href="#二、《朋友请听好》" class="headerlink" title="二、《朋友请听好》"></a>二、《朋友请听好》</h3><p><img src="https://pics1.baidu.com/feed/d788d43f8794a4c2f670bf9a1b00dfdcac6e3929.jpeg?token=8b27736236d409e565c7c4c01d6aa0cd"></p><p>这是一档我很喜欢的综艺，说是一个综艺节目但是我更觉得它的意义在于一个情感上的慰藉港湾，在这里面有很多很多温暖的声音，有很多很多暖心的故事。当然在这里面我也收获了很多很多的慰藉！</p><h5 id="①“永远要相信世上的善意”"><a href="#①“永远要相信世上的善意”" class="headerlink" title="①“永远要相信世上的善意”"></a>①“永远要相信世上的善意”</h5><p>一位打电话来的女生，因为是自己一人在外打拼，所以自己就租了一个单间的房子，而有段时间她和邻居发生了争执。邻居住着一家，有着一个已经哑了的老奶奶，还有一个可爱的小孩。女生每次回家的时候，都会发现自己的家门口摆放着一双干净但又很破旧的皮鞋，因为是一个人，回家看到这样的情况，一定会有些恐惧的感觉。有一天，女生也没忍住，就去敲了邻居家的门，对着奶奶(情绪激动地)说到这样的事情，也许是因为太突然，女生觉得可能吓到老奶奶了，她看着老奶奶好像被吓得说不出话，因此也没有继续激动下去，而是提醒之后就走了。可是当天回来之后，那一双皮鞋依旧整整齐齐地摆放在自己家的门前，女生正无语的时候，看到鞋子里面有着一张小孩子写的纸条:”阿姨你好，我的奶奶她不能说话。我的爷爷走了，家里就剩下爷爷的这一双皮鞋，奶奶知道你是一个人住在这里，担心你的安全，所以把爷爷的皮鞋放在你的门口…….”</p><p><strong>我的描述可能不会太感动，但是当时听到最后的纸条内容的时候，我是真的一下也没有绷住，眼泪很自热而然地就流了下来。那时的我就突然觉得这个世界真的很好，真的很好，无论是最亲近的人还是陌生的人，他们也许无时无刻地在对你表示着善意，而请我们也要同样地对这个世界，对这个世界的每一个人保持善意！</strong></p><h5 id="②”你愿意和我建造一个图书馆吗？“"><a href="#②”你愿意和我建造一个图书馆吗？“" class="headerlink" title="②”你愿意和我建造一个图书馆吗？“"></a>②”你愿意和我建造一个图书馆吗？“</h5><p>因为故事很长，所以希望看到此篇博客的uu们可以到<a href="https://b23.tv/qzMpMH7">朋友请听好</a>这里去看！我深深被女生最后的英文誓词感动了，不知道是不是一时兴起，但是我觉得英文得好好学：</p><ul><li><p>英文誓词</p><ul><li><p>For the first, I love you deeply and passionately that I have felt for no one else in this life.</p></li><li><p>You said “早上好” this morning with your awkward Chinese. And I thought I can’t imagine myself love you more than I do today. But I thought the same way yesterday.</p></li><li><p>And if it astonished you, it almost frightened me as well.</p></li><li><p>It’s just. I was not such an fool even once hoped. Aspired, dreamed that one could find everything one want in a person.</p></li><li><p>And yet in you, I found everything.</p><p>…….</p></li></ul></li></ul><p><strong>读至此，我渴望着自己也能够变得更加的温柔，善良等等，因为一生的遇见，遇见的所有人，还有你，是多么多么的不容易啊。就像最后唱到的《慢慢喜欢你》,歌曲温柔，听着听着，就幻想到了后面的一生。</strong></p><h3 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h3><p>虽然当下的人包括自己真的在很多很多时候，想要快一点，再快一点。也许是快一点找到喜欢的一份工作，也许是快一点找到自己喜欢的人，可是殊不知，美好是一直在身边的。走得越快，真的能够抓住吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h3&gt;&lt;p&gt;一直认为生活不应该只有学业还有各种方面的压力，一定要有属于自己的诗和远方，开启生活篇的博客就是希望能够分享一</summary>
      
    
    
    
    <category term="生活篇" scheme="https://sample.com/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/"/>
    
    
    <category term="生活" scheme="https://sample.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题2</title>
    <link href="https://sample.com/2022/03/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%982/"/>
    <id>https://sample.com/2022/03/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%982/</id>
    <published>2022-03-29T05:47:02.000Z</published>
    <updated>2022-04-14T10:18:13.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><hr><h3 id="二、leetcode每日一题"><a href="#二、leetcode每日一题" class="headerlink" title="二、leetcode每日一题"></a>二、leetcode每日一题</h3><p><img src="https://img-blog.csdnimg.cn/39df104b32574cbbac56a8e175e46cc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="滑动窗口题目"></p><p>说实话，这一题在刚开始用双指针的时候，是有些地方没有想明白的，比如当最后的右指针移动到某个位置把k次数用完后，左指针应该移动到哪个位置，所以开始死磕了好久，最后也是积累了这样一种滑动窗口的办法吧。其实就是不要等右指针移到位才开始计算结果，边移动的时候就可以开始计算了，利用维护一个sum值，当sum依然小于k的时候，右指针就可以一直往后面移动，sum也一直++，知道他大于k的那一刻，我们的left就需要移动到他等于k的地方。那么这一题和后面要-+(三叶姐的简单题加餐)的题目是几乎一样的，只不过这题是需要计算最多有多少个“F”和“T”最后取两者的最大值就是答案啦！</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string s;    int jl;    int maxConsecutiveAnswers(string answerKey, int k) &#123;        s = answerKey;        jl = k;        int ans = 0;        ans = max(getmax('T'), getmax('F'));        return ans;    &#125;    int getmax(char ss) &#123;        int n = s.size();        int sum = 0;        int as = 0;        for(int i = 0, j = 0; j < n; j++) &#123;            //不等于ss时，翻牌操作++；            sum += (s[j] != ss);            //翻牌的操作已经用空了            while(sum > jl) &#123;                sum -= (s[i] != ss);                i++;            &#125;            //边走边记录下来答案            as = max(as, j - i + 1);        &#125;        return as;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、-套餐（简单题加餐）"><a href="#三、-套餐（简单题加餐）" class="headerlink" title="三、-+套餐（简单题加餐）"></a>三、-+套餐（简单题加餐）</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486241&idx=1&sn=609ca05e6e21a72023172b52d0af0a75&chksm=fd9ca03ecaeb2928018ef5b2faf20b170ae123813eec30962d2ea2d3c93e78e54ddde0d51c87&cur_album_id=1805384400772087811&scene=189#wechat_redirect">最大连续1的个数</a></p><p>上方来自三叶姐的题解，里面涉及到dp做法；二分加前缀和；还有今天的滑动窗口，非常的厉害！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题1</title>
    <link href="https://sample.com/2022/03/28/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%981/"/>
    <id>https://sample.com/2022/03/28/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%981/</id>
    <published>2022-03-28T08:37:29.000Z</published>
    <updated>2022-03-28T09:19:54.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><hr><h3 id="二、leecode每日一题"><a href="#二、leecode每日一题" class="headerlink" title="二、leecode每日一题"></a>二、leecode每日一题</h3><h5 id="①首先是今天的每日一题，题目如下："><a href="#①首先是今天的每日一题，题目如下：" class="headerlink" title="①首先是今天的每日一题，题目如下："></a>①首先是今天的每日一题，题目如下：</h5><p><img src="https://img-blog.csdnimg.cn/69c46960dcf04186a11aab308856d966.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="交替二进制"></p><h5 id="②题目解答（1）"><a href="#②题目解答（1）" class="headerlink" title="②题目解答（1）"></a>②题目解答（1）</h5><pre class="line-numbers language-c++"><code class="language-c++">//版本1，逐步的进行判断class Solution &#123;public:    bool hasAlternatingBits(int n) &#123;        int prev = 100;  //因为二进制每一位不可能超过2，所以prev比2大就好        while (n != 0) &#123;            int cur = n & 1;    //当前判断的位数            if (cur == prev) &#123;  //如果与上一位相等就不满足                return false;            &#125;            prev = cur;         //前缀等于当前，进行下一次的判断            n >>= 1;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="③题目解答（2）"><a href="#③题目解答（2）" class="headerlink" title="③题目解答（2）"></a>③题目解答（2）</h5><p>因为位运算的性质，所以这题其实可以几行代码就解决的。例如一个二进制数为101，如何判断他是交替的呢。首先令u&#x3D;101，然后u &gt;&gt; 1是等于010的，这一步可以看成让一个本来是101交替的，变成010交替，那么u^(u&gt;&gt;1)等于111，也就是说对于交替进行的数字，必然有其本身抑或本身右移一位后得到的结果位数全部为1!!</p><pre class="line-numbers language-c++"><code class="language-c++">//版本二：利用位运算的相关性质class Solution &#123;public:    bool hasAlternatingBits(int n) &#123;        long a = n ^ (n >> 1);        //a加1后如果为真，111变成1000与原数按位与必然为0        return (a & (a+1)) == 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、三叶姐的拓展"><a href="#三、三叶姐的拓展" class="headerlink" title="三、三叶姐的拓展"></a>三、三叶姐的拓展</h3><p>这一题之后三叶姐给了一个位运算的入门专题，也是状态压缩的一个入门题目：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490530&idx=1&sn=f53d29ff37a37b41408a83e10bff0ee6&chksm=fd9cb0fdcaeb39eb014629bce596c667600ad22791f5c4e50307da0090c8777caaefadf85948&mpshare=1&scene=23&srcid=0328BdmtGDal2kCsgWYe74cB&sharer_sharetime=1648433142477&sharer_shareid=700066f28b945e5d1cd5d3f0173f1539#rd">【位运算专题】经典「状态压缩 + 位运算」入门题</a></p><h5 id="①题目如下："><a href="#①题目如下：" class="headerlink" title="①题目如下："></a>①题目如下：</h5><p><img src="https://img-blog.csdnimg.cn/45a0dd6be54f4da8946facbd537559b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="状态压缩入门"></p><h5 id="②解答如下"><a href="#②解答如下" class="headerlink" title="②解答如下"></a>②解答如下</h5><p>因为数据给的比较小，然后要判断的只是小写字母，因此只需要把每一个单词小写字母出现的情况放在一个二进制数下进行表示就好了的！</p><pre class="line-numbers language-c++"><code class="language-c++">//c++版本的解答class Solution &#123;public:    int maxProduct(vector<string>& words) &#123;        int n = words.size();        vector<int> dp(n,0);        for(int i = 0; i < n; i++) &#123;            for(int j = 0; j < words[i].size(); j++) &#123;                char u = words[i][j];                //进行每一位1的存储                dp[i] |= (1 << (u - 'a'));              &#125;        &#125;        int ans = 0;        //从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i = 0; i < n - 1; i++) &#123;            for(int j = i+1; j < n; j++) &#123;                if((dp[i] & dp[j]) == 0) &#123;//这里取最大值的地方可以注意一下//可以用ans = max(ans, (int)(words[i].size() * words[j].size()));//因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() > ans)                    ans = words[i].size() * words[j].size();                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三</summary>
      
    
    
    
    <category term="力扣刷题篇" scheme="https://sample.com/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AF%87/"/>
    
    
    <category term="刷题" scheme="https://sample.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="力扣" scheme="https://sample.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>周总结（1）</title>
    <link href="https://sample.com/2022/03/27/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
    <id>https://sample.com/2022/03/27/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/</id>
    <published>2022-03-27T10:44:33.000Z</published>
    <updated>2022-03-28T04:14:18.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到&#x3D;&#x3D;一周一总结&#x3D;&#x3D;的栏目！！希望能够和大家一起努力！</p><h3 id="二、学习任务"><a href="#二、学习任务" class="headerlink" title="二、学习任务"></a>二、学习任务</h3><h5 id="①力扣的刷题任务"><a href="#①力扣的刷题任务" class="headerlink" title="①力扣的刷题任务"></a>①力扣的刷题任务</h5><p>这周的力扣好像都没有出太难的题目，唯一令我印象比较深刻的是一道困难题<a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">字典序的第k小的数字</a>，这个题目的模仿了字典树的一个遍历过程，当时真的没有想到，但是其实还是有点眉目的，虽然最后还是没写出来吧。遗憾的是，自己还是没有把字典树给学精通来！</p><p><img src="https://img-blog.csdnimg.cn/b15450e05169480fbb75e160274b782a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><pre class="line-numbers language-c++"><code class="language-c++">//贴一下这个题目的一个求解过程吧class Solution &#123;public:    long min(long a, long b)&#123;        if(a >= b) return b;        return a;    &#125;    //找到此时的数字的所有树节点的个数    int findnums(long cur,int n)&#123;        long next = cur+1;        long sumtox = 0;        while(cur <= n)&#123;            sumtox += min(next-cur,n-cur+1);            next *= 10;            cur *= 10;        &#125;        return (int) sumtox;    &#125;    int findKthNumber(int n, int k) &#123;        long cur = 1;        k--;        while(k > 0)&#123;            int nodes = findnums(cur, n);            //如果结点数小于此时数量，直接在同一层搜索            if(k >= nodes)&#123;                k -= nodes;                cur++;            &#125;            //否则到树的下一层搜索            else&#123;                cur *= 10;                k--;            &#125;        &#125;        return (int)cur;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;当时反正是想不出来的，希望以后看到总结的时候能够写出来这题吧！&#x3D;&#x3D;</p><p><strong>过完本周就是坚持力扣刷题38天了，当然这个连续刷题是有水分的，有的时候遇到完全没有思路的题目就直接跳过去了，蒟蒻太菜，求大佬们带带！</strong></p><hr><h5 id="②leetbook的学习"><a href="#②leetbook的学习" class="headerlink" title="②leetbook的学习"></a>②leetbook的学习</h5><p>本周还跟着三叶姐出的书，学了一点路径dp的知识，虽然在其中有很多以前写过的题目，但是再次刷题的时候还是会遇到各种各样的问题，当然收获最大的是，自己得到了某些方面的拓展，关于这一周的一个拓展，我也写在了我的CSDN博客里面，便于以后的查找：<a href="https://blog.csdn.net/qq_60556896/article/details/123754413?spm=1001.2014.3001.5502">最短路径拓展</a>！！</p><p>下面也是三叶姐的书，感兴趣的同学可以点这：<a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/r8h07j/">dp路径学习</a></p><p><img src="https://img-blog.csdnimg.cn/56991cd79f994e238c58468699a18170.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h5 id="③课内的学习"><a href="#③课内的学习" class="headerlink" title="③课内的学习"></a>③课内的学习</h5><p>课内其实这周就中规中矩吧，但是因为自己比较的笨，所以会花更多时间去把老师没有布置的题目写完，比如大物第二和第四章的课后习题都刷了一遍，等等。然后就是本来这周想要去开始六级的准备了，但是本人准备了个寂寞，每天都不太想背单词，听听力，我希望赶紧能够养成每天复习点英语的习惯，希望下一次的周记能够写到我英语有一直在复习哈哈哈！！</p><hr><h5 id="④博客的搭建"><a href="#④博客的搭建" class="headerlink" title="④博客的搭建"></a>④博客的搭建</h5><p>虽然自己对网页的方方面面都不知晓，但是为了让自己的博客目前看起来像点样子，还是抽出了周日的一天时间去美化自己的博客吧，就像大家看到的这个亚子，虽然还有些功能没有完善，但是我真的不太会怎么完善了，希望会的uu们可以交一下子我！</p><hr><h3 id="三、运动任务"><a href="#三、运动任务" class="headerlink" title="三、运动任务"></a>三、运动任务</h3><p>这周前几天比较冷还下雨，所以鸽了几天运动，但是后面有每天都去跑步和跳绳哦，我记得这周虽然没有减肥太多，但是体重保持得相当不错。还记得跳绳的时候，跳双摇，旁边的小弟弟召集了他的伙伴到身边围观，哈哈哈哈哈哈哈哈哈哈哈，当时的我真的会有点羞涩的！！</p><h3 id="四、创新任务"><a href="#四、创新任务" class="headerlink" title="四、创新任务"></a>四、创新任务</h3><h5 id="①加入了Carl哥的知识星球："><a href="#①加入了Carl哥的知识星球：" class="headerlink" title="①加入了Carl哥的知识星球："></a>①加入了Carl哥的知识星球：</h5><p>感兴趣的同学可以一起加入哦，曾听一位学姐说，与其花钱在各种不必须的物品之上，不如多知识付费去提高自己的能力！！加入星球后我发现了很多小伙伴有着跟自己相同的困惑，Carl哥非常好的，就是他会给每一个人进行解答，包括传授各种各样的知识和学习路线，值得大家入手！！</p><p><strong>下面是我得到的回答，收获很丰富</strong></p><p><img src="https://img-blog.csdnimg.cn/443ee98d271e4f50ade1640f701b0723.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="②加了Carl哥还有三叶姐的微信"><a href="#②加了Carl哥还有三叶姐的微信" class="headerlink" title="②加了Carl哥还有三叶姐的微信"></a>②加了Carl哥还有三叶姐的微信</h5><p>&#x3D;&#x3D;虽然可能就是刚开始互相不认识的人，但是总是觉得已经认识了好久哈哈&#x3D;&#x3D;</p><hr><h3 id="五、总结-贴图"><a href="#五、总结-贴图" class="headerlink" title="五、总结+贴图"></a>五、总结+贴图</h3><p>一周下来真的很累很累，但是其实过得真的非常的充实，希望自己接下来可以不嫌麻烦的，继续坚持的做自己喜欢的事情，就像一直保持热爱的她！</p><p><img src="https://img-blog.csdnimg.cn/09100c5cafb848b4b0dc0220a6882b81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;sheepice的CSDN博客地址：&lt;a href=&quot;https://blog.csdn.net/qq_60556896/&quot;</summary>
      
    
    
    
    <category term="周总结" scheme="https://sample.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="周总结" scheme="https://sample.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
