<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论之Kruskal</title>
      <link href="/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BKruskal/"/>
      <url>/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BKruskal/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于最小生成树的问题来说的话，我们可以发现如果直接利用我们的dijkstra算法，每次去遍历一个点，然后通过一个点的话去更新其他的所有边，在这样的过程中，换一个理解的方式来看的话，不过就是把我们所有的最短的边连起来，也就是，我们尝试将所有有关系的点通过最短的概念，连接起来，然后能够通过这样的方式，在集合内部已经连好的点，就不会在继续连，也就是我们一旦选定两个点进行边的连接的话，我们一定会选最短的，然后最后我们判断一下是否所有的点到最后会被连接到一个集合之中就好了。有了这个思路，我们其实就可以利用今天所讲到的Kruskal算法进行最短边的尝试，知道我们能够去让所有点入集合。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①Kruskal算法模板-ACwing-859"><a href="#①Kruskal算法模板-ACwing-859" class="headerlink" title="①Kruskal算法模板(ACwing.859)"></a>①Kruskal算法模板(ACwing.859)</h3><p><img src="https://img-blog.csdnimg.cn/643f49b0432a4eb7be8dd34de80e15f1.png" alt="Kruskal最小生成树"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度:</code>  $O(mlogn)$</p><p><code>适用场景:</code>  点数和边数都比较多的最小生成树的问题，应用面广于之前所说的Prim算法。</p><p><code>思路: </code>  将所有的边进行排序，贪心的从最短的边开始遍历，一旦发现我们遍历的那个边能够加到我们的集合中的话，我们就可以加到我们的集合当中去的话就加入。那么判断这个边是否能够加入我们之前的集合当中去，无非就是看一下这个边加入集合后，会不会破坏我们的生成树的条件，而我们知道，一棵树只有一个根节点，我们只要满足每次加入的时候保证根节点只有一个就好了，这里就可以用并查集进行优化，最后我们只要判断一下是否所有边的数量为n - 1就好了！</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 1e5 + 5, M &#x3D; 2 * N + 10;&#x2F;&#x2F;因为是遍历所有的边，用结构体装一下就好了struct Edge &#123;    &#x2F;&#x2F;代表a, b有一条权值为c的边    int a, b, c;    &#x2F;&#x2F;为了按照边从小到大排序的话，需要重载一下小于号    &#x2F;&#x2F;这里的写法主要是学比如写的，具体其实两个const和一个&amp;不要也可以的    bool operator&lt; (const Edge&amp; W) const &#123;        return c &lt; W.c;    &#125;&#125;edges[M];&#x2F;&#x2F;并查集的pre数组int pre[N];&#x2F;&#x2F;并查集加路径压缩的函数写法int find(int x) &#123;    if(x !&#x3D; pre[x]) pre[x] &#x3D; find(pre[x]);    return pre[x];&#125;int main() &#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    &#x2F;&#x2F;初始化一下我们的并查集的点    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) pre[i] &#x3D; i;        for(int i &#x3D; 0; i &lt; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        edges[i] &#x3D; &#123;a, b, c&#125;;    &#125;        sort(edges, edges + m);    &#x2F;&#x2F;记录加的边,和最终的结果    int cnt &#x3D; 0, ans &#x3D; 0;    &#x2F;&#x2F;遍历一下所有的边    for(int i &#x3D; 0; i &lt; m; i ++ ) &#123;        auto t &#x3D; edges[i];        int f1 &#x3D; find(t.a), f2 &#x3D; find(t.b);                if(f1 !&#x3D; f2) &#123;            &#x2F;&#x2F;可以把边加入             cnt++;            &#x2F;&#x2F;把两个不相连的集合连起来            pre[f1] &#x3D; f2;            ans +&#x3D; t.c;            if(cnt &#x3D;&#x3D; n - 1) break;        &#125;    &#125;        if(cnt !&#x3D; n - 1) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; ans &lt;&lt; endl;        &#x2F;&#x2F; cout &lt;&lt; cnt &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②未完待续"><a href="#②未完待续" class="headerlink" title="②未完待续"></a>②未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> 图论专题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之Prim</title>
      <link href="/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BPrim/"/>
      <url>/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BPrim/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>此篇主要针对图论中的求最小生成树的一种算法Prim算法，这个算法其实整体的结构和dijkstra算法是相似的，所以整体的思路也和dijkstra算法有异曲同工之妙。首先，讲一下自己对最小生成树这个概念的理解。</p><p><code>生成树:</code> 包含图中所有结点，且整个结点形成的一张图中不含有任何环，一旦再多连接两个结点形成一条边，一定会生成一个环的一个结构图。</p><p><code>最小生成树:</code>  在一个图中找到的所有生成树中，所有边加起来的权值最小的那一棵生成树是一颗最小生成树。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①Prim算法模板-ACwing-858"><a href="#①Prim算法模板-ACwing-858" class="headerlink" title="①Prim算法模板(ACwing.858)"></a>①Prim算法模板(ACwing.858)</h3><p><img src="https://img-blog.csdnimg.cn/26e9b03e0c97421a80f76f2559a2a883.png" alt="Prim求最小生成树"></p><p><code>时间复杂度:</code>  $O(n^2)$</p><p><code>适用场景:</code>  点数少，边数多的最小生成树求解。</p><p><code>思路:</code>  和dijkstra算法结构差不多，但是此时定义的dist数组指的是，此时计算的某个点，到我们此时求到的生成树整个集合中的一个最小值距离。也就是说我们在推导dist数组的时候，同样每次选取一个距离集合最短的那一条边进行一个延申，不断延申的时候求出某个点到整个已经求出的部分最小生成树的一个距离最小值。</p><p><code>更新过程:</code></p><p><img src="https://img-blog.csdnimg.cn/6d7826cd1056488fa903c9a04092b223.jpeg"></p><p><code>紫色</code> <font color="purple">当前利用的更新点</font></p><p><code>蓝色</code><font color="blue">当前更新完后，某个点距离整个集合的最小距离</font></p><p><code>红色</code><font color="red">两个结点边的长度</font></p><p>上图最终的最小生成树就为3！</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 505, INF &#x3D; 0x3f3f3f3f;int g[N][N], dist[N];bool st[N];int n, m;int prim() &#123;    int res &#x3D; 0;    dist[1] &#x3D; 0;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        int t &#x3D; -1;        &#x2F;&#x2F;寻找离集合最近的那一条边                for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t])) &#123;                t &#x3D; j;            &#125;        &#125;     &#x2F;&#x2F;如果dist[t] &#x3D; INF代表没有边连向集合，直接返回            if(dist[t] &#x3D;&#x3D; INF) return INF;        st[t] &#x3D; true;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            dist[j] &#x3D; min(dist[j], g[t][j]);        &#125;                res +&#x3D; dist[t];    &#125;        return res;&#125;int main() &#123;    memset(dist, 0x3f, sizeof(dist));    memset(st, 0, sizeof st);    memset(g, 0x3f, sizeof g);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        &#x2F;&#x2F;先去掉自环        &#x2F;&#x2F;注意这种都是无向图，所以两个边都需要赋值        if(a !&#x3D; b) g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b], c);    &#125;        int ans &#x3D; prim();        if(ans &#x3D;&#x3D; INF) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图论专题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之Floyd</title>
      <link href="/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd/"/>
      <url>/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在之前的图论算法中有说过基本都是从一个原点出发，然后定义其他点到原点的一个距离最小值。那假设这个原点都是不固定的，而题目刚好要求去求任意两个点之间的最小距离的话，那么这个时候暴力美学就非常凸显出其独有的重要性了。那么本章总结的Floyd算法，就是能够解决这样的问题。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①Floyd算法模板-ACwing-854"><a href="#①Floyd算法模板-ACwing-854" class="headerlink" title="①Floyd算法模板(ACwing.854)"></a>①Floyd算法模板(ACwing.854)</h3><p><img src="https://img-blog.csdnimg.cn/ce6634a7cd4f47aabbb5e8d03d15f85b.png" alt="Floyd求最短路"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度:</code>  $O(n^3)$</p><p><code>适用场景:</code>  当点的数量很少，而边的数量较多的稠密图，且题目要求求的是任意两点之间的最短距离的时候，就可以利用此算法进行求解。</p><p><code>思路:</code>  由于是稠密图，可以用邻接矩阵来存图，对于每个邻接矩阵，都是会有$g[a][b]$表示a到b的距离，那么一旦a到b之间这条路径有其他点k的话，那么就可以考虑用k这个点去尝试更新一下$g[a][b]$之间的距离，也就是:<br>$$<br>g[a][b] &#x3D; min(g[a][b], g[a][k] + g[k][b])<br>$$<br>这样的话，我们利用三层循环，内两层循环去循环a,b两个点，外一层循环，循环k这个点这样就可以不重不漏的列举每个路径的可能性，对于无边的边，初始化为正无穷，就可以实现更新了。</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int INF &#x3D; 1e9;const int N &#x3D; 205;int n, m, k;int grid[N][N];void floyd() &#123;    for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;                grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    &#x2F;&#x2F;初始化    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++) &#123;            if(i &#x3D;&#x3D; j) grid[i][j] &#x3D; 0;            else grid[i][j] &#x3D; INF;        &#125;    &#125;        for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;                grid[a][b] &#x3D; min(grid[a][b], c);    &#125;        floyd();        while(k -- ) &#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;                if(grid[x][y] &gt; INF &#x2F; 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;        else cout &lt;&lt; grid[x][y] &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p><font color="blue">循环的顺序能不能变？</font></p><p>在上面的代码，我们可以看到，循环的顺序是先循环k，再循坏i，j。也就如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void floyd() &#123;    for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;                grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果把k这一层放到最内层，如下的话可以吗？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void floyd() &#123;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;                grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案是不行的！</p><p>首先举个例子，假设有一组样例是这样的</p><blockquote><p>10 4 1</p><p>2 8 1</p><p>8 9 8</p><p>9 1 10</p><p>1 10 0</p><p>2 10</p></blockquote><p>上面的样例，显然从2到10的距离最短是19，但是如果按照第二种方式，最后得到的结果会是impossible的，为什么呢？<font color="red">从循环顺序来看，当我们要求$ g[2][10]$的时候就需要求$g[2][1]$,而在求$g[2][1]$的时候，我们发现$g[2][1]是通过g[2][9]和g[9][1]得到的 $，而如果循环把k放到内层，那么$g[2][9]$会在i&#x3D;2，j&#x3D;9的时候才能推出来，这样就导致$g[2][1]$不能顺利得到正确结果，也就是最后得不到一条2到10的最短距离。</font></p><p>其次我们应该用动态规划的思想去理解Floyd的算法。我们可以让这个算法的动态规划数组看成$f(k, i, j)$代表以前k个点为媒介的时候，从i到j这个点的最短距离。</p><p>利用dp分析的方法有下面这个图</p><p><img src="/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BFloyd/Users/0604520/AppData/Roaming/Typora/typora-user-images/image-20220730101206077.png"></p><p>动态规划转移方程如下:<br>$$<br>f[k][i][j] &#x3D; min(f[k - 1][i][j],f[k - 1][i][k] + f[k-1][k][j])<br>$$<br>也就是说，我们当前第k层的状态应该根据上一层已经推出的k-1层来进行运算，所以k这一层循环应当放在最外面。</p><p>而由于上一层推出来的一个数据本身就可以用来推导下一层，就和背包dp问题的感觉一样，就可以优化一层，利用滚动数组的感觉，变成二维的dp解法，也就是我们的解法一。</p><h3 id="②未完待续"><a href="#②未完待续" class="headerlink" title="②未完待续"></a>②未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> 图论专题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之spfa</title>
      <link href="/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8Bspfa/"/>
      <url>/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8Bspfa/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于之前有写到的Dijkstra算法，我们发现他只能用来计算边的权值为正的情况，这其实也就是为什么我们需要开一个st数组，对于一个已经被更新过的点来说，他一旦用于更新其他点的时候，我们就不需要再考虑再利用这个点再次更新其他的点。</p><p><font color="blue">但是呢，如果点之间的边是负值的时候，就必须去遍历一下所有的边，因为存在负值的时候，负数加正数是会把距离缩短的，所以呢就可以利用遍历所有边的办法去更新点到原点的距离。</font>这就需要用到后续要说的spfa算法，那么在讲这个算法之前，需要了解bellman-ford算法，会先利用这个算法进行一个引入。</p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①bellman-ford-ACwing-853"><a href="#①bellman-ford-ACwing-853" class="headerlink" title="①bellman-ford(ACwing.853)"></a>①bellman-ford(ACwing.853)</h3><p><img src="https://img-blog.csdnimg.cn/dbffd9a6fb0b44748a688cb55b6fdd9e.png" alt="边权受限制的最短路"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度：</code>  $O(mn)$</p><p><code>适用场景：</code>  这个算法可以看到，时间复杂度比较高，所以mn的值要落在$1e7-1e8$之间才能满足不超时，另外，由于这个算法，是从原点出发，外层循环多少次，内层就需要更新多少次边。这个实际含义就是，外层循环多少次，就代表：<font color="red">从原点出发了多少条边</font>，所以能够计算，走多少条边到终点的一个最短距离，<font color="red">注意这个最短距离并不一定是整个图看上去的最短，而是满足了走k条边的最短！</font></p><p><code>思路：</code>  如果题目规定走k条边，那么按照上述分析，外层循环k次代表走k条边的更新情况，内部循环，更新每一条边，一旦能够更新就更新，不能更新的话，距离保证不变。<font color="red">这里注意由于内层循环更新的是所有的边，所以是有可能发生应该只再原本的基础上衍生1条边，但是衍生出去了2条边。所以需要一个回溯的数组，保存一下上一次更新好的dist数组。而这个串联反应可以举个例子，如下：</font></p><p><img src="https://img-blog.csdnimg.cn/8148d0f1d76e4a7d95599783af89bef6.png"></p><p>假设这个图，如果我们的k只给1的话，那么从1-&gt;3的距离最短应该为3，而不是1+1&#x3D;2。假设我们在更新的时候，还是像之前dijkstra的更新方式，利用dist数组更新的话，那么在仅有的一次循环里面，1-&gt;2这条边的距离首先会被更新为1，那么在2-&gt;3这条边就会按照dist[2] &#x3D; 1的这个数组更新dist[3],让dist[3]变成2，那么就和我们最终得到的答案3就是不同的。</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 505, M &#x3D; 10050;&#x2F;&#x2F;因为要遍历所有边，所以结构体存图struct Edge &#123;    int a, b, c;&#125;edges[M];int dist[N], n, m, k;&#x2F;&#x2F;设置一个回溯的数组int backup[N];void bellman_ford() &#123;    dist[1] &#x3D; 0;        for(int i &#x3D; 1; i &lt;&#x3D; k; i ++ ) &#123;        &#x2F;&#x2F;先进行一个备份操作        memcpy(backup, dist, sizeof dist);                for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;            auto t &#x3D; edges[i];            &#x2F;&#x2F;就是这个地方，如果写成            &#x2F;&#x2F;dist[t.b] &gt; dist[t.a] + t.c的话            &#x2F;&#x2F;就会有可能出现串联反应            if(dist[t.b] &gt; backup[t.a] + t.c) &#123;                dist[t.b] &#x3D; backup[t.a] + t.c;            &#125;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    memset(dist, 0x3f, sizeof dist);        for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        &#x2F;&#x2F;代表a到b有一条权值为c的边        edges[i] &#x3D; &#123;a, b, c&#125;;    &#125;        bellman_ford();        if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="②spfa模板-ACwing-851"><a href="#②spfa模板-ACwing-851" class="headerlink" title="②spfa模板(ACwing.851)"></a>②spfa模板(ACwing.851)</h3><p><img src="https://img-blog.csdnimg.cn/5cf3def466b34406a70e05162bfa6d1f.png" alt="spfa求最短路"></p><h4 id="相关分析-1"><a href="#相关分析-1" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度：</code>  $O(m)$</p><p><code>适用场景：</code>  其实spfa这个算法以他比较优越的时间复杂度，其实用在很多题目都可以，且不仅能够求带负权的最短路，在一定程度上也可以解决dijkstra的题目。并且这个算法，可以判定一个图里面是否有负环</p><p><code>思路：</code>  这里的思路其实也是从上一个bellman-ford算法延申过来的。我们可以看到，上一个算法的好处就是可以知道有边限制的最短路，但是其实如果没有边的限制的话，第一个算法其实在内层循环遍历边的时候，会有很多操作本身更新不了一个点到原点的距离，但是还是进行了一个尝试更新的操作。<font color="red">那么spfa的话其实就是可以排除这些没有实际价值的更新操作，也就是说在$dist[j] &#x3D; dist[t] + w[i] $的那一步，只有一个点能够达到这一步操作了，让这个点进入队列之中，才有机会更新其他的边，如果某个点本身压根无法更新其他边，那也就没有必要让他到队列中再去更新其他边 </font></p><h4 id="完整AC代码-1"><a href="#完整AC代码-1" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 1e5 + 5;bool st[N];int dist[N], n, m;int h[N], w[N], e[N], ne[N], idx;queue&lt;int&gt; q;void add(int a, int b, int c) &#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++;&#125;void spfa() &#123;    q.push(1);    dist[1] &#x3D; 0;    st[1] &#x3D; true;    &#x2F;&#x2F;利用类似宽搜的方法进行优化    while(q.size()) &#123;        auto t &#x3D; q.front();        q.pop();        &#x2F;&#x2F;注意用过的点，有可能在后续更新的时候会继续用        st[t] &#x3D; false;                for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]) &#123;            int j &#x3D; e[i];                        if(dist[j] &gt; dist[t] + w[i]) &#123;                dist[j] &#x3D; dist[t] + w[i];                if(!st[j]) &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;&#125;int main() &#123;    memset(h, -1, sizeof h);    memset(st, 0, sizeof st);    memset(dist, 0x3f, sizeof dist);    cin &gt;&gt; n &gt;&gt; m;        for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;        spfa();        if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码相关问题"><a href="#代码相关问题" class="headerlink" title="代码相关问题"></a>代码相关问题</h4><p>这里的话有一个问题，就是为什么一个已经被使用来更新其他点的点，从对头取出来的那一刻，他的st数组要被更新成为没有使用过，这里举一个例子，例子图如下:</p><p><img src="https://img-blog.csdnimg.cn/c108a2f31d904c2f8056dcaecc2581a7.png" alt="spfa例子图"></p><p>我们可以看到这个图，假设，我们在用1这个点第一次更新好1-&gt;2和1-&gt;4的距离后，不让他的st数组变为false的话，那么当3这个点用来更新1的时候，很显然从1-&gt;2-&gt;3-&gt;1一回会让整个路径变小，而我们虽然更新了一下3-&gt;1的距离，但是并没有在后面让1入队的话，那么1这个点就不会继续更新4这个点，当然这个例子有些问题，因为，我们可以一直让上方的环不断的走，让最后的1到4的路径距离不断的减少，所以希望读者有更好的例子可以举例一下。</p><p>当然，这个题，如果不专门用st代表是否访问，直接更新然后不断放点那其实就等同于bellman-ford算法了，所以还是建议这个地方能够继续好好理解一下。然后也正因为这样，spfa算法可以去判定一下是否有负环，或者是否有一个环可以让某一个路径的距离一直减小。</p><h3 id="③spfa判断负环-ACwing-852"><a href="#③spfa判断负环-ACwing-852" class="headerlink" title="③spfa判断负环(ACwing. 852)"></a>③spfa判断负环(ACwing. 852)</h3><p><del>负环的定义就是一个环上边的权值全部为负数</del>，刚开始我还一直这么认为的，其实负环应该是一个环上所有数加起来的权值和是为负数叫做负环，因此根据上面的一个分析，其实判断负环就很容易了，就看循环是不是一直跑不出来，因为不能死循环，所以我们要利用一个cnt数组，判断一下某个点走了多少次，根据抽屉原理，一旦走的次数比n大的时候，那么一定存在负环。</p><p><img src="https://img-blog.csdnimg.cn/ce8a83dc0fb24fb1bb3636a59bd3c1c4.png"></p><h4 id="完整AC代码-2"><a href="#完整AC代码-2" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 100050, INF &#x3D; 1e9 + 10;int n, m, idx;int h[N], e[N], ne[N], w[N];int dist[N], cnt[N];bool st[N];void add(int a, int b, int c) &#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], w[idx] &#x3D; c, h[a] &#x3D; idx ++ ;&#125;bool spfa() &#123;    queue&lt;int&gt; q;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        q.push(i);        st[i] &#x3D; true;    &#125;        while(q.size()) &#123;        int t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i] ) &#123;            int j &#x3D; e[i];                        if(dist[j] &gt; dist[t] + w[i]) &#123;                dist[j] &#x3D; dist[t] + w[i];                cnt[j] &#x3D; cnt[t] + 1;                                if(cnt[j] &gt;&#x3D; n) return true;                                if(!st[j]) &#123;                    st[j] &#x3D; true;                    q.push(j);                &#125;            &#125;        &#125;    &#125;        return false;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);        for(int i &#x3D; 0; i &lt; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;        if(spfa()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码问题"><a href="#代码问题" class="headerlink" title="代码问题"></a>代码问题</h4><p>为什么dist数组不用初始化为正无穷？</p><p>​    其实就是，负环必须走的那个路径是有负数产生的，且由于一个环必须满足权值为负，那么我们其实可以偷懒一下，让每次开始更新dist出现在，我们搜索的时候，第一次搜到的负数开始，然后在更新dist，如果有负环，那么这个dist是会不断减少的。<font color="red">这个等价于什么呢，我们可以发现，之前的题目都是从1这个点出发开始的，而负环不一定存在1这个点连接的路径上，所以其实在刚开始，队列就应该把所有点放进去，然后所有点去找负环，那也就是说从这个角度看，所有点距离本身的距离为0，那么初始化为0就是正确的！</font></p>]]></content>
      
      
      <categories>
          
          <category> 图论专题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之Dijkstra</title>
      <link href="/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BDijkstra/"/>
      <url>/2022/07/28/%E5%9B%BE%E8%AE%BA%E4%B9%8BDijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本篇开始进行有关图论Dijkstra的题目整理，首先会整理两个模板，针对dijkstra的朴素版本和优化版本，此系列也会一直的更新，对于之后做到相关的题目，会放到此专题当中！而对于这个算法来说，一般求的是对于一些有向图，从某个点走到另外的一个终点不同路径的最小距离，<font color="red">注意此时有向边的权值必须为正数才行！</font></p><h1 id="二、题目汇总"><a href="#二、题目汇总" class="headerlink" title="二、题目汇总"></a>二、题目汇总</h1><h3 id="①朴素版Dijkstra-ACwing-849"><a href="#①朴素版Dijkstra-ACwing-849" class="headerlink" title="①朴素版Dijkstra(ACwing 849)"></a>①朴素版Dijkstra(ACwing 849)</h3><p><img src="https://img-blog.csdnimg.cn/9d19c2becddc4fc9a17f3b542df945cd.png" alt="求最短路"></p><h4 id="相关分析："><a href="#相关分析：" class="headerlink" title="相关分析："></a>相关分析：</h4><p><code>时间复杂度：</code>   $O(n^2)$，此处的n代表点的数量</p><p><code>适用场景：</code>  题目中是稠密图，点比较少，但是边比较多。此时利用邻接矩阵存图！</p><p><code>思路：</code>  朴素版本的Dijkstra的整体思路就是，从某个点(记作一号点)开始设其距离为0，然后通过与他本身距离更短的点不断的更新其他点到一号点的一个距离。外层的循环就是循环点的编号，内层的循环就是找到第一个离原点最近的那个点，然后利用那个点更新他其他边到原点最近的距离。</p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 505;&#x2F;&#x2F;邻接矩阵存图, n表示点数,m表示边数量;int g[N][N], n, m;&#x2F;&#x2F;dist数组表示某个点到原点的最短距离int dist[N];&#x2F;&#x2F;记录某个点有没有被更新过bool st[N];void dijkstra() &#123;    &#x2F;&#x2F;原点距离本身为0    dist[1] &#x3D; 0;        &#x2F;&#x2F;两层循环    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;        &#x2F;&#x2F;哨兵，便于选点        int t &#x3D; -1;        &#x2F;&#x2F;找到没有用来更新其他点的最短距离原点的点        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t])) &#123;                t &#x3D; j;            &#125;        &#125;        &#x2F;&#x2F;t这个点已经用来更新过了        st[t] &#x3D; true;                &#x2F;&#x2F;用t这个点更新一下        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) &#123;            dist[j] &#x3D; min(dist[j], g[t][j] + dist[t]);        &#125;    &#125;&#125;int main() &#123;    &#x2F;&#x2F;初始化，刚开始边都是正无穷，便于取最小，判定是否有路径    memset(g, 0x3f, sizeof g);    memset(dist, 0x3f, sizeof dist);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        &#x2F;&#x2F;代表a到b有一个权值为v的边        int a, b, v;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; v;        &#x2F;&#x2F;可以提前排除自环        if(a !&#x3D; b) g[a][b] &#x3D; min(g[a][b], v);    &#125;    &#x2F;&#x2F;进行求解    dijkstra();    &#x2F;&#x2F;如果路径不存在，那么dist[n]还是正无穷    if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;        return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="②堆优化版Dijkstra-ACwing-850"><a href="#②堆优化版Dijkstra-ACwing-850" class="headerlink" title="②堆优化版Dijkstra(ACwing.850)"></a>②堆优化版Dijkstra(ACwing.850)</h3><p><img src="https://img-blog.csdnimg.cn/630fa3f2d27543bbb1b52f70837ee197.png" alt="求最短路"></p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p><code>时间复杂度：</code>   $O(mlogm)$</p><p><code>适用场景:  </code>  这个题目和第一个题目最大的不同就是点数变多了，而如果再使用$O(n^2)$的做法就会超时，所以需要看点数比较多，而边数能够满足时间复杂度的时候就可以使用了。</p><p><code>思路：  </code>  之所以有这个优化，主要是因为我们可以看到第一个解法再寻找t用来更新其他路径的时候，是利用一层循环进行更新才能保证t的那个点更新的距离是最短的，但是其实这个过程是可以利用一个数据结构–优先队列(堆)进行相关的优化的，而在堆进行查找的操作是O(1)的，只不过删除元素后，把堆调整，是需要log的时间,所以以上的时间可以被优化。</p><h4 id="完整AC代码-1"><a href="#完整AC代码-1" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 2e5;int m, n, dist[N];&#x2F;&#x2F;利用邻接表存int h[N], e[N], ne[N], w[N], idx;&#x2F;&#x2F;队列放一个pair,pair第一个装距离，第二个装点编号&#x2F;&#x2F;因为pair默认按照第一个关键字排序&#x2F;&#x2F;这样可以做到排序的时候就是按照距离短进行priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;bool st[N];&#x2F;&#x2F;邻接表的一半添加操作，头插法void add(int a, int b, int c) &#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], w[idx] &#x3D; c, h[a] &#x3D; idx ++ ;&#125;void dijkstra() &#123;    dist[1] &#x3D; 0;    &#x2F;&#x2F;先让队列存在第一个点，第一个点的距离为0，编号是1    q.push(&#123;0, 1&#125;);        while(q.size()) &#123;        auto t &#x3D; q.top();        q.pop();        &#x2F;&#x2F;如果此点已经更新了其他点就不用再更新        if(st[t.y]) continue;        &#x2F;&#x2F;标记此点用来更新其他点        st[t.y] &#x3D; true;                for(int i &#x3D; h[t.y]; i !&#x3D; -1; i &#x3D; ne[i]) &#123;            int j &#x3D; e[i];            &#x2F;&#x2F;只有让某个点的距离能够更新的情况            &#x2F;&#x2F;才把那个点放到队列，可能用来更新其他点到原点的距离            if(dist[j] &gt; w[i] + dist[t.y]) &#123;                dist[j] &#x3D; w[i] + dist[t.y];                q.push(&#123;dist[j], j&#125;);            &#125;        &#125;            &#125;&#125;int main() &#123;    &#x2F;&#x2F;初始化操作    &#x2F;&#x2F;距离先初始化为正无穷    &#x2F;&#x2F;头结点开始指向空，记作-1    memset(dist, 0x3f, sizeof dist);    memset(h, -1, sizeof h);    memset(st, 0, sizeof st);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;        dijkstra();        if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图论专题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状压dp</title>
      <link href="/2022/07/28/%E7%8A%B6%E5%8E%8Bdp/"/>
      <url>/2022/07/28/%E7%8A%B6%E5%8E%8Bdp/</url>
      
        <content type="html"><![CDATA[<p>等待更新ing……</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -状压DP -DP分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形dp</title>
      <link href="/2022/07/28/%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2022/07/28/%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p>等待更新ing……</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -树形DP -DP分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bfs 专题</title>
      <link href="/2022/07/27/bfs-%E4%B8%93%E9%A2%98/"/>
      <url>/2022/07/27/bfs-%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>等待更新ing……</p>]]></content>
      
      
      <categories>
          
          <category> 搜索专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -宽度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs专题</title>
      <link href="/2022/07/27/dfs%E4%B8%93%E9%A2%98/"/>
      <url>/2022/07/27/dfs%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>等待更新ing……</p>]]></content>
      
      
      <categories>
          
          <category> 搜索专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP</title>
      <link href="/2022/07/27/%E5%8C%BA%E9%97%B4DP/"/>
      <url>/2022/07/27/%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>最近写的一些相关文章，主要会整理一下相关题目，此系列会不断的更新，只要遇到了相关的题目就都会整理在一起！本篇主要针对区间DP进行相关整理。区间dp有一个特点，就是一般题目都会对一个区间进行一些处理，而此dp的状态定义也与区间相关。而整个题目的分析，采取闫式dp分析法，从<font color="red">状态表示，状态计算</font>两个方面分析每一个dp题目。希望之后做到类似的题目的时候能够更快速的分析出如何解题！</p><h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><h3 id="①ACwing-282-石子合并"><a href="#①ACwing-282-石子合并" class="headerlink" title="①ACwing 282.石子合并"></a>①ACwing 282.石子合并</h3><p><img src="https://img-blog.csdnimg.cn/b2869b5a18454244929219a1982c5a8e.png" alt="石子合并"></p><p><code>注意：</code></p><p>本题和大家比较常见的合并果子那一个贪心题不同，因为此题必须合并相邻的两堆石子。如果合并的顺序是任意的话才能够利用贪心！</p><h4 id="DP分析"><a href="#DP分析" class="headerlink" title="DP分析"></a>DP分析</h4><p><img src="https://img-blog.csdnimg.cn/ec2607b4d3a447579a45ccbe1b105650.png"></p><blockquote><p>此处解释上方的一个分析方法</p><p>对于动态规划来说，如何能够正确的写出这类的题目，首先要知道，先定义一个与题目相关的状态表示，而这样的状态表示恰好表示一类集合，而这一类集合表达出来以后，是可以先考虑以集合的最后一个点作为分界点往前看。</p><p>假设我们在计算f(i, j)的时候，我们可以以j为分界点，把集合分成j - 1的子集合，状态转移中的m分界点。注意这个m所选取的区间是落在[i, j)这个区间内的。</p><p>为什么i为闭区间，j为开区间呢？</p><p>因为选i为分界点，可以分为拿第一个和后面所有为两个区间</p><p>而如果选j为分界点，就无法分成两堆了！</p><p>一旦分好这些分界点之后，就知道如何进行递推了。</p></blockquote><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>如果以m为分界点，我们要计算f(i, j)的值</p><p><font color="red">$f(i, j) &#x3D; min(f(i, m) + f(m + 1, j) + sum(i, j)), m \in [i, j)$</font></p><p>其中sum(i, j)表示[i, j]区间所有果子合并需要花费的体力值，这个也就是合并两段区间所需要的体力值！而因为这个是一个区间求和的问题，因此再计算sum的时候就可以利用前缀和进行一个优化了！</p><p><font color="blue">最后结果就是：f(1,n)</font></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>对于初始化来说，有下面情况</p><p>i &#x3D;&#x3D; j : 就是合并一个石子的最小花费为0(因为不需要合并)</p><p>i &lt; j : 最小花费初始化为$+\infty$,因为要求最小值，所以可以初始成一个很大的数，<font color="red">这里不能说初始化为0，因为0代表无花费，这样的话怎么推导，都是最小为0，那么最后的答案肯定是0</font></p><h4 id="完整AC代码"><a href="#完整AC代码" class="headerlink" title="完整AC代码"></a>完整AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 305, INF &#x3D; 0x3f3f3f3f;&#x2F;&#x2F;初始化1int f[N][N];&#x2F;&#x2F;前缀和数组int sum[N];int main() &#123;    int n;    cin &gt;&gt; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;        cin &gt;&gt; sum[i];        sum[i] +&#x3D; sum[i - 1];    &#125;        &#x2F;&#x2F;先枚举可能的区间长度    for(int len &#x3D; 2; len &lt;&#x3D; n; len ++ ) &#123;        &#x2F;&#x2F;左端点为i，右端点为i + len - 1;        &#x2F;&#x2F;满足右端点在n内就可以满足左端点范围        for(int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++ ) &#123;            int l &#x3D; i, r &#x3D; i + len - 1;            &#x2F;&#x2F;初始化2            f[l][r] &#x3D; INF;                        &#x2F;&#x2F;枚举分界点m            for(int m &#x3D; l; m &lt; r; m ++ ) &#123;                &#x2F;&#x2F;状态转移                f[l][r] &#x3D; min(f[l][r], f[l][m] + f[m + 1][r] + sum[r] - sum[l - 1]);            &#125;        &#125;    &#125;        cout &lt;&lt; f[1][n] &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 动态规划专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -区间DP -DP分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性DP</title>
      <link href="/2022/07/27/%E7%BA%BF%E6%80%A7DP/"/>
      <url>/2022/07/27/%E7%BA%BF%E6%80%A7DP/</url>
      
        <content type="html"><![CDATA[<p>等待更新ing……</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -线性DP -DP分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟堆</title>
      <link href="/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%A0%86/"/>
      <url>/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本篇文章主要以小根堆为例子，做一些有关小根堆的知识点笔记，前面主要就是堆排序，后面呢是一个题目的相关介绍，由于那个题目的特殊性，所以不多加赘述，这一篇主要是以堆能够实现的一些操作为例子，记录一下堆的一些应用。</p><h1 id="二、理解"><a href="#二、理解" class="headerlink" title="二、理解"></a>二、理解</h1><p>本篇主要受众是已经建立在知道二叉树的建立的基础上，进行堆的记录。如果不太了解二叉树的uu们可以先去了解一下二叉树的建立，知道左右孩子的节点是怎么表示的，然后食用一下这篇文章。</p><p>堆呢，其实原型就是一颗完全二叉树，我们知道，完全二叉树必须保证树儿子的完整性，即一个节点为x的父亲，如果他有孩子，那么他左右孩子的节点位置一定为2x和(2x+ 1)，而整个树的根节点坐标从1开始计算！</p><p>而堆其实分为小根堆和大根堆。以小根堆为主要例子介绍。小根小根，就是根都是小的，也就是一个节点如果有孩子，那么他在他本身和他孩子中间，他是最小的。即是我们的小根堆。至于小根堆，以下面的图做例子，相信大家能够更加清晰的知道了。</p><p><img src="https://img-blog.csdnimg.cn/04ee26c8076d4a15b9044e8ab0e92b6d.png"></p><p>上图就是一个小根堆，而红颜色代表着每一个节点的坐标。</p><h1 id="三、堆的相关函数"><a href="#三、堆的相关函数" class="headerlink" title="三、堆的相关函数"></a>三、堆的相关函数</h1><p>我觉得还是应该先以堆的相关函数为例子然后在进行后续堆的基本操作的讲解</p><h3 id="①定义相关变量"><a href="#①定义相关变量" class="headerlink" title="①定义相关变量"></a>①定义相关变量</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100050;int h[N]; &#x2F;&#x2F;存储堆的元素int sz &#x3D; 0; &#x2F;&#x2F;表示堆的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②down函数"><a href="#②down函数" class="headerlink" title="②down函数"></a>②down函数</h3><p>如果有一些节点发生了变化，可能会导致节点需要向下调整到合适的位置</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void down(int u) &#123;    &#x2F;&#x2F;记录节点和孩子谁最小，小的会到父亲的位置，成为根    int t &#x3D; u;    &#x2F;&#x2F;如果左孩子存在，并且比根小的话    if(2*u &lt;&#x3D; sz &amp;&amp; h[t] &gt; h[2*u]) t &#x3D; 2*u;    &#x2F;&#x2F;如果有孩子存在，并且比根和左孩子小的话    if(2*u+1 &lt;&#x3D; sz &amp;&amp; h[t] &gt; h[2*u+1]) t &#x3D; 2*u+1;    &#x2F;&#x2F;如果此时记录的t不等于u的话    if(t !&#x3D; u) &#123;        swap(h[t], h[u]);    &#x2F;&#x2F;递归的处理一下后续的节点    down(t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③up函数"><a href="#③up函数" class="headerlink" title="③up函数"></a>③up函数</h3><p>如果有一些节点发生了变化，可能会导致节点需要向上调整到合适的位置，<font color="red">而向上调整与向下不同的是，向上调整的时候，只需要跟根节点进行比较就好，因为为了满足小根堆的需求，其中孩子变化了，但是在之前一个状态下，根还是保证最小。</font></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void up(int u) &#123;    &#x2F;&#x2F;当根节点比变化的孩子大，就让他向上调整    while(u &#x2F; 2 &gt; 0 &amp;&amp; h[u &#x2F; 2] &gt; h[u]) &#123;        swap(h[u &#x2F; 2], h[u]);        u &#x2F;&#x3D; 2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、堆的基本操作"><a href="#四、堆的基本操作" class="headerlink" title="四、堆的基本操作"></a>四、堆的基本操作</h1><p>通过堆相关函数的介绍下面其实就是函数的拼凑了</p><h3 id="①构建一个堆"><a href="#①构建一个堆" class="headerlink" title="①构建一个堆"></a>①构建一个堆</h3><p>这里有一个比较巧的方法，无论是什么样的小根堆，如果他含有n个元素，那么叶子节点(没有孩子节点层)的上一层最后一个存有元素的父亲节点为n &#x2F; 2,这个结论大家可以直接记住。所以我们在构建堆的时候，我们只需要从节点为n &#x2F; 2处开始向上调整节点，每个节点都往下down一遍就可以建立一个堆。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这个操作可以把一个存有元素的一维数组，按照堆的节点顺序排列for(int i &#x3D; n &#x2F; 2; i &gt; 0; i -- ) &#123;    down(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②向堆里面插入一个元素"><a href="#②向堆里面插入一个元素" class="headerlink" title="②向堆里面插入一个元素"></a>②向堆里面插入一个元素</h3><p>这里有个技巧就是下面几个点</p><ul><li>将插入的元素先插入在堆的最后</li><li>利用up函数向上调整一遍</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">h[++sz] &#x3D; val;&#x2F;&#x2F;向上调整堆的最后一个元素up(sz);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="③删除堆中的元素"><a href="#③删除堆中的元素" class="headerlink" title="③删除堆中的元素"></a>③删除堆中的元素</h3><ul><li>将待删除的元素和堆中最后一个元素</li><li>up调整一遍</li><li>down调整一遍</li></ul><p>其中后面两个步骤只会进行其中一个，因为调整后，要不然就是比其父亲小，要不然就比孩子大。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">swap(h[k], h[sz]);sz--;up(k);down(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④修改堆中的某个元素值"><a href="#④修改堆中的某个元素值" class="headerlink" title="④修改堆中的某个元素值"></a>④修改堆中的某个元素值</h3><p>和第三个操作类似</p><ul><li>修改堆中元素值</li><li>up调整一遍</li><li>down调整一遍</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">h[k] &#x3D; val;up(k);down(k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑤输出堆中的最小值"><a href="#⑤输出堆中的最小值" class="headerlink" title="⑤输出堆中的最小值"></a>⑤输出堆中的最小值</h3><ul><li>直接输出堆顶元素就好</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; h[1] &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="blue">不难发现，其实整个堆的调整就是类似打拳皇一样，我们先熟知每一个英雄他有什么技能，然后根据不同的需求，利用我们已知的技能，打出不同的组合技能，最终KO对方。而我们就是要利用组合起来的函数AC相关的算法题。还是很好玩的！</font></p><h1 id="五、相关题目"><a href="#五、相关题目" class="headerlink" title="五、相关题目"></a>五、相关题目</h1><h3 id="题目一-堆排序"><a href="#题目一-堆排序" class="headerlink" title="题目一.堆排序"></a>题目一.堆排序</h3><p>能够利用堆排序主要的原因就是小根堆能够维护我们整个堆中的最小值。当最小值被输出之后，我们删除堆顶元素，然后不断的输出新的堆顶元素，我们就可以完成这一个题目。所以只需要利用四中的①③⑤组合技我们就可以AC掉了</p><p><img src="https://img-blog.csdnimg.cn/7e6cd8f3a0f6437c9b5f531c3c83eff9.png"></p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100005;int m, n;int sz, h[N];void down(int x) &#123;    int t &#x3D; x;    &#x2F;&#x2F;左子树存在且比节点小    if(2 * x &lt;&#x3D; sz &amp;&amp; h[2 * x] &lt; h[t]) t &#x3D; 2 * x;    &#x2F;&#x2F;右子树存在且比节点小    if(2 * x + 1 &lt;&#x3D; sz &amp;&amp; h[2 * x + 1] &lt; h[t]) t &#x3D; 2 * x + 1;    if(t !&#x3D; x) &#123;        swap(h[t], h[x]);        down(t);    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    sz &#x3D; n;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; h[i];    for(int i &#x3D; n &#x2F; 2; i; i--) down(i);    while(m--) &#123;        cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;;        h[1] &#x3D; h[sz--];        down(1);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p><img src="https://img-blog.csdnimg.cn/a21629f07a4f486a93bb6dbc8ce117e6.png"></p><p>这个题目因为要记录一下第k个插入数的位置，所以大家可以直接用结构体装一下每个节点是第几个插入的，但是为了快速，是可以类似利用数组去模拟哈希表的方式进行实现，因为可能会有些难理解。我写了相关的注释在代码中，可以量力理解一下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;ph[k]表示第k个插入的节点在堆中的下标，hp[k]表示堆中第k个节点是第几个插入的数。#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100005;int ph[N], hp[N], h[N];&#x2F;&#x2F;m代表第m个插入的数，cnt代表整个堆的大小int m, cnt;&#x2F;&#x2F;这个swap就实现了不仅元素交换了，节点对应是第几个插入的数也被交换了！void heap_swap(int a, int b) &#123;    &#x2F;&#x2F;交换第某个插入的数的堆中下标    swap(ph[hp[a]], ph[hp[b]]);    &#x2F;&#x2F;交换堆中某个节点代表插入的数    swap(hp[a], hp[b]);    &#x2F;&#x2F;交换堆中的两个位置的值    swap(h[a], h[b]);&#125;&#x2F;&#x2F;下传操作void down(int x) &#123;    int t &#x3D; x;    if(2 * x &lt;&#x3D; cnt &amp;&amp; h[2 * x] &lt; h[t]) t &#x3D; 2 * x;    if(2 * x + 1 &lt;&#x3D; cnt &amp;&amp; h[2 * x + 1] &lt; h[t]) t &#x3D; 2 * x + 1;    if(t !&#x3D; x) &#123;        heap_swap(t, x);        down(t);    &#125;&#125;&#x2F;&#x2F;上传操作void up(int x) &#123;    while(x &#x2F; 2 &amp;&amp; h[x &#x2F; 2] &gt; h[x]) &#123;        heap_swap(x, x &#x2F; 2);        x &gt;&gt;&#x3D; 1;    &#125;&#125;int main() &#123;    int num, k, n;    cin &gt;&gt; n;    string op;    while(n--) &#123;        cin &gt;&gt; op;        &#x2F;&#x2F;插入操作        if(op &#x3D;&#x3D; &quot;I&quot;) &#123;            cin &gt;&gt; num;            cnt++; m++;            h[cnt] &#x3D; num; hp[cnt] &#x3D; m; ph[m] &#x3D; cnt;            up(cnt);        &#125;        &#x2F;&#x2F;输出最小值        else if(op &#x3D;&#x3D; &quot;PM&quot;) &#123;            &#x2F;&#x2F; cout &lt;&lt; n &lt;&lt; endl;            cout &lt;&lt; h[1] &lt;&lt; endl;        &#125;        &#x2F;&#x2F;删除最小值        else if(op &#x3D;&#x3D; &quot;DM&quot;) &#123;            heap_swap(1, cnt);            cnt--;            down(1);        &#125;        &#x2F;&#x2F;删除第k个插入的数        else if(op &#x3D;&#x3D; &quot;D&quot;) &#123;            cin &gt;&gt; k;            &#x2F;&#x2F;必须先保存一个位置，否则有可能在交换过程直接交换了指针位置，导致答案错误！！            k &#x3D; ph[k];            heap_swap(k, cnt);            cnt--;            up(k);            down(k);        &#125;        &#x2F;&#x2F;修改第k个插入的数为num        else &#123;            cin &gt;&gt; k &gt;&gt; num;            int id &#x3D; ph[k];            h[id] &#x3D; num;            up(id);            down(id);        &#125;    &#125;    return 0;&#125;作者：sheepice链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;3438577&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构 -模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie数(字典树)</title>
      <link href="/2022/07/03/Trie%E6%95%B0-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2022/07/03/Trie%E6%95%B0-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>字典树是一个比较神奇的东西。试想如果我们要用程序去存一些字符串，但是相同的字符不能放在不同的空间里面，比如有两个字符串abc，abf，我们发现ab是相同的，就需要我们把他们存在一个数组空间?我们应该怎么做到呢？再来就是为什么叫字典树呢，其实很形象的说明了他的存储方式，就是字典。我们在查字典的时候，都会先查一个单词的首字母，然后在对应的地方继续依次查后面的字母。也就是我们可以利用数组完成这样的存储</p><p><font color="red">但是由于一般数组的空间有限，字典树会占据很多的空间，一个abc就占用了3个单位空间，所以在用的时候是需要注意一下数据范围，是否能够不爆空间！</font></p><h1 id="二、相关操作"><a href="#二、相关操作" class="headerlink" title="二、相关操作"></a>二、相关操作</h1><h3 id="①前期变量定义"><a href="#①前期变量定义" class="headerlink" title="①前期变量定义"></a>①前期变量定义</h3><p><img src="https://img-blog.csdnimg.cn/90071e11da794f4fae8dde0d9ba95be5.jpeg"></p><p>字典树需要一个二维数组空间，叫做son，为什么这么称呢。因为我们整个树的根节点我们用idx&#x3D;0来表示。这个点是整个树的头，他有无数的儿子，儿子又有无数的儿子。所以我们亲切的称后续的节点为一个儿子</p><p>而son的定义其实就是每一个x都会对应有y个儿子，无论我们是插入操作还是查询操作，为了满足不浪费多余的空间，我们都需要进行首先的判断，作为第x的父亲是否已经存在y这个节点，如果不存在，就给他一个儿子，如果存在，就一视同仁为一个儿子。</p><h3 id="②插入一个字符串"><a href="#②插入一个字符串" class="headerlink" title="②插入一个字符串"></a>②插入一个字符串</h3><p>假设我们树中的字符串全是小写字母，那我们的儿子其实只可能有26个，所以在开数组的时候就可以开: int $son[N][26]$,而我们后面的例题主要以这个为主。</p><p><img src="https://img-blog.csdnimg.cn/dda00c468fce49e2b60e18731622c1a6.jpeg"></p><p>上面我觉得插入讲得比较清楚了，所以直接贴一个代码好了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insert(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ ) &#123;        int u &#x3D; ss[i] - &#39;a&#39;;        &#x2F;&#x2F;如果没有这个儿子就给他一个儿子        if(son[p][u] &#x3D;&#x3D; 0) son[p][u] &#x3D; ++idx;        &#x2F;&#x2F;不管有没有儿子，p指针都会朝向儿子或者新建点走        &#x2F;&#x2F;一旦p走向新建的点，其实就代表后面的所有点都是新建的        p &#x3D; son[p][u];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③查询一个字符串"><a href="#③查询一个字符串" class="headerlink" title="③查询一个字符串"></a>③查询一个字符串</h3><p>查询其实和构建是差不多的，就是看我们要查询的字符串是否能够完全的走完构建好的字符串，至于查询，结合后面的题目，大家可以理解，直接贴一个小小的代码。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int query(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ ) &#123;        int u &#x3D; ss[i] - &#39;a&#39;;        if(son[p][u] &#x3D;&#x3D; 0) return 0;        p &#x3D; son[p][u];    &#125;        return cnt[p];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、相关题目"><a href="#三、相关题目" class="headerlink" title="三、相关题目"></a>三、相关题目</h1><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p><img src="https://img-blog.csdnimg.cn/fd0f17eb8d7846c0a542dbabb963e9e9.png"></p><p>上面的题目就是比较经典的，查询字串出现次数的题目，在我们构建树的时候，我们另外开一个cnt数组，记录一个字符串最后那个字母所在的位置出现了多少个就能解决这个题目了。可以直接看一下完整的代码。</p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100005;int son[N][26], cnt[N], idx;void insrt(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ )&#123;        int u &#x3D; ss[i] - &#39;a&#39;;        if(son[p][u] &#x3D;&#x3D; 0) son[p][u] &#x3D; ++ idx;        p &#x3D; son[p][u];    &#125;        cnt[p] ++ ;&#125;int query(string ss) &#123;    int sz &#x3D; ss.size();    int p &#x3D; 0;    for(int i &#x3D; 0; i &lt; sz; i ++ ) &#123;        int u &#x3D; ss[i] - &#39;a&#39;;        if(son[p][u] &#x3D;&#x3D; 0) return 0;        p &#x3D; son[p][u];    &#125;        return cnt[p];&#125;int main() &#123;    int n;    cin &gt;&gt; n;    while (n -- ) &#123;        string op, in;        cin &gt;&gt; op &gt;&gt; in;                if(op &#x3D;&#x3D; &quot;I&quot;) &#123;            insrt(in);        &#125;                else &#123;            cout &lt;&lt; query(in) &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p><img src="/2022/07/03/Trie%E6%95%B0-%E5%AD%97%E5%85%B8%E6%A0%91/Users/0604520/AppData/Roaming/Typora/typora-user-images/image-20220703165405990.png"></p><p>这个题目比较的好玩，其实这个题目就是在表述一个二叉树，具体的思路如图解</p><p><img src="https://img-blog.csdnimg.cn/102a9cd23cea44aa9b1abbb4ae8484e5.jpeg"></p><p>我们都知道一个二进制数异或起来，相同为0，不同为1，那其实就是再告诉我们，我们在不断建树的过程中，可以用待插入元素，与树中的元素比较，每次去看相同位下有没有和本身不同位的儿子，如果有的话，我们就可以忘那个儿子的路径走。</p><p>比如下图：</p><p><img src="https://img-blog.csdnimg.cn/54204ac29ce440e28dc684016f0b4e67.jpeg"></p><p>依次插入5，3，4并且寻找最大异或的元素，</p><p>再插入4的时候，先寻找最大异或，我们发现4的二进制是100</p><p>对于1这一位，先找有没有0儿子，恰好3的第一位为0，一次类推，他和3抑或能够得到最大的异或值7(111);</p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100050, M &#x3D; 31 * N;&#x2F;&#x2F;因为儿子只可能有0，1两个选项int son[M][2], idx &#x3D; 0;void insert(int num) &#123;    int p &#x3D; 0;    &#x2F;&#x2F;体重说最多有31位    for(int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;        int u &#x3D; (num &gt;&gt; i) &amp; 1;        if(son[p][u] &#x3D;&#x3D; 0) son[p][u] &#x3D; ++idx;        p &#x3D; son[p][u];    &#125;&#125;int query(int num) &#123;    int p &#x3D; 0, ret &#x3D; 0;    for(int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;        int u &#x3D; (num &gt;&gt; i) &amp; 1;        &#x2F;&#x2F;如果有不同的儿子        if(son[p][!u] !&#x3D; 0) &#123;            ret &#x3D; ret * 2 + !u;            p &#x3D; son[p][!u];        &#125;        &#x2F;&#x2F;如果没有不同的儿子        else &#123;            ret &#x3D; ret * 2 + u;            p &#x3D; son[p][u];        &#125;    &#125;    return ret;&#125;int main() &#123;    int m, num;    cin &gt;&gt; m;    int ans &#x3D; 0;    while (m -- ) &#123;        cin &gt;&gt; num;        insert(num);        ans &#x3D; max(num ^ query(num), ans);    &#125;        cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构 -模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP匹配字符串</title>
      <link href="/2022/07/03/KMP%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/07/03/KMP%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这一章记录的是自己学习KMP算法的一个笔记吧。我觉得KMP虽然目前没有用到相关的算法，但是他的思想很妙，很多人在刚开始会非常不理解这个算法的由来。而我也是写了好几遍才能够真的说掌握了一些KMP算法。其实主要记住一点就是，KMP完成了字符串与本身进行比较的一个思路。</p><p><font color="red">所有字符串下标从1开始</font></p><h1 id="二、相关操作"><a href="#二、相关操作" class="headerlink" title="二、相关操作"></a>二、相关操作</h1><h3 id="①相关变量的定义"><a href="#①相关变量的定义" class="headerlink" title="①相关变量的定义"></a>①相关变量的定义</h3><p><img src="https://img-blog.csdnimg.cn/dd7b7fd4f32e4ff0a3eaed36a6abcab1.jpeg"></p><p>说真的我觉得相关一些数组的定义是整个这个算法的核心</p><p>首先就是题目给的两个串，一个比较长的叫做模式串，另外一个叫做子串，题目的要求就是子串在模式串出现的位置或者出现的次数</p><p>我们再看最难理解的一个ne数组的定义，最长子串的公共前后缀长度</p><p><font color="red">其实这个地方需要加上一个定义，假设ne[X], 这个其实代表的是，子串从1-X位置的字符串的最长公共前后缀的长度。这里要说明的是，前后缀是什么</font></p><ul><li>前缀:包含字符串首字母的连续子串</li><li>后缀:包含字符串尾字母的连续子串</li></ul><blockquote><p>比如字符串：abc</p><p>前缀有: a  ab </p><p>后缀有: c  bc </p></blockquote><h3 id="②ne数组的求解"><a href="#②ne数组的求解" class="headerlink" title="②ne数组的求解"></a>②ne数组的求解</h3><p>搞清楚了前后缀之后，如果我们要去求ne数组怎么求呢？</p><p><img src="https://s2.loli.net/2022/07/03/RxH7P9sMBNehp3K.jpg"></p><p>假设我们有一个字符串：abcabf</p><blockquote><p>a : 0</p><p>ab : 0</p><p>abc : 0</p><p>abca : a为公共前后缀 1</p><p>abcab: ab为公共前后缀 2</p><p>abcabf: 0</p></blockquote><p>而上方求出这样一个数组便是去比较p字符串的本身,匹配图如下：</p><p><img src="https://s2.loli.net/2022/07/03/14KmUZj7hzg2bPA.jpg"></p><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;        while(j !&#x3D; 0 &amp;&amp; p[j + 1] !&#x3D; p[i]) j &#x3D; ne[j];        if(p[j + 1] &#x3D;&#x3D; p[i]) j ++ ;        ne[i] &#x3D; j;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③字符串匹配"><a href="#③字符串匹配" class="headerlink" title="③字符串匹配"></a>③字符串匹配</h3><p>为什么求出一个ne数组就可以拿来进行匹配了呢？</p><p><img src="https://s2.loli.net/2022/07/03/nzI3E4MfhCJ7x1u.jpg"></p><p>这个是我最常用进行的一个理解图</p><p>我们可以看到有两个子串</p><ul><li>q : abcabcabf</li><li>p : abcabf</li></ul><p>当p匹配到f的时候发现不相等了，那么子串p重新开始匹配的位置是由ne数组进行指示的，f位置前一个位置是b,b的ne值为2，代表此位置的公共前后缀的长度为2，那么我们需要先回到2的位置，也就是p串中的b位置，再看b后面的c是否与上面串相等。相等之后继续往后推移匹配p的串的指针j，知道j指针的值等于p的长度，说明已经匹配成功了。</p><p><font color="red">上面之所以能进行，其实就是因为，p利用ne指针去指示已经匹配过的前缀，我们不再进行重新匹配，而是从匹配好的前缀再重新开始，也就是说，abf和q串的abc字串不相等了，但是abc已经完全匹配好了ab后缀，那我的p串刚好有个ab前缀，那我们直接从ab这个前缀的位置再继续往后匹配，这样就避免了重复匹配的时间复杂度！</font></p><h1 id="三、相关题目"><a href="#三、相关题目" class="headerlink" title="三、相关题目"></a>三、相关题目</h1><p><img src="https://img-blog.csdnimg.cn/39a6860bc4104a7d98cca72c8f9cad77.png"></p><p><code>完整AC代码</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100050, M &#x3D; 10 * N;char p[N], q[M];int ne[N];int main() &#123;    &#x2F;&#x2F;进行相关输入    int n, m;    cin &gt;&gt; n &gt;&gt; (p + 1) &gt;&gt; m &gt;&gt; (q + 1);        &#x2F;&#x2F;先进性ne数组的求解    for(int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;        while(j !&#x3D; 0 &amp;&amp; p[j + 1] !&#x3D; p[i]) j &#x3D; ne[j];        if(p[j + 1] &#x3D;&#x3D; p[i]) j ++ ;        ne[i] &#x3D; j;    &#125;        &#x2F;&#x2F;进行字符串的匹配    for(int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; m; i ++ ) &#123;        while(j !&#x3D; 0 &amp;&amp; p[j + 1] !&#x3D; q[i]) j &#x3D; ne[j];        if(p[j + 1] &#x3D;&#x3D; q[i]) j ++ ;        if(j &#x3D;&#x3D; n) &#123;            cout &lt;&lt; i - n &lt;&lt; &quot; &quot;;            j &#x3D; ne[j];        &#125;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构 -模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟单链表</title>
      <link href="/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/07/03/%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在很久之前的博客sheepice已经有过对于链表的相关介绍，而当时那篇文章的访问量也比较大，说明还是对大家有一定的帮助，那么这篇文章将继续对链表进行一个介绍，而本次所记录的是单链表的数组模拟，其实就是采用了一个虚表头的做法。</p><p>为什么要用数组进行模拟呢，主要有以下几点：</p><ul><li>我们能够更好的理解单链表的存储方式。</li><li>能够巩固之前对于一般利用结构体构建链表的理解。</li><li>由于数组模拟的单链表能够实现用结构体模拟的链表的一切操作，但是在一些算法题上用数组进行模拟能够更快的跑出程序。</li><li>也可以为之后即将总结一些图论的邻接表的构建打下一定的基础。</li></ul><h1 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h1><h3 id="①初始化操作"><a href="#①初始化操作" class="headerlink" title="①初始化操作"></a>①初始化操作</h3><p>初始化的操作主要进行下面几点：</p><ul><li>头结点指向空(我们用-1代表空节点)</li><li>当前节点idx为0(代表我们没有用一个节点进行操作)</li><li>定义一些数组，存储当前节点和下一个节点的信息</li></ul><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100050 &#x2F;&#x2F;根据题目给的数据去定义一个Nint e[N];   &#x2F;&#x2F;这个数组代表某个节点所存下的值int ne[N];  &#x2F;&#x2F;这个数组代表某个节点的下一个节点位置，相当于next指针void init() &#123;    head &#x3D; -1, idx &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②向头节点插入一个元素"><a href="#②向头节点插入一个元素" class="headerlink" title="②向头节点插入一个元素"></a>②向头节点插入一个元素</h3><p><img src="https://s2.loli.net/2022/07/03/kMLPo4DzBaGXqQb.jpg"></p><p>大家可以看一下上面的图，如果要在整个链表最左边插入一个值，我们只需要四步走</p><ul><li>存下当前节点值val</li><li>存下当前节点的下一个节点值，也就是头指针指向的值</li><li>让头指针指向新进来的值</li><li>idx++ 代表我们已经处理完了一个点，下一个节点的坐标需要比这个点多1。刚开始学的时候这个地方不太清楚，其实主要知道，每个节点都是独一无二的，idx无非只是控制这个节点的下标为多少。</li></ul><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void add_to_head(int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; head;    head &#x3D; idx;    idx ++ ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③删除第k个节点后面的一个数"><a href="#③删除第k个节点后面的一个数" class="headerlink" title="③删除第k个节点后面的一个数"></a>③删除第k个节点后面的一个数</h3><p><img src="https://s2.loli.net/2022/07/03/5ejIVBnwxLvTPqY.jpg"></p><p>这个操作其实比较的简单，我们只需要让第k个节点的next指针指向它下一个节点的下一个节点。</p><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;删除下标为k的后面一个数(D k)void remove(int k)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④在一个节点后面新加上一个值"><a href="#④在一个节点后面新加上一个值" class="headerlink" title="④在一个节点后面新加上一个值"></a>④在一个节点后面新加上一个值</h3><p><img src="https://s2.loli.net/2022/07/03/BD9YMRPUsn2A6fb.jpg"></p><p>这个操作和基本链表一样，也是四步走</p><ul><li>构建新节点记下存下的值</li><li>新节点的next指针指向某节点指向的值</li><li>某节点指向新的节点</li><li>idx++ 代表要处理后续的节点</li></ul><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void add(int k, int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx;    idx ++ ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⑤输出链表"><a href="#⑤输出链表" class="headerlink" title="⑤输出链表"></a>⑤输出链表</h3><p>上面的四个步骤已经包含了绝大部分链表的操作了，那最后就是如何把我们的链表进行输出呢?其实就是我们先让一个指针指向head头指针指向的地方，依次利用ne数组，去探索后续的节点，知道指针指向空节点(也就是值等于我们最初初始化的-1)</p><p>可能用文字描述不太能理解，我们可以看下面的图解，大家也可以跟着图慢慢的走，一定能够发现其中的逻辑。</p><p><img src="https://s2.loli.net/2022/07/03/YfZ9yqvPF6DW1oC.jpg"></p><p>上面的这个图便是模拟了插入两次头节点，然后在中间插入后，最终我们的一个红色线路就是我们的输出线路，而完成这个链表的输出。其实就是下面图中的代码！</p><p><img src="https://s2.loli.net/2022/07/03/g2YHWrvRZN8QseT.jpg"></p><p><code>代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、题目分享"><a href="#三、题目分享" class="headerlink" title="三、题目分享"></a>三、题目分享</h1><p>上述的所有操作就可以完成一个基本模拟单链表的题目，题目如下：</p><p><img src="https://img-blog.csdnimg.cn/3a334c670a3547ae891844bd5902bdb0.png"></p><p><code>完整AC代码如下：</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;&#x2F;&#x2F;idx表示节点&#x2F;&#x2F;head表示头结点&#x2F;&#x2F;e表示当前下标点的值&#x2F;&#x2F;ne表示当前下标点的下一个下标的位置int idx &#x3D; 0, head &#x3D; -1;int e[N], ne[N];&#x2F;&#x2F;将值为x插入到头节点的位置(H x)void add_to_head(int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; head;    head &#x3D; idx;    idx ++ ;&#125;&#x2F;&#x2F;删除下标为k的后面一个数(D k)void remove(int k)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;&#x2F;&#x2F;在下标为k的数的后面插入一个数x(I k x)void add(int k, int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx;    idx ++ ;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    while (n -- )     &#123;        char op;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &#39;H&#39;)        &#123;            int x;            cin &gt;&gt; x;            add_to_head(x);        &#125;        else if(op &#x3D;&#x3D; &#39;D&#39;)        &#123;            int k;            cin &gt;&gt; k;            if(k &#x3D;&#x3D; 0) head &#x3D; ne[head];            remove(k - 1);        &#125;        else        &#123;            int x, k;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);        &#125;    &#125;    for(int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    return 0;&#125;作者：sheepice链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;3676581&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构 -模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19岁!</title>
      <link href="/2022/06/03/19%E5%B2%81/"/>
      <url>/2022/06/03/19%E5%B2%81/</url>
      
        <content type="html"><![CDATA[<h1 id="歌曲全览"><a href="#歌曲全览" class="headerlink" title="歌曲全览"></a>歌曲全览</h1><h3 id="①生日快乐歌！-原创"><a href="#①生日快乐歌！-原创" class="headerlink" title="①生日快乐歌！(原创)"></a>①生日快乐歌！(原创)</h3><blockquote><p>歌名: 想与你相遇</p><p>歌词: 佳威</p><p>编曲(等于没有): 佳威</p><p>曲:佳威</p><p>演唱：佳威</p><p>大致内容:虽然取这个歌名会让人觉得有点像一首情歌的感觉?但是其实本人的寓意不是这样的，一直觉得相遇表达的意思非常非常的多，也许不需要人与人面对面的相遇，其实只要在某种程度上，能够达到无论是自己慢慢便强大朝着既定的目标逐步前进，抑或是真的能够有那么一个际遇，让两人现实中遇见，其实都是一种相遇吧。这首歌其实本来想写得比较唯美一点啊，伴奏乐器多一点，但是当时写的时候，越写越觉得应该把自己这一年来最真实的想法通过白话文的方式表达出来，所以词非常直白，曲非常单调，伴奏也只用了一些简单的和弦，因为录音设备的缘故，所以整体听起来可能不是那么协调吧，但是这首歌写出来其实更多的还是一种自己内心的表达吧，反正写完之后自己每次听，感触都挺大的！</p></blockquote><p><font color="blue">因为无法转成外链，所以就放到全民k歌去了哈哈哈！下面是链接:</font></p><ul><li><a href="https://kg3.qq.com/node/lVL5C619sN/play_v2?s=-zheYZ-IB6AW2-5Q&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724614__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">《想与你相遇》</a></li></ul><img src="https://s2.loli.net/2022/06/03/j23aZUCLbPiHl1T.jpg" alt="这首歌的初稿" style="zoom:33%;"><br><h3 id="②爱大家，爱身边的每一个人！"><a href="#②爱大家，爱身边的每一个人！" class="headerlink" title="②爱大家，爱身边的每一个人！"></a>②爱大家，爱身边的每一个人！</h3><ul><li><a href="https://kg3.qq.com/node/gLy1O31GnV/play_v2?s=IGFvf7I-0JATiI5f&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724633__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">《爱你》</a></li></ul><blockquote><p>歌名：《爱你》</p><p>清唱：佳威</p><p>大致内容：就是最近特别洗脑的一首歌！灵魂的爱你两个字把我给唱肉麻了哈哈哈！</p></blockquote><br><h3 id="③只要是你，其他都没关系！"><a href="#③只要是你，其他都没关系！" class="headerlink" title="③只要是你，其他都没关系！"></a>③只要是你，其他都没关系！</h3><ul><li><a href="https://kg3.qq.com/node/P9jTyhu6w7/play_v2?s=0cW3AL0BIxf6808V&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724645__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">我喜欢上你时的内心活动</a></li></ul><blockquote><p>歌名：《我喜欢上你时的内心活动》</p><p>清唱：佳威</p><p>大致内容：循环播放了几个星期的歌，真的陈绮贞的歌就会让人有一种内心非常平静但是又不失浪漫的感觉。说真的在某个阶段的某个时候，真的有想过很久很久以后的生活。世界上七千个地方，我们要定居在哪里呢？我会问你你喜欢哪里，如果是你的话，还是会问你很多很多的问题。如果是你的话，今天的小溪很好看的消息我也想第一时间的分享给你。所以，只要是你的话，一切的一切都可以不仅仅是内心活动了吧。</p></blockquote><br><h3 id="④我们一定会！"><a href="#④我们一定会！" class="headerlink" title="④我们一定会！"></a>④我们一定会！</h3><ul><li><a href="https://kg3.qq.com/node/KM3y8SbYp8/play_v2?s=KAOrcHK_8pE2aKKD&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724660__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">一起向未来</a></li></ul><blockquote><p>歌名：《一起向未来》</p><p>翻唱：赟宝，佳威</p><p>大致内容：和赟宝录制的一首歌，刚开始的声音就是赟宝的声音，他的声线唱这首歌真的很四字弟弟也，他现实生活中就是这样比较的温柔又自带一些搞笑因子，合作非常愉快，虽然中途因为设备啊，声音等问题可整了好久，不过最终的效果还挺不错的！</p></blockquote><br><p><font color="red">下面两个歌是刚上高中的时候录的，非常辣耳朵，不过还挺有意义的，希望通过博客记录下来。</font></p><h3 id="⑤非常中二的十五岁！"><a href="#⑤非常中二的十五岁！" class="headerlink" title="⑤非常中二的十五岁！"></a>⑤非常中二的十五岁！</h3><ul><li><a href="https://kg3.qq.com/node/B3RO1eC8X4/play_v2?s=Ws0Q7fWjLr9WVWkX&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724727__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">十七</a></li></ul><blockquote><p>歌名：《十七》</p><p>翻唱：佳威</p><p>大致内容：这首歌其实当时是上高中的时候，刚高一的时候有一些叛逆，十五岁就去给十七岁唱歌了，也是不知道为什么要那么急，怎么说呢，还有15岁之前的傻瓜作品，自己在整理的时候每当我听到以前的声音的时候，我其实还是会经常性的提起自己的以前。以前的时候真的很单纯很单纯，是什么样就是什么样，自己内心的感受(喜欢，难过，开心……)从来也没有藏着掖着，但是当时都是通过行动，不是一个特别会说的孩纸，所以真的重新听了一下歌前面的旁白，真的就很中二，但是我即使放到现在也不会觉得特别尴尬，因为当时我真的就是那么想的！</p></blockquote><br><h3 id="⑥感谢遇见的每一个人！"><a href="#⑥感谢遇见的每一个人！" class="headerlink" title="⑥感谢遇见的每一个人！"></a>⑥感谢遇见的每一个人！</h3><ul><li><a href="https://kg3.qq.com/node/c4yo65r6dA/play_v2?s=Ws0Q7fWjLvEZtWcb&shareuid=609a998d2d2b358a35&topsource=a0_pn201001006_z11_u274886211_l0_t1653724753__&chain_share_id=aHufrqVs4kp8atuzSGwARformGqQhmk9-I8OQ4BP6mo&pageId=details_of_creations">因为遇见你</a></li></ul><blockquote><p>歌名：《因为遇见你》</p><p>翻唱：佳威</p><p>大致内容：其实当时这首歌是写给我高一刚开始对我影响比较大的学长的。当看到这篇博客的uu们肯定肯定和我已经比较熟了，然后呢，也觉得不管怎么样，能够遇见就是一个非常大的缘分，所以我觉得特别特别的感谢。虽然在生活中，有一些相遇最后都成为了不太好的际遇，但是怎么说呢，每一次的不管是好是坏，觉得还是让一个人多多少少的成长了！所以还是很感谢很感谢。最后，希望自己做自己了，不再去伪装自己，找到原本最真实的自己，迎接后面的每一次相遇！</p></blockquote><br><h1 id="生日文案"><a href="#生日文案" class="headerlink" title="生日文案"></a>生日文案</h1><p>往年的生日的第一句话永远是祝我，祝你生日快乐。今年的话很幸运又可以多祝一个人生日快乐了(露宝)。每次都会想很久很久的生日文案，想总结一下一年来啊遇到了什么新鲜事情和很好的朋友。但是今年的话感觉真的除了在家就是在家，所以反而让自己更加的想着说，要不就回忆一下从前吧。所以在家的时候经常会翻起以前的照片来看，看一下过去的自己。一直在问他，你当时许下的愿望，如今实现了多少。就还挺感叹的，从之前的某个阶段(大概是从初三开始吧)，性格从内向慢慢的打开，随着其接踵而至的是，内心也开始变得不如从前的平静。青春期的各种不懂事猛然而生。其实直到大学我都感觉在某些方面的特别不理智。也有一直想着去控制，但是还是很难真的去抑制自己内心的一个情感。虽然性格变得好像还不错了，但是内心的一些幼稚，直白一直没有能够压下去。所以无论是在处理事情抑或是处理一段关系上，总会在现在的自己看来是一个小丑。这几年来，让我感到比较遗憾的很多事情，其实感觉更多的是人际关系带来的，反而不是之前一直很在乎的成绩。之前看过《被讨厌的勇气》，那一本书其实对我来说影响真的挺大的，但是即使能够很清楚的知道他其中的道理，但是在有的时候还是忍不住去做让自己讨厌自己的东西。比如书中有谈到，人生气的时候其实是没有原因的，而是取决于你的目的，而生气的目的其实就在于想要让被生气的对象认可你并且在某种程度上屈服于你。其实每次因为一些没必要的生气而生气的时候，脑子里面一直回想着这个观点，但还是生气了。又比如，书中有一句话说:你是你地图的中心，所以不用在乎别人怎么看你。但是每次心有不甘或者想要别人觉得自己很厉害的时候，又总会很刻意很刻意的伪装自己，有的时候真的自己也不太知道自己的面貌了 。但是无论是哪一个阶段或者再怎么绝望，我觉得我还是特别特别的幸运的，因为和我生日同一天的她还是一如既往的在前面。‘以前一直觉得一定一定要和她站在一起才行，但是好像越长越大，这样的想法也没越来越没有那么强烈了其实。不知道uu们有没有在你们的生活中出现那么一个人吧，就是也许你们互相不熟悉，仅仅是生活中压根可能不会碰面的人。但是就是因为言语之外的温存让你总能回想的起，其实我也不确定是不是我幻想得太多了，但是放下很多的幻想，我依然还是想在某种程度上能够和她相遇吧。因此为了这样的目标，我觉得很多情况下自己的努力还是会战胜内心的懒惰，我希望能够看到自己的灯塔越来越亮，即使我永远到不了也没关系的。最后呢希望自己继续被照亮着前行吧！</p>]]></content>
      
      
      <categories>
          
          <category> 生活篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结7</title>
      <link href="/2022/05/15/%E5%91%A8%E6%80%BB%E7%BB%937/"/>
      <url>/2022/05/15/%E5%91%A8%E6%80%BB%E7%BB%937/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的<strong>CSDN博客地址</strong>：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！上周事情贼多，然后又加上周日的时候又在考试，所以上周的总结放到这周一起吧，虽然已经忘记了上周干了什么了哈哈哈！</p><p><font color="red">三叶姐也搭配了hexo地址，在这里强烈推荐<a href="https://sharingsource.github.io/about/">三叶姐的hexo</a></font></p><h3 id="二、算法学习"><a href="#二、算法学习" class="headerlink" title="二、算法学习"></a>二、算法学习</h3><p>这两周，总体来说，好像还是学了很多的算法的，也有蛮多是复习的！</p><p><font color="blue">下面是一些能想到学的和复习的算法</font></p><ol><li>最长公共子序列问题</li><li>最长上升子序列问题</li><li>与质数相关的问题(质数筛选，分解质因子)</li><li>dfs(邻接表存图，树的重心问题)</li><li>bfs(邻接表存图，树的层次问题)</li><li>拓扑排序(先处理入度为0的点)</li><li>并查集(路径压缩，有一道超级难的食物链问题)</li><li>字典树(Trie数):用二维数组模拟，idx表示节点</li><li>KMP算法(其实就是自己匹配自己)</li><li>字符串哈希，用unsigned long long 自动取余，经验值：131转换进制，好像还学了一个叫前缀哈希的东西，记得要减前缀的时候进行左移</li><li>堆排序(down操作，up操作，包括如果要维护第k个插入的数，有一个heap_swap操作！)</li></ol><p><strong>这么看来，这两周学的东西有点多啊，但是还是感觉没能够对模板熟记于心，每次看y总写代码的时候，就感觉特别得心应手，什么时候才能有这样一半的水平啊，好好的背模板吧！</strong></p><h3 id="三、Linux操作系统学习"><a href="#三、Linux操作系统学习" class="headerlink" title="三、Linux操作系统学习"></a>三、Linux操作系统学习</h3><ol><li>巩固了一下tmux和vim的相关用法</li><li>学了shell语法，然后内容比较多，已经在开始复习，后边会进行相关的复习！</li></ol><h3 id="四、生活"><a href="#四、生活" class="headerlink" title="四、生活"></a>四、生活</h3><p>感觉这两周虽然很忙，然后学校的内容很多很多吧，但是好像这两周心态调整的特别好哈哈，虽然每天都在熬夜，有的时候甚至4-5点才睡觉，但是一点也不累，还是比较放松一点的，我觉得好像就是放下了很多很多包袱就会特别放松。这两周也尝试了很多很多的方式，包括自己开一些腾讯会议和同学们去交流一些东西，自己也准备了很多开会用的东西，也希望能够把自己想讲的东西更好的能够传输出去。会议后得到的反馈也非常不错，目前来说，感觉非常好。然后也交了不少的朋友，只能说还蛮有成就感的吧。最开心的当然也是本周末的时候出去看了一个非常好看的电影，只能说真的非常好看，剧情无限反转，惊心动魄的感觉了属于是。然后还进到了5-6年都没进去好好吃过一餐的KFC，我再也不想因为痘痘满脸都是吃不到好吃的东西了，不过确实好贵啊，也正是因为贵，吃不了太多东西，我就没有长胖，这属于是回报性消费了对吧哈哈啊哈哈哈！嗯嗯呢，没想到因为疫情，周总结这个栏目直接在家里面写了整整已经2-3个月了哈哈哈，只能说，感触很大，就是觉得虽然作为一个程序员，好像每天对着电脑写写博客啊，写写算法啊，然后写一些工程，学一些框架就够了，但是总是还是会感受到身边少了一些什么东西吧，不知道在家的时间还需要持续多久吧，但是我真的非常非常希望赶快能够和好朋友们聚在一起，一起玩游戏，一起吃大餐，一起拼搏，因为那样的感觉真的真的非常非常的好，呜呜呜呜。最后的话，希望疫情早日结束，我们一起回到最初的美好吧！</p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法(4)</title>
      <link href="/2022/05/09/shell%E8%AF%AD%E6%B3%95-4/"/>
      <url>/2022/05/09/shell%E8%AF%AD%E6%B3%95-4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、文件重定向"><a href="#一、文件重定向" class="headerlink" title="一、文件重定向"></a>一、文件重定向</h1><p>每个进程默认打开3个文件描述符：</p><ul><li><code>stdin</code>：标准输入，从命令行读取数据，文件描述符为0</li><li><code>stdout</code>：标准输出，从命令行输出数据，文件描述符为1</li><li><code>stderr</code>：标准错误输出，向命令行输出数据，文件描述符为2</li></ul><p>可以用文件重定向将这三个文件重定向到其他的文件当中</p><h3 id="①重定向命令列表"><a href="#①重定向命令列表" class="headerlink" title="①重定向命令列表"></a>①重定向命令列表</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">command &gt; file</td><td align="center">将stdout重定向到file文件内</td></tr><tr><td align="center">command &lt; file</td><td align="center">将stdin重定向到file文件内</td></tr><tr><td align="center">command &gt;&gt; file</td><td align="center">以stdout的形式追加到file文件内</td></tr><tr><td align="center">command n &gt; file</td><td align="center">将文件描述符n重定向到file中</td></tr><tr><td align="center">command n &gt;&gt; flie</td><td align="center">将文件描述符n追加到file文件中</td></tr></tbody></table><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo -e &quot;Hello \c&quot; &gt; output.txt  #将Hello重定向输出到fileecho &quot;World&quot; &gt;&gt; output.txt #将World追加到文件后read str &lt; output.txt #将文件的内容读给strecho $str #输出Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="同时重定向输入输出"><a href="#同时重定向输入输出" class="headerlink" title="同时重定向输入输出"></a>同时重定向输入输出</h4><p>创建bash脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashread aread becho $(expr &quot;$a&quot; + &quot;$b&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建input.txt,脸面的内容为</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.sh   #添加可执行操作acs@2ba77538d358:~$ test.sh &lt; input.txt &gt; output.txt  acs@2ba77538d358:~$ cat output.txt   #里面内容为77<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="引入外部脚本"><a href="#引入外部脚本" class="headerlink" title="引入外部脚本"></a>引入外部脚本</h1><p>类似于c引入一个头文件</p><p>语法格式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">. filename  #注意有一个空格或者source filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><font color="blue">举一个例子</font></p><p>比如先创建一个bash脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ vim test1.sh#然后在vim里面写东西#！ &#x2F;bin&#x2F;bashname&#x3D;wjw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再创建一个新的脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ vim test2.sh#然后在vim里面写东西#！ &#x2F;bin&#x2F;bashsource test1.shecho $name  #会输出wjw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux系统课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法(3)</title>
      <link href="/2022/05/09/shell%E8%AF%AD%E6%B3%95-3/"/>
      <url>/2022/05/09/shell%E8%AF%AD%E6%B3%95-3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、判断语句"><a href="#一、判断语句" class="headerlink" title="一、判断语句"></a>一、判断语句</h1><h3 id="①if…them形式"><a href="#①if…them形式" class="headerlink" title="①if…them形式"></a>①if…them形式</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if conditionthen语句1语句2fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]thenecho $&#123;a&#125;在范围内fi#输出，3在范围内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②单层if-else"><a href="#②单层if-else" class="headerlink" title="②单层if-else"></a>②单层if-else</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if conditionthen语句1语句2else语句1语句2fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4if ! [&quot;$a&quot; -lt &quot;$b&quot;]echo $&#123;a&#125;不小于$&#123;b&#125;elseecho $&#123;a&#125;小于$&#123;b&#125;fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③多层if-else"><a href="#③多层if-else" class="headerlink" title="③多层if-else"></a>③多层if-else</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if conditionthen语句elif conditionthen语句else then语句fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④case语句"><a href="#④case语句" class="headerlink" title="④case语句"></a>④case语句</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">case 变量($a) in1)语句;;2)语句;;*)语句;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a>二、循环结构</h1><h3 id="①-for-var-in-v1-v2-v3"><a href="#①-for-var-in-v1-v2-v3" class="headerlink" title="① for var in v1 v2 v3"></a>① for var in v1 v2 v3</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#命令格式for var in v1 v2 v3do语句1语句2done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">for i in a 2 ccdoecho $idone#输出a &#x2F;n 2 &#x2F;n cc#------------------------for file in &#39;ls&#39;(&#39;&#39;表示获取某个命令的stdout结果,等同于$())doecho $filedone#输出当前目录下的文件名#------------------------for i in $(sec 1 10)doecho $idone#输出1-10#------------------------for i in (1..20)  #可以输出字母，也可以反向输出doecho $idone#输出1-20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②for-…-…-…"><a href="#②for-…-…-…" class="headerlink" title="②for ((…; …; …))"></a>②for ((…; …; …))</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">for ((i &#x3D; 1; i &lt;&#x3D; 10; i++))doecho $idone#输出1-10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③while…do…done"><a href="#③while…do…done" class="headerlink" title="③while…do…done"></a>③while…do…done</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">while read namedoecho $namedone#读取什么就输出什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④untill…do…done"><a href="#④untill…do…done" class="headerlink" title="④untill…do…done"></a>④untill…do…done</h3><blockquote><p>当条件为真的时候才结束,否则一直循环,当然可以直接用Ctrl + c直接杀死现在的进程！</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">untill [ &quot;$&#123;word&#125;&quot; &#x3D;&#x3D; &quot;yes&quot; ]doread -p &quot;please input yes&quot; worddone#只有当用户输入yes的时候才会结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⑤死循环的处理方式"><a href="#⑤死循环的处理方式" class="headerlink" title="⑤死循环的处理方式"></a>⑤死循环的处理方式</h3><ol><li>如果终端可以打开该程序，输入<code>Ctrl +  c</code>就可以结束了！</li><li><ul><li>使用top命令找到该进程的PID，也就是第一列的数字</li><li>输入<code>kill -9 PID</code>即可关掉这个进程</li></ul></li></ol><h1 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h1><p><code>bash</code>中的函数类似于c中的函数，但是返回值是<code>exit code</code></p><p>如果想要获取函数最后的一个stdout的结果，可以通过<code>echo</code>输出到<code>stdout</code>中然后通过<code>$&#123;function_name&#125;</code>来获取stdout中的结果。</p><p>如果不写<code>return</code>的时候默认<code>return 0</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#示例1func() &#123;name&#x3D;wjwecho &quot;hello $name&quot;&#125;func #直接调用，输出hello wjw#示例2func() &#123;name&#x3D;wjwecho &quot;$name&quot;return 123&#125;output&#x3D;$(func)   #保存wjwret&#x3D;$? #保存123#示例3func() &#123;if [$1 -le 0]thenecho 0return 0fisum&#x3D;$(func &#39;expr $1 - 1&#39;)echo $(expr $sum + $1)&#125;echo $(func 10) #递归输出从0-10的累加和！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、exit命令"><a href="#四、exit命令" class="headerlink" title="四、exit命令"></a>四、exit命令</h1><ul><li><code>exit</code>命令用来退出当前<code>shell</code>进程，并返回一个退出状态</li><li><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态，如果不指定，默认为0</li><li>退出状态只能介于0-255之间的整数，只有0代表正常退出</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashif [ $# -ne 1 ] #如果参数等于1就正常退出，不等于1就非正常退出thenecho &quot;NO&quot;exit 1elseecho &quot;YES&quot;exit 0fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">如果执行该脚本</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.shacs@2ba77538d358:~$ .&#x2F;test.sh wjw 18acs@2ba77538d358:~$ echo $?  #输出的是1acs@2ba77538d358:~$ .&#x2F;test.sh wjwacs@2ba77538d358:~$ echo $?  #输出的是0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux系统课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法(2)</title>
      <link href="/2022/05/06/shell%E8%AF%AD%E6%B3%95-2/"/>
      <url>/2022/05/06/shell%E8%AF%AD%E6%B3%95-2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、expr命令"><a href="#一、expr命令" class="headerlink" title="一、expr命令"></a>一、expr命令</h1><p><code>expr</code> 命令用户求表达式的值，格式如下</p><blockquote><p>expr 表达式</p></blockquote><p>表达式说明</p><ul><li>用空格隔开每一项</li><li>用\去转义一些特定字符</li><li>对包含空格和其他特殊字符的字符串要用引号括起来</li><li>最后是返回到stdout(标准输出)中输出结果：所以用$(command) 或者 ‘commmand’进行输出。</li><li>不仅会输出一个结果，同时也会有一个返回值(0代表真，1代表假)</li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">str&#x3D;“Hello World”echo &#39;expr length &quot;$str&quot;&#39;  #输出字符串长度12echo &#39;expr index &quot;$str&quot; aWd&#39; #输出aWd任一个字符最先出现的位置，这里就是W出现在7(下标从1开始),如果找不到就输出0echo &#39;expr substr &quot;$str&quot; 2 3&#39; #输出ell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="①整数表达式"><a href="#①整数表达式" class="headerlink" title="①整数表达式"></a>①整数表达式</h3><p><code>expr</code> 支持普通的算数操作！</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4echo &#39;expr $a + $b&#39; #输出7echo &#39;expr $a \* $b&#39; #输出12echo &#39;expr $a % $b&#39; #输出3echo &#39;expr \( $a + 1 \) \* \( $b + 1 \)&#39; #输出20，等同于(3+1)*(4+1)#除号，加号，减号，取模号都不需要转义#也可以用单引号让其识别不为关键字#比如&#39;expr $a &#39;*&#39; $b&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②逻辑表达式"><a href="#②逻辑表达式" class="headerlink" title="②逻辑表达式"></a>②逻辑表达式</h3><p>和c++大致相同，但是返回值有点点不同，比如|，&amp;两个返回的不仅仅是0或1</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a&#x3D;3b&#x3D;4c&#x3D;0d&#x3D;5echo &#39;expr $c \&amp; $d&#39;  #输出0不再计算decho &#39;expr $a \&amp; $b&#39;  #输出a的值,返回3echo &#39;expr $c \| $d&#39;  #输出d的值,返回4echo &#39;expr $a \| $b&#39;  #输出a的值,不再计算b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、read命令"><a href="#二、read命令" class="headerlink" title="二、read命令"></a>二、read命令</h1><p>从stdin里面读入单行数据,当读到文件结束符<code>Ctrl + d</code>的时候返回<code>exit code</code>,为1则继续读，为0则正常退出！</p><p>参数说明</p><ul><li>-p : 后面可以接提示的信息</li><li>-t : 后面跟秒数，超过该秒数后会自动忽略此行命令</li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashread -p &quot;Please input your name: &quot; -t 30 name #读入用户名，等待30s，用户不输入，自动跳过此命令#echo &quot;hello,$name&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么在终端进行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ .&#x2F;test.shacs@2ba77538d358:~$ Please input your name: #提示用户输入acs@2ba77538d358:~$ wjw #用户进行输入(若30s内不输入则代表name为空，进入下一行命令)acs@2ba77538d358:~$ hello,wjw  #标准输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、echo命令"><a href="#三、echo命令" class="headerlink" title="三、echo命令"></a>三、echo命令</h1><h3 id="①显示普通字符串"><a href="#①显示普通字符串" class="headerlink" title="①显示普通字符串"></a>①显示普通字符串</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo wjw    #引号可以省略echo &quot;wjw&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="②显示转义字符"><a href="#②显示转义字符" class="headerlink" title="②显示转义字符"></a>②显示转义字符</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo &quot;\&quot;hello\&quot;wjw&quot;  #输出“hello”wjwecho \&quot;hello\&quot;wjw    #不加外面引号也可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="③显示换行"><a href="#③显示换行" class="headerlink" title="③显示换行"></a>③显示换行</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo -e &quot;hi\nwjw&quot;  #-e开启转义#可以在终端用 man echo 打开帮助命令，查看一些参数#最后输出hiwjw# -c 强制不换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④显示结果到文件内"><a href="#④显示结果到文件内" class="headerlink" title="④显示结果到文件内"></a>④显示结果到文件内</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ .&#x2F;test.shacs@2ba77538d358:~$ echo &quot;hello,world&quot; &gt; temp.txt#此时会在temp.txt多一个hello，world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="四、printf命令"><a href="#四、printf命令" class="headerlink" title="四、printf命令"></a>四、printf命令</h1><p><font color="red">此命令可能用的不是特别多</font></p><p>和c语言的差不多，只不过用空格去表示括号的内容</p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">printf &quot;%10d!\n&quot; 123printf &quot;%.2f!\n&quot; 123.2345print &quot;My name is %s\n&quot; &quot;wjw&quot;  #字符串输出printf &quot;%d * %d &#x3D; %d\n&quot; 2 3 &#39;expr 2\* 3&#39;  #表达式的值作为参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">输出结果</font></p><blockquote><p>​       123!</p><p>123.23</p><p>My name is wjw</p><p>2 * 3 &#x3D; 6</p></blockquote><h1 id="五、test命令"><a href="#五、test命令" class="headerlink" title="五、test命令"></a>五、test命令</h1><h3 id="①逻辑运算符-amp-amp-和-bash里面自带的"><a href="#①逻辑运算符-amp-amp-和-bash里面自带的" class="headerlink" title="①逻辑运算符&amp;&amp;和||(bash里面自带的)"></a>①逻辑运算符&amp;&amp;和||(bash里面自带的)</h3><ul><li>两者均有短路的特性（用来实现类似if，else的功能）</li><li>表达式最终的结果返回退出状态，<font color="red">如果为0则真，反之1则假!</font></li></ul><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.shacs@2ba77538d358:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; #输出existacs@2ba77538d358:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; #输出not exist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>test命令用于判断文件的类型，以及对变量做比较。</p><p>test命令用<font color="red">exit code</font>作为返回状态！<font color="red">如果为0则真，反之1则假!</font></p></blockquote><h3 id="②命令格式"><a href="#②命令格式" class="headerlink" title="②命令格式"></a>②命令格式</h3><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">文件是否存在</td></tr><tr><td align="center">-f</td><td align="center">是否是文件</td></tr><tr><td align="center">-d</td><td align="center">是否是目录</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.shacs@2ba77538d358:~$ test -e test.shacs@2ba77538d358:~$ echo $? #返回上个命令的返回状态，输出0代表文件存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">文件是否可读</td></tr><tr><td align="center">-w</td><td align="center">文件是否可写</td></tr><tr><td align="center">-x</td><td align="center">文件是否可执行</td></tr><tr><td align="center">-s</td><td align="center">文件是否为空</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework test.sh output.txtacs@2ba77538d358:~$ test -x output.txtacs@2ba77538d358:~$ echo $? #返回上个命令的返回状态，输出1代表文件是不可以执行的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">a是否等于b</td></tr><tr><td align="center">-ne</td><td align="center">a是否不等于b</td></tr><tr><td align="center">-gt</td><td align="center">a是否大于b</td></tr><tr><td align="center">-lt</td><td align="center">a是否小于b</td></tr><tr><td align="center">-ge</td><td align="center">a是否大于等于b</td></tr><tr><td align="center">-le</td><td align="center">a是否小于等于b</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ test $a -eq $b    #判断a是否等于bacs@2ba77538d358:~$ test 3 -lt 4acs@2ba77538d358:~$ echo $?  #返回0，代表3小于4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-z CHAR</td><td align="center">判断字符串是否为空，为空则真</td></tr><tr><td align="center">-n CHAR</td><td align="center">判断字符串是否为非空，为非空则真，-n可以省略</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">判断两个字符串是否相等，相等为真</td></tr><tr><td align="center">!&#x3D;</td><td align="center">判断两个字符串是否不相等，不相等为真</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ test -z &quot;wjw&quot; &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出N，代表非空acs@2ba77538d358:~$ test -n &quot;wjw&quot; &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出Y，代表非空acs@2ba77538d358:~$ s1&#x3D;yxcacs@2ba77538d358:~$ s2&#x3D;wjwacs@2ba77538d358:~$ test &quot;s1&quot; &#x3D;&#x3D; &quot;s2&quot; &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出N，代表两个字符串不相等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">测试参数</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">两条件是否同时成立</td></tr><tr><td align="center">-o</td><td align="center">两条件是否至少一个成立</td></tr><tr><td align="center">!</td><td align="center">取反，如test ! -x test.txt,不可执行返回真</td></tr></tbody></table><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ ls #显示当前路径下的文件homework.txt test.shacs@2ba77538d358:~$ test -x test.sh -a -r homework.txtacs@2ba77538d358:~$ echo $?   #返回0，代表第一个文件可读，第二个文件可以执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③判断符号"><a href="#③判断符号" class="headerlink" title="③判断符号[]"></a>③判断符号[]</h3><p>与test的用法几乎是一模一样的，更常用与if语句之中,<font color="red">括号和命令之间也要加空格</font></p><p><font color="blue">例如</font></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ [ 2 -lt 3 ]acs@2ba77538d358:~$ echo $?  #返回0代表2是小于3的acs@2ba77538d358:~$ [ &quot;s1&quot; &#x3D;&#x3D; &quot;s2&quot; ] &amp;&amp; echo &quot;T&quot; || echo &quot;N&quot;#输出N，代表两个字符串不相等注意name&#x3D;wjw wing#不能直接用[ $name &#x3D;&#x3D; &quot;wjw wing&quot;]#需要加上双引号，把空格包含[ “$name” &#x3D;&#x3D; &quot;wjw wing&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux系统课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法(1)</title>
      <link href="/2022/05/06/shell%E8%AF%AD%E6%B3%95-1/"/>
      <url>/2022/05/06/shell%E8%AF%AD%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h1><p><font color="red">本篇好像在hexo网站看不了，请移步到CSDN网站观赏！！！！</font><a href="https://blog.csdn.net/qq_60556896/article/details/124619776?spm=1001.2014.3001.5502">CSDN网站入口</a></p><p>shell是我们通过命令行与操作系统沟通的语言。可以直接在命令行中运行，也可以将一套逻辑组织成一个文件，方便复用。</p><p>linux系统默认使用bash脚本</p><h3 id="①vim-test-sh文件之后-创建一个文件"><a href="#①vim-test-sh文件之后-创建一个文件" class="headerlink" title="①vim test.sh文件之后(创建一个文件)"></a>①<strong>vim test.sh</strong>文件之后(创建一个文件)</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#首行指明bash为默认的脚本解释器#! &#x2F;bin&#x2F;bash#输出hello worldecho &quot;hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②运行方式"><a href="#②运行方式" class="headerlink" title="②运行方式"></a>②运行方式</h3><ol><li><p>bash + 文件名 ： bash test.sh</p></li><li><p>当 ls -l test.sh之后，会发现只有r,w的读写可以进行，需要先加入一个可以执行的操作</p><ul><li>chmod +x test.sh</li></ul><p>如果在当前路径的话: .&#x2F;test.sh</p><p>可以用绝对路径: &#x2F;home&#x2F;acs&#x2F;test.sh</p><p>也可以用相对路径:  ~&#x2F;test.sh #家目录下执行</p></li></ol><h1 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h1><h3 id="①单行注释"><a href="#①单行注释" class="headerlink" title="①单行注释"></a>①单行注释</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 这是一行注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="②多行注释"><a href="#②多行注释" class="headerlink" title="②多行注释"></a>②多行注释</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">:&lt;&lt;EDF注释1注释2注释n&lt;&lt;EOF# EOF可以用其他任意字符串都可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h3 id="①定义变量"><a href="#①定义变量" class="headerlink" title="①定义变量"></a>①定义变量</h3><p>定义变量不需要加$符号</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name1&#x3D;&quot;wjw&quot; #定义变量等号两边不能有空格name2&#x3D;&#39;wjw&#39; #单引号也可以定义name3&#x3D;wjw #也可以不加引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②使用变量"><a href="#②使用变量" class="headerlink" title="②使用变量"></a>②使用变量</h3><p>使用变量的时候需要加上$或者 加上一个{};</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjw #定义变量echo $&#123;name&#125; #输出wjwecho $&#123;name&#125;hhh #输出wjwhhh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="③只读变量"><a href="#③只读变量" class="headerlink" title="③只读变量"></a>③只读变量</h3><p>变量的值是没办法改变的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjwreadonly name #第一种写法declare -r name #第二种写法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="④删除变量"><a href="#④删除变量" class="headerlink" title="④删除变量"></a>④删除变量</h3><p>用unset可以删除变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjwunset nameecho $name #输出空行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑤变量类型"><a href="#⑤变量类型" class="headerlink" title="⑤变量类型"></a>⑤变量类型</h3><ul><li>自定义变量(局部变量)<ul><li>子进程不能访问的变量</li></ul></li><li>环境变量(全局变量)<ul><li>子进程可以访问的变量</li></ul></li></ul><p>自定义变量改成环境变量(下面是在终端下进行操作)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ name&#x3D;wjw #定义变量acs@2ba77538d358:~$ export name #第一种方式acs@2ba77538d358:~$ declear -x name #第二种方式acs@2ba77538d358:~$ exit #退出当前进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>环境变量改成自定义变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ export name&#x3D;wjw #定义环境变量acs@2ba77538d358:~$ declear +x name #改为自定义变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开一个子进程</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ bash #开一个子进程#在子进程下，只可以访问环境变量acs@2ba77538d358:~$ exit 或者 [Ctrl + d]都可以退出子进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="⑥字符串"><a href="#⑥字符串" class="headerlink" title="⑥字符串"></a>⑥字符串</h3><p>单引号：原样输出，不会转义，也不会直接取值</p><p>双引号：(不加引号) 会转义也会取值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;wjwecho &#39;hello,$name \&quot;hh\&quot;&#39;    #输出hello,$name \&quot;hh\&quot;echo &quot;hello,$name \&quot;hh\&quot;&quot;    #输出hello,wjw &quot;hh&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取字符串长度</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;&quot;wjw&quot;echo $&#123;#name&#125;   #输出3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提取字串</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">name&#x3D;hello,wjwecho $&#123;name:0:5&#125; #提取从0开始的5个字符#此处的定义类似于c++的substring函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、默认变量"><a href="#四、默认变量" class="headerlink" title="四、默认变量"></a>四、默认变量</h1><h3 id="①文件参数变量"><a href="#①文件参数变量" class="headerlink" title="①文件参数变量"></a>①文件参数变量</h3><p>在执行shell脚本的时候，可以向脚本传递参数。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! &#x2F;bin&#x2F;bashecho &quot;文件名: &quot;$0echo &quot;第一个参数: &quot;$1echo &quot;第二个参数: &quot;$2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后如果执行该脚本的话：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">acs@2ba77538d358:~$ chmod +x test.shacs@2ba77538d358:~$ .&#x2F;test.sh wjw 18#后续会输出的是文件名: .&#x2F;test.sh第一个参数: wjw第二个参数: 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②其他默认参数变量"><a href="#②其他默认参数变量" class="headerlink" title="②其他默认参数变量"></a>②其他默认参数变量</h3><table><thead><tr><th align="center">参数</th><th align="center">参数的相关说明</th></tr></thead><tbody><tr><td align="center">$#</td><td align="center">代表文件传入的参数个数，如上面例子中的值为4</td></tr><tr><td align="center">$*</td><td align="center">由所有参数构成的用空格隔开的字符串，如“.&#x2F;test.sh wjw 18”</td></tr><tr><td align="center">$@</td><td align="center">每个参数用分别用双引号括起来，“.&#x2F;test.sh” “ wjw” “18”</td></tr><tr><td align="center">$$</td><td align="center">脚本当前运行的进程ID</td></tr><tr><td align="center"><strong>$?</strong></td><td align="center"><strong>上一条命令的退出状态，0表示正常，其他值表示错误</strong></td></tr><tr><td align="center"><strong>$(command)</strong></td><td align="center"><strong>返回command 这条命令的stdout(标准输出)</strong></td></tr><tr><td align="center"><strong>‘command’</strong></td><td align="center"><strong>返回command 这条命令的stdout(标准输出)</strong></td></tr></tbody></table><h1 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h1><p>数组可以存放多个不同类型的值，只支持一维数组，初始化不需要指明数组的大小</p><p><strong>下标从0开始</strong></p><h3 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">array&#x3D;(1 abc &quot;def&quot; wjw) #第一种方法array[0]&#x3D;1     #第二种方法array[1]&#x3D;abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="②读取并输出"><a href="#②读取并输出" class="headerlink" title="②读取并输出"></a>②读取并输出</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo $&#123;array[index]&#125;  #读取并输出(隔行输出)echo $&#123;array[@ or *]&#125; #读取整个字符串(空格输出)#没有开到的空间用不上，例如array[0]&#x3D;wjwarray[1000]&#x3D;18echo $&#123;array[*]&#125;  #打印结果为wjw 18echo $&#123;#array[*]&#125; #打印结果为2(代表数组元素个数)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux系统课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化操作</title>
      <link href="/2022/05/01/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/05/01/%E7%A6%BB%E6%95%A3%E5%8C%96%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、离散化操作"><a href="#一、离散化操作" class="headerlink" title="一、离散化操作"></a>一、离散化操作</h1><p>什么是离散化操作，这里给一个简单的解答。</p><blockquote><p>假设给你一个数组，元素有1,2,200,30000,400000。按照元素的个数，将最终的数组变成1,2,3,4,5的操作就是离散化。离散化的操作有什么好处呢？</p><p>如果数据非常大，但是元素的个数非常小。我们离散化操作就会节省空间，同时通过这样的操作能够让我们优化时间复杂度！</p></blockquote><h1 id="二、实现方法"><a href="#二、实现方法" class="headerlink" title="二、实现方法"></a>二、实现方法</h1><p>为了满足这样的要求(假设有n个数)，我们只需要让每一个数对应一个下标，而这个下标就是离散化他对应的区间$[1,n]$里面的某一个数！这里主要采用c++的实现操作！下面是具体的实现方法</p><h4 id="①开一个vector数组"><a href="#①开一个vector数组" class="headerlink" title="①开一个vector数组"></a>①开一个vector数组</h4><p>因为后面需要用到库函数，所以会更方便解题，但是其实用哈希表对应也是可以的！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; allis;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="②数据放入数组之中"><a href="#②数据放入数组之中" class="headerlink" title="②数据放入数组之中"></a>②数据放入数组之中</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">allis.push_back(x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③排序之后去重"><a href="#③排序之后去重" class="headerlink" title="③排序之后去重"></a>③排序之后去重</h4><p>去重的目的只为了之后在找数的时候没有重复的数！(其实不去重可能也可以过)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;排序去重    sort(allis.begin(), allis.end());&#x2F;&#x2F;去重的库函数    allis.erase(unique(allis.begin(), allis.end()), allis.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④查找数所在的位置，最后返回应该映射的那一个数"><a href="#④查找数所在的位置，最后返回应该映射的那一个数" class="headerlink" title="④查找数所在的位置，最后返回应该映射的那一个数"></a>④查找数所在的位置，最后返回应该映射的那一个数</h4><p>这里也用了库函数，但是其实就是一个简单的二分，因为排序之后的数组是递增的，所以二分查找加快速度！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int finds(int x) &#123;    int id;    &#x2F;&#x2F;找到第一个大于等于x的数    &#x2F;&#x2F;加1是为了让下标从1开始    id &#x3D; lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;    return id;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④举例分析"><a href="#④举例分析" class="headerlink" title="④举例分析"></a>④举例分析</h4><blockquote><p>假设给你一个数组，元素有1,200,2。我们的第三步操作就会让这个数组变成，1,2,200。假设后续操作遍历需要200的时候，我们就会先利用finds函数，返回3，从而，从头开始遍历的时候数组就会呈现出1，3，2的形式。</p></blockquote><h1 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h1><h3 id="（1）例题1：区间求和"><a href="#（1）例题1：区间求和" class="headerlink" title="（1）例题1：区间求和"></a>（1）例题1：区间求和</h3><p><img src="https://img-blog.csdnimg.cn/676ec2fb1b404c4a9eec4670d784d133.png" alt="区间求和"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这一题乍一看其实就是一个前缀和，然后最后区间查询用前缀和的思想就好了。但是本题的难点就在区间和数的范围都是几乎接近了一个int的大小，如果我们直接用前缀和，从头到尾遍历一遍，首先数组不可能开那么大，其次是即使是O(N)的时间复杂度，因为N过大，也必然会超时。<font color="red">但是我们发现，n和m的值比较的小，所以从他们入手，把我们所有输入的数都进行一个离散化，最后其实就相当于最多求一个(n + 2m)那么多次的一个前缀和！</font>因为输入的数字有n个，然后有2m个断点值(左端点和右端点)。因此如果我们把他们转化到一个非常小的区间去求前缀和，就变得非常的简单！所以套用之前的离散化操作，这里直接给出代码！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 300005;typedef pair&lt;int, int&gt; PII;vector&lt;int&gt; allis;vector&lt;PII&gt; add, query;int a[N], sum[N];int n, m;int finds(int x) &#123;&#125;    int id;    id &#x3D; lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;    return id;    &#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int x, c;        cin &gt;&gt; x &gt;&gt; c;        allis.push_back(x);        add.push_back( &#123;x, c&#125; );        &#125;    for(int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        allis.push_back(l);        allis.push_back(r);        query.push_back( &#123;l, r&#125; );        &#125;        &#x2F;&#x2F;排序去重    sort(allis.begin(), allis.end());    allis.erase(unique(allis.begin(), allis.end()), allis.end());        &#x2F;&#x2F; for(auto alli : allis) cout &lt;&lt; alli &lt;&lt; &quot; &quot;;        &#x2F;&#x2F;处理插入    for(auto item : add) &#123;&#125;        int s &#x3D; finds(item.first);        a[s] +&#x3D; item.second;        &#125;        &#x2F;&#x2F;前缀和    for(int i &#x3D; 1; i &lt;&#x3D; allis.size(); i++) &#123;        sum[i] &#x3D; sum[i - 1] + a[i];        &#125;        &#x2F;&#x2F;查询    for(auto item : query) &#123;        int l &#x3D; finds(item.first), r &#x3D; finds(item.second);        int ans &#x3D; 0;        ans &#x3D; sum[r] - sum[l - 1];        cout &lt;&lt; ans &lt;&lt; endl;        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）例题2：区间合并"><a href="#（2）例题2：区间合并" class="headerlink" title="（2）例题2：区间合并"></a>（2）例题2：区间合并</h3><p><img src="https://img-blog.csdnimg.cn/543283207df9411d8490deea79b3f0ed.png" alt="区间合并"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>因为区间合并的相关知识已经写过博客了，对区间合并不了解的uu们，可以点击这里去看看<a href="https://blog.csdn.net/qq_60556896/article/details/124435766?spm=1001.2014.3001.5501">区间合并的刷题</a>。那么这题就是在区间合并的前提下，加上一个离散化操作，所以非常的简单哈！</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 200000 + 10;PII p[N];vector&lt;int&gt; allis;vector&lt;PII&gt; query;int finds(int x) &#123;    return lower_bound(allis.begin(), allis.end(), x) - allis.begin() + 1;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    int count &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        allis.push_back(l);        allis.push_back(r);        query.push_back(&#123;l, r&#125;);    &#125;    &#x2F;&#x2F;去重排序    sort(allis.begin(), allis.end());    allis.erase(unique(allis.begin(), allis.end()), allis.end());    int t &#x3D; 0;    for(auto item : query) &#123;        int l &#x3D; finds(item.first), r &#x3D; finds(item.second);        p[t++] &#x3D; &#123;l, r&#125;;    &#125;    &#x2F;&#x2F;这个地方不能用sort(p.begin(),p.end());    sort(p, p + t);    int st &#x3D; -1, ed &#x3D; -1;    for(int i &#x3D; 0; i &lt; t; i++) &#123;        if(p[i].first &lt;&#x3D; ed) ed &#x3D; max(ed, p[i].second);        else &#123;            count++;            st &#x3D; p[i].first;            ed &#x3D; p[i].second;        &#125;    &#125;    cout &lt;&lt; count &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结6</title>
      <link href="/2022/05/01/%E5%91%A8%E6%80%BB%E7%BB%936/"/>
      <url>/2022/05/01/%E5%91%A8%E6%80%BB%E7%BB%936/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的<strong>CSDN博客地址</strong>：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、算法学习"><a href="#二、算法学习" class="headerlink" title="二、算法学习"></a>二、算法学习</h3><p>这周因为课内要准备复习，所以好像这周对课外的东西没有看特别多，所以还是以算法学习为主吧！上周认识到了ACwing这个网站，然后知识付费了一下，和朋友购买了一个算法的课程，还挺不错的，<strong>基本是模板题目但是还是常做常新！</strong></p><p><font color="red">下面是这周的一个算法小结(选取一些之前没有写过博客的模板粘上去)：</font></p><h5 id="①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！"><a href="#①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！" class="headerlink" title="①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！"></a>①快速排序：随机选择某个数，然后利用递归的思想，让那一个随机选择的数的左右两边分别是大于他的和小于他的，然后利用双指针和交换的方法！</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100000 + 5;void quick_sort(vector&lt;int&gt; &amp; q, int l, int r) &#123;    if(l &gt;&#x3D; r) return;    int m &#x3D; (l + r) &gt;&gt; 1;    int mid &#x3D; q[m];        int sd &#x3D; l - 1, ed &#x3D; r + 1;    while(sd &lt; ed) &#123;        do sd++; while(q[sd] &lt; mid);        do ed--; while(q[ed] &gt; mid);        if(sd &lt; ed) swap(q[sd], q[ed]);    &#125;    quick_sort(q, l, ed);    quick_sort(q, ed + 1, r);&#125;int main() &#123;    int n;    cin &gt;&gt; n;    vector&lt;int&gt; ss;    int num;    for(int i &#x3D; 0; i &lt; n; i++) &#123;        cin &gt;&gt; num;        ss.push_back(num);    &#125;    quick_sort(ss, 0, n - 1);    for(int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; ss[i] &lt;&lt; &quot; &quot;;&#125;作者：sheepice链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;3347542&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="②归并排序-加求逆序对-树状数组求逆序对："><a href="#②归并排序-加求逆序对-树状数组求逆序对：" class="headerlink" title="②归并排序(加求逆序对) + 树状数组求逆序对："></a>②归并排序(加求逆序对) + 树状数组求逆序对：</h5><p>两种方式都尝试了一遍，具体代码链接如下：</p><p><a href="https://www.acwing.com/activity/content/code/content/3348147/">树状数组和归并排序求逆序对</a></p><h5 id="③一维，二维前缀和-一维，二维差分"><a href="#③一维，二维前缀和-一维，二维差分" class="headerlink" title="③一维，二维前缀和 + 一维，二维差分"></a>③一维，二维前缀和 + 一维，二维差分</h5><h5 id="④离散化操作-解决了区间和以及区间合并-：这里之后会总结一篇博客的！"><a href="#④离散化操作-解决了区间和以及区间合并-：这里之后会总结一篇博客的！" class="headerlink" title="④离散化操作(解决了区间和以及区间合并)：这里之后会总结一篇博客的！"></a>④离散化操作(解决了区间和以及区间合并)：这里之后会总结一篇博客的！</h5><blockquote><p>本周(其实就这两天)刷算法挺上头的,只能说能力在慢慢提升，之前以为刷的题越多越好，但是其实应该是巩固最起码的模板题目，然后再谈刷题，所以非常推荐y总的《算法基础课》，虽然有点小贵，但是钱得花在刀刃上，不是吗哈哈哈！</p></blockquote><p><font color="blue">附上这两天的刷题记录，上面真的总结到位了：</font></p><p><img src="https://img-blog.csdnimg.cn/25ec5ea3dd5a4a29a816eca74caf5339.png" alt="基础课第一节打卡完成"></p><h3 id="三、运动"><a href="#三、运动" class="headerlink" title="三、运动"></a>三、运动</h3><p><strong>本周的话，采用了一种运动方式，和家人们一起运动打卡，然后也一起听着歌，跑跑步啥的，真的非常的不错！</strong></p><img src="https://img-blog.csdnimg.cn/26c86d0ca32c4dbeb1cfac15f054067c.png" alt="运动打卡" style="zoom:33%;"><h3 id="四、小倾诉"><a href="#四、小倾诉" class="headerlink" title="四、小倾诉"></a>四、小倾诉</h3><p><strong>这周的话，有过不愉快的交谈。其实起因就是自己一直坚持一个比较虚伪的自己吧。明明运气的不公让你觉得自己的努力白费了两年，然后就会为了满足自己内心深处的那一点点自尊和不甘，编出一个让自己心安理得的谎言。然后被狠狠地揭穿了，其实那一刻我内心是无比的内疚和自责的，一个怪自己明明早就已经接受了现实，却还是无法放下过去。一个怪自己明明知道那么多道理，却还是在人面前加厚着自己的外衣。不过真的感谢用火把纸烧出洞的人吧，也许没有这么一个人出现的话，以后永远没有办法去正视在那一方面的自己吧！只可惜很多事情一旦发生，还是会产生各种各样的不堪的后果。这个谎言以后也不会再说了，虽然没有伤害他人，但是却真正地虚伪了不是自己的“我”，希望自己再多努力努力，之后不再嫉妒努力，而是享受那些一起拼搏的日子吧！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing刷题1</title>
      <link href="/2022/04/26/AcWing%E5%88%B7%E9%A2%981/"/>
      <url>/2022/04/26/AcWing%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近发现一个算法题目的宝藏平台，上面的题目其实都是比较偏向应用题了，所以可能更适合用来提高自己笔试的能力。在这里还没有入口的uu们可以在这里看一看哦：<a href="https://www.acwing.com/about/">AcWing刷题网站</a></p><p>今天其实做了上周的周赛的一个题目，才发现自己很多基础的算法模板都没有掌握，所以只能说我算法还是没有真正的入门吧!今天其实也少稍微的学习了一下，关于区间合并的一个模板问题，题目描述如下：</p><h3 id="二、题目描述"><a href="#二、题目描述" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p><img src="https://img-blog.csdnimg.cn/a6fb2e10963448ab9c51e7bdd31459ba.png" alt="构造数组"></p><h3 id="三、思路"><a href="#三、思路" class="headerlink" title="三、思路"></a>三、思路</h3><p>本题的思路需要一些推导，也不是特别难，我们可以看到假设a数组中的$a_i &#x3D; a_j$的话，那么由于$b_{i + 1}$对于$b_i$来说只有两种可能，要不然和他相同，要不然比他大一，<font color="red">因此对于$a_i &#x3D; a_j$来说，b数组中下标为$[i,j]$必须满足$b_{i} &#x3D; b_j$所以这个区间所有的数字必须相同才能满足条件，那么按照这样的分法，我们是一定可以把一整个区间划分成不同的小段，假设我们划分成了m个小段，对于第一个小段来说，由于题目的限定，$b_0&#x3D;0$因此第一段只可能是0，那么接下来的每一段都有两种选择，要不然等于前面一段的数，要不然等于前面的数加1，因此最后的结果为$2^{m - 1}$。</font></p><p>而在划分区域的时候，我们要进行合并区域的操作，即两个有交集的区间应该取他们两个的并集才能够正确的划分最终的区段。</p><p><font color="blue">举个栗子：</font></p><blockquote><p>假设a[5] &#x3D; {1,2,1,2,3},我们在合并的时候假设要划分到1的时候区间为[0,2],而划分2的时候是[1,3],我们发现这两个区间需要b数组在两个区间内的值要相同，就必须把两个区间合并成为[0,3]即在这整个区间上的b数组的值必须都相同，最后才是最正确的答案，而合并区间的操作，可以利用两个哈希表来进行。</p></blockquote><h3 id="四、合并区间"><a href="#四、合并区间" class="headerlink" title="四、合并区间"></a>四、合并区间</h3><p>我觉得还是有必要说一下如何去合并区间呢？</p><p>①首先我们要开两个哈希表L,R。这两个表代表的含义分别是第i个区间的左边界和右边界。于是我们可以用下面的代码将这些边界预处理到我们的哈希表里面。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;好像有可能展示不出,大家知道这个地方是开一个哈希表就好map&lt;int, int&gt; L,R;   for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;       int a;   &#x2F;&#x2F;a代表数组的第i个数       cin &gt;&gt; a;       R[a] &#x3D; i;       if(!L.count(a)) L[a] &#x3D; i;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此在上面的操作之后，我们已经把区间的左边界和右边界预处理好了，接下来就是如何去合并区间呢？</p><p>②合并区间的话，<font color="blue">首先我们需要用一个pair键对将哈希表里面的第一个值存储下来，然后进行一个排序，这样可以让我们在判断区间是否合并的时候是从前往后一段一段的去进行的，就保证了答案的正确性。</font>在合并的过程中就不断的判断下一段的左边界和前一段的右边界的大小关系，从而确定两个集合是否有交集。这样说会有点难理解，所以直接给出代码，便于食用！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;m代表区间的数量，l表示前一段左边界，r表示前一段右边界int m &#x3D; 0, l &#x3D; -1, r &#x3D; -1;&#x2F;&#x2F;按照哈希表的第一个元素放到p数组里面for(auto&amp; [k, v] : L) &#123;    p[m++] &#x3D; &#123;L[k], R[k]&#125;;&#125;sort(p, p + m);int cnt &#x3D; 0;for(int i &#x3D; 0; i &lt; m; i++) &#123;    &#x2F;&#x2F;如果后一段的左边界比前一段的右边界还小    if(p[i].x &lt; r) r &#x3D; max(r, p[i].y);    &#x2F;&#x2F;否则已经进入到了下一个区间划分    else &#123;        cnt++;        l &#x3D; p[i].x;        r &#x3D; p[i].y;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后进行结果的输出就好了！</p><h3 id="五、AC代码"><a href="#五、AC代码" class="headerlink" title="五、AC代码"></a>五、AC代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 200050;const int mod &#x3D; 998244353;PII p[N];int main() &#123;    int n;    cin &gt;&gt; n;    &#x2F;&#x2F;这里可以用unordered_map速度会很快，但是可能会被TLE   &#x2F;&#x2F;解决方法就是给两个哈希表一个较大的存储值，比如300010;    &#x2F;&#x2F;好像有可能展示不出,大家知道这个地方是开一个哈希表就好    map&lt;int, int&gt; L,R;        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int a;        cin &gt;&gt; a;        R[a] &#x3D; i;        if(!L.count(a)) L[a] &#x3D; i;    &#125;    &#x2F;&#x2F;m代表区间的数量，l表示前一段左边界，r表示前一段右边界    int m &#x3D; 0, l &#x3D; -1, r &#x3D; -1;    &#x2F;&#x2F;按照哈希表的第一个元素放到p数组里面    for(auto&amp; [k, v] : L) &#123;        p[m++] &#x3D; &#123;L[k], R[k]&#125;;    &#125;        sort(p, p + m);    int cnt &#x3D; 0;    for(int i &#x3D; 0; i &lt; m; i++) &#123;        &#x2F;&#x2F;如果后一段的左边界比前一段的右边界还小        if(p[i].x &lt; r) r &#x3D; max(r, p[i].y);        &#x2F;&#x2F;否则已经进入到了下一个区间划分        else &#123;            cnt++;            l &#x3D; p[i].x;            r &#x3D; p[i].y;        &#125;    &#125;    int res &#x3D; 1;    for(int i &#x3D; 0; i &lt; cnt - 1; i++) &#123;       res &#x3D; res * 2 % mod;    &#125;    cout &lt;&lt; res &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> AcWing刷题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> AcWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结5</title>
      <link href="/2022/04/24/%E5%91%A8%E6%80%BB%E7%BB%935/"/>
      <url>/2022/04/24/%E5%91%A8%E6%80%BB%E7%BB%935/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、学习"><a href="#二、学习" class="headerlink" title="二、学习"></a>二、学习</h3><h5 id="①算法学习"><a href="#①算法学习" class="headerlink" title="①算法学习"></a>①算法学习</h5><p>其实说实话，这周主要栽在算法上面好久好久，就是记得之前的Carl哥说<font color="blue">算法这个东西就是你觉得一段时间你提升特别快，但是一旦做起题目来的话，你就会发现你压根啥也不会。这周真的非常真实的体会到这个东西，也彻底让自己感到自己在算法上确实是没有任何天赋了，所以有什么办法呢？</font>只好乖乖的积累，希望之后能顺利过大厂的一个面试题就好了吧！</p><p>这里<strong>主要总结一下这周遇到蛮多题目以及链接吧！</strong>其实大部分都是板子题目，但是一旦自己板子不熟悉，压根就不敢动手去写，就比如我到现在还没在力扣上做成功一个线段树的题目呜呜好难受。下面的链接便于之后回来看的时候能够重新做一些题目！</p><hr><p><strong><font color="red">题目分类及链接：</font></strong></p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">统计数组逆序对(树状数组解法)</a></p><p><a href="https://leetcode-cn.com/problems/count-good-triplets-in-an-array/">数组逆序对和顺序对一起统计</a></p><p><a href="https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/">树状数组离散化</a></p><p><a href="https://leetcode-cn.com/problems/QO5KpG/">线段树离散化</a></p><p><a href="https://leetcode-cn.com/problems/erect-the-fence/">二维凸包，数学向量叉乘</a></p><p><a href="https://leetcode-cn.com/problems/course-schedule-iii/">单调队列加贪心维护最值</a></p><hr><blockquote><p>上面的题目大多数是比赛的时候有思路但是最终还是没有写对的，而且我觉得也算是表面模板上比较好的题目，我觉得自己可以之后找个时间，多刷几遍，把模板再仔细的温习。我有个朋友从18年开始到2022年，一年去写一遍线段树的板子，说真的这些板子东西真的很重要！要不然就要我一样，压根不敢写板子，因为太不熟练了！</p></blockquote><h4 id="②操作系统粗学"><a href="#②操作系统粗学" class="headerlink" title="②操作系统粗学"></a>②操作系统粗学</h4><p>因为上周的时候操作系统就已经学到了信号量去空着各个进程的共享和互斥的作用。这周就主要还是学习一些用P,V操作去进行一些题目的理解吧。比如<font color="blue">多消费者，生产者问题，吸烟者问题，哲学家用餐问题。以及初学了管程，管程其实有点像类，对程序员显性，对用户隐性，而且也避免了去思索P，V操作的顺序等等的问题。</font>说个笑话，那个时候我真的想问，那为什么还要学信号量，只是为了考试吗哈哈哈！QAQ</p><h4 id="③英语"><a href="#③英语" class="headerlink" title="③英语"></a>③英语</h4><p>说真的着了魔一样，虽然自己英语真的很差，但是还是听不下英语课，上英语课的时候真的就很迷茫。老师总是会上课提问，但是不好意思的是，每次提问我的页面总是停留在某个算法题目，或者某个课内作业之上。然后一回答就社死。<font color="blue">不过幸运的是，因为自己的社牛吧！直接把英语课上有印象很活跃的东西都加了一遍，然后问各种作业，当然很开心的是，居然加上了一个广西的老乡，这可是在学校上了一个学期都没碰到的事情。只能说老乡见老乡两眼泪汪汪哈哈哈。</font>然后就是英语六级的复习，说复习也没复习，每天听六级听力，一篇文章听2-3遍才能够勉勉强强的听懂，<font color="red">不知道有没有英语听力很好的uu们分享一下英语听力的技巧啊，很欢迎跟本英语蒟蒻的小菜鸟分享一下。</font>希望英语六级的成绩能够稍微好看一点吧呜呜呜！然后就是翻译，我一个连口语都表达不清楚的人，做翻译还是有点痛苦，好多词会，但是一翻译就想不起来了，哇，真的好难好难！</p><h4 id="④总结学习"><a href="#④总结学习" class="headerlink" title="④总结学习"></a>④总结学习</h4><p>这周真的是学到难的一周！果然一个悖论说得没错，你学得越多，你会发现你知道的就越少呜呜！</p><hr><h3 id="三、运动"><a href="#三、运动" class="headerlink" title="三、运动"></a>三、运动</h3><p>这周的话还是有氧运动多一点吧，就还是每天去跑跑步然后跳跳绳之类的，但是这周可恶的天气，让我至少有3天没有去外边运动了，那几天还刚好学的做的东西挺难的然后加上上周比较emo，心态上就调整的不是很好吧！好在这周运动量蛮大，每次运动完一身的汗真的非常的舒服。</p><hr><h3 id="四、音乐"><a href="#四、音乐" class="headerlink" title="四、音乐"></a>四、音乐</h3><p>说真的，其实本来说自己这次寒假回来的时候，要多去学一些编曲啊，乐器啥的，但是真的热度就在前半个月，然后后面两个月，就是啥也没干。我得谢谢上周的emo吧，最起码上一周的emo让我知道我应该去做什么解决我的一些不好的情绪，所以这周开始去弹弹电子琴，吉他，然后哼一些自己内心的旋律，其实之前自己也写过歌，也发行了，虽然是帮别人写的，但是很可惜的是，自己写的词的那个本子不见了，那个时候也没把词哼成曲子，所以还是没有足够热爱吧感觉。<font color="blue">有的时候真的觉得挺奇怪的，因为我明明挺喜欢音乐，也挺希望创造出属于自己的作品，但是每次想去学一个和弦，弹一个曲子，总是进不到一个痴迷的状态，好像练了半个小时就干别的事情去了，似乎从中得到的乐趣真没有和朋友们打上几把游戏来得高涨。感觉时间规划和自己的内心管理真的真的有点不到位。</font></p><hr><h4 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h4><p>最后的话，我这周3天没出去运动就胖了6斤.(真的只胖脸呜呜呜！)</p><p>然后特别特别开心，居然在疫情的时候还能交到新朋友！</p><p>最近的疫情又愈发的严重了，希望uu们都能够戴好口罩，希望我们见面的时候一定还是那健康的我们。</p><p>下周要准备准备考试了，毕竟好久没听课，还是有点慌张！</p><p><strong>所以，下周见咯！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列初探</title>
      <link href="/2022/04/18/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/04/18/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>今天总结的一个东西叫做单调队列，其实单调队列这个名字一听就知道是跟数据结构有关。而之所以命名为这个，肯定说明了他代表队列里面的元素都是成为一个单调的形式存在在队列中的。今天主要介绍两种实现单调队列的方法吧。</p><p>首先考虑这样的一个题目：这是洛谷的P1886<a href="https://www.luogu.com.cn/problem/P1886">滑动窗口单调队列</a>。</p><h4 id="①题目描述如下："><a href="#①题目描述如下：" class="headerlink" title="①题目描述如下："></a>①题目描述如下：</h4><p><img src="https://img-blog.csdnimg.cn/7c11d13af76247afb2d61c477494a958.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="滑动窗口单调队列"></p><p>数据范围为：$1 &lt;&#x3D; n &lt;&#x3D; k &lt;&#x3D; 10^6$。</p><h4 id="②解题思路"><a href="#②解题思路" class="headerlink" title="②解题思路"></a>②解题思路</h4><p>我们不妨以求某个窗口的最小值为例子(最大值同理也可以那么推导)。我们首先做的事情就是，依次的放入元素，到一个我们设置好的队列之中，因为这个队列要满足最后输出的结果是最小值，<font color="red">此时我们的队列应当满足单调递增的顺序</font>，这样的话我们每次输出的结果就是在输出一个队首的元素，保证输出的结果是在队列里面是最小的。那么一旦我即将要入队的元素比我目前队尾的元素要小的话，那么队尾会直接弹出，这是因为队尾元素和即将入队的元素已经在一个窗口里面了，由于即将入队的元素小，那么肯定就会有此滑动窗口元素的最小值不可能是原先队尾的元素了。<font color="red">如果当队首元素的下标已经不包含在滑动窗口里面的话</font>，那么我们要进行一个队首出队的行为，保证后面答案的更新不包括滑动窗口以外的元素！</p><h4 id="③一些问题及举例说明"><a href="#③一些问题及举例说明" class="headerlink" title="③一些问题及举例说明"></a>③一些问题及举例说明</h4><blockquote><p>1.为什么队列要满足单调递增呢？</p><p>我们考虑题目中的样例，当我们1入队以后，3能不能入队呢？答案是能。因为我们无法保证3之后的数字会不会比3还大，假设3之后的数字是4，5，6，……，那么当我们输出第一个答案1之后，滑动窗口往后移动，此时最小值就是3了，所以保证队列是单调递增的。</p></blockquote><blockquote><p>2.如何去判断队首元素不在滑动窗口里面呢？</p><p>要判断队首元素在不在窗口，就是说其坐标是不是比窗口的左边边界要大。这就需要我们另外用方法记录下来队首元素的坐标，比如开一个数组进行坐标的记录。假设我们遍历到第i个元素了，那么滑动窗口的左边界其实就是(i - k),此时就判断他是否比队首元素坐标小就好，如果不是，就让队首元素弹出就好了。</p></blockquote><h1 id="二、实现方法1-数组模拟"><a href="#二、实现方法1-数组模拟" class="headerlink" title="二、实现方法1(数组模拟)"></a>二、实现方法1(数组模拟)</h1><p>其实数组模拟了一个比较底层的数据结构deque,也就是双向队列。这个队列之所以能够满足题目的要求，就是因为，队首和队尾元素都可以进行弹出的操作，也就像一个管道一样，你可以从管道的两头出去，而不仅仅像一个队列一样，只能队首进行弹出。</p><p>以下代码有相关注释，结合前言，大家可以试着走一下程序。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 1e+6 + 5;int nums[N];int q[N];  &#x2F;&#x2F;队列int p[N];  &#x2F;&#x2F;下标 int main() &#123;int n, k;cin &gt;&gt; n &gt;&gt; k;int head, tail;for(int i &#x3D; 0; i &lt; n; i++) &#123;cin &gt;&gt; nums[i];&#125;&#x2F;&#x2F;输出滑动窗口最小值head &#x3D; 0, tail &#x3D; -1;for(int i &#x3D; 0; i &lt; n; i++) &#123;&#x2F;&#x2F;如果入队元素比队尾大，就队尾出队 while(head &lt;&#x3D; tail &amp;&amp; q[tail] &gt;&#x3D; nums[i])tail--;&#x2F;&#x2F;入队操作q[++tail] &#x3D; nums[i];p[tail] &#x3D; i;&#x2F;&#x2F;如果滑动窗口不包括队首元素，队首出队if(head &lt;&#x3D; tail &amp;&amp; i - k &gt;&#x3D; p[head])head++;&#x2F;&#x2F;进行输出if(i - k + 1 &gt;&#x3D; 0) cout &lt;&lt; q[head] &lt;&lt;&quot; &quot;; &#125;cout &lt;&lt; endl;&#x2F;&#x2F;输出滑动窗口最大值memset(q, 0, sizeof(q));memset(p, 0, sizeof(p));head &#x3D; 0, tail &#x3D; -1;for(int i &#x3D; 0; i &lt; n; i++) &#123;&#x2F;&#x2F;如果入队元素比队尾大，就队尾出队 while(head &lt;&#x3D; tail &amp;&amp; q[tail] &lt;&#x3D; nums[i])tail--;&#x2F;&#x2F;入队操作q[++tail] &#x3D; nums[i];p[tail] &#x3D; i;&#x2F;&#x2F;如果滑动窗口不包括队首元素，队首出队if(head &lt;&#x3D; tail &amp;&amp; i - k &gt;&#x3D; p[head])head++;&#x2F;&#x2F;进行输出if(i - k + 1 &gt;&#x3D; 0) cout &lt;&lt; q[head] &lt;&lt;&quot; &quot;; &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、实现方法2-deque"><a href="#三、实现方法2-deque" class="headerlink" title="三、实现方法2(deque)"></a>三、实现方法2(deque)</h1><p>我们可以直接用STL自带的deque底层队列进行模拟，这个地方，可以重新设置一下类，然后让队列的入队出队方式有一些细微的变化。这里的代码仅供参考，也是能过的，当然会稍微有点难理解吧,因为用到类和函数重置的相关知识了！</p><p>下面代码依次拼在一起就是最终的AC代码啦！</p><p>不知道为什么这里的代码不给我放到代码块里面，所以为了有更好的观感，可以去我的CSDN里面看这篇文章！</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124255565?spm=1001.2014.3001.5502">CSDN单调队列初探</a></p><blockquote><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int nums[10000005];<br>&#x2F;&#x2F;实现最大值的获取<br>class myqueuemax<br>{<br>   public:<br>       deque<int> que1;<br>       void pop(int value)<br>       {<br>           &#x2F;&#x2F;如果队首元素已经不在滑动窗口才弹出<br>           if(!que1.empty()&amp;&amp;value&#x3D;&#x3D;que1.front())<br>           que1.pop_front();<br>       }<br>       void push(int value)<br>       {<br>           &#x2F;&#x2F;加入的元素是否比队尾大就弹出队尾，保证单调递减<br>           while(!que1.empty()&amp;&amp;value&gt;que1.back())<br>           que1.pop_back();<br>           que1.push_back(value);<br>       }<br>       int front()<br>       {<br>           return que1.front();<br>       }<br>};</int></p><p>&#x2F;&#x2F;实现最小值的获取<br>class myqueuemin<br>{<br>   public:<br>       deque<int> que2;<br>       void pop(int value)<br>       {<br>           &#x2F;&#x2F;如果队首元素已经不在滑动窗口才弹出<br>           if(!que2.empty()&amp;&amp;value&#x3D;&#x3D;que2.front())<br>           que2.pop_front();<br>       }<br>       void push(int value)<br>       {<br>           &#x2F;&#x2F;加入的元素是否比队尾大就弹出队尾，保证单调递增<br>           while(!que2.empty()&amp;&amp;value&lt;que2.back())<br>           que2.pop_back();<br>           que2.push_back(value);<br>       }<br>       int front()<br>       {<br>           return que2.front();<br>       }<br>};</int></p><p>int main()<br>{<br>    myqueuemax que1;<br>    myqueuemin que2;<br>    int k,n;<br>    cin&gt;&gt;n&gt;&gt;k;<br>       &#x2F;&#x2F;最小值的输出<br>    for(int i&#x3D;0;i&lt;n;i++)<br>    {<br>        cin&gt;&gt;nums[i];<br>    }<br>     for(int i&#x3D;0;i&lt;k;i++)<br>    {<br>     que2.push(nums[i]);<br>    }<br>    cout&lt;&lt;que2.front()&lt;&lt;” “;<br>    for(int i&#x3D;k;i&lt;n;i++)<br>    {<br>        que2.pop(nums[i-k]);  &#x2F;&#x2F;直接利用下标对应的元素判断队首是否还在队列中<br>        que2.push(nums[i]);<br>        cout&lt;&lt;que2.front()&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>   &#x2F;&#x2F;最大值的输出<br>    for(int i&#x3D;0;i&lt;k;i++)<br>    {<br>     que1.push(nums[i]);<br>    }<br>    cout&lt;&lt;que1.front()&lt;&lt;” “;<br>    for(int i&#x3D;k;i&lt;n;i++)<br>    {<br>        que1.pop(nums[i-k]);  &#x2F;&#x2F;直接利用下标对应的元素判断队首是否还在队列中<br>        que1.push(nums[i]);<br>        cout&lt;&lt;que1.front()&lt;&lt;” “;<br>    }<br>}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结4</title>
      <link href="/2022/04/17/%E5%91%A8%E6%80%BB%E7%BB%934/"/>
      <url>/2022/04/17/%E5%91%A8%E6%80%BB%E7%BB%934/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、学习"><a href="#二、学习" class="headerlink" title="二、学习"></a>二、学习</h3><p>①c++prime看完了第12章</p><p>②英语每天留了40min的复习时间</p><p>③课内还是只听了微积分，课内作业也按时写完了</p><p>④学了线段树，这周写了有三篇博客：两篇线段树，一篇数位dp。</p><p>⑤操作系统学了信号量机制下怎么实现进程的同步和互斥，包括相关的问题（消费者，生产者进程）。</p><p>⑥力扣每日一题坚持到了59天</p><p>⑦参加了个人赛，AC了两个，排到2000多了，但是因为自己起晚了，好像比赛开始了1个半小时才去打的，第三题是线段树的一个写法，但是好像有点离散的思想在里面，导致学了线段树还是不是太会。</p><p>⑧知识星球的打卡取消了吧，感觉好像打卡只是一个形式，还是别浪费这个时间了。</p><h3 id="三、运动"><a href="#三、运动" class="headerlink" title="三、运动"></a>三、运动</h3><p>这周其实还是有坚持每天去外面跑步跳绳，然后让自己更加充满活力一点。但是周五开始一直到周日也就是今天，我们这边一直一直再下雨，所以这几天都没有运动，不过待会在家里面运动运动吧！</p><h3 id="四、杂言"><a href="#四、杂言" class="headerlink" title="四、杂言"></a>四、杂言</h3><p>其实上周说，要什么一天认真的去专注做好学习这一件事情，然后尝试了一下，发现自己还是没能够坚持下来。甚至有一些时间自己的精神高度紧绷了，然后导致晚上睡觉前怎么也睡不着，然后就刷手机看视频什么的，然后睡觉的时候，还多次冒冷汗，然后就醒来了。我也不知道怎么了，就可能一直想去学习更多的东西，但是有的时候，即使已经有了什么计划，我总是会觉得差了点什么东西。也许是我们计算机这个行业太卷了，我们是需要不断的学习新的东西就丰富自己各个方面的知识，但是也是因为这个想法，在学习知识的过程，好像兴趣越来越少了。有的时候，躺在床上，刷刷手机，和朋友们打打游戏，时间过去非常的快，但是我觉得那样的生活好像对于现在的我来说，真的比我像某段时间一样疯狂的学习充实得很多。我总觉得目前来说，身边还是少了些什么东西。也许是少了一些动力，又或者是少了一些陪伴。我挺知道这个行业或者说很多的行业都犹如行业本身一般，天生就是孤独的，可是这份孤独就真的有点如同现在飘在天上的乌云一般，如果你问他，你能不能快点走开啊！我现在的心情真的很烦很烦！他也许会看都不看你一眼，倔强着他那黑色到遮住天空的身体，然后吐了吐口水，天上瞬间就会下起倾盆的大雨。这一周的我真的好不喜欢下雨天，也许雨滴一直滴在我心中的某个地方，我一直在心里去找水滴的位置。可是有的时候，真就就是只能听到响声，还是找不到那个位置……这周疯狂的痴迷上了一个剧，其实很久很久之前就不会再去追一些什么《校园偶像剧》了，但是那部剧给我的感觉还是能找到一些让自己慰藉的感觉。虽然我觉得每个人的一生中，都很难去上演偶像剧一般的青春，偶像剧一般的爱情和友情，但是并不能妨碍你内心深处对看到的美好的一个期望吧！至此，还是希望能够慢慢去调整一下自己吧，我相信，会慢慢好起来的。</p><h3 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h3><p>贴上这周博客的网址吧</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124135034?spm=1001.2014.3001.5501">力扣刷题4</a></p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124178530?spm=1001.2014.3001.5501">力扣刷题5</a></p><p><a href="https://blog.csdn.net/qq_60556896/article/details/124149805?spm=1001.2014.3001.5501">线段树详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题5</title>
      <link href="/2022/04/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%985/"/>
      <url>/2022/04/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解的灵感来源于我自己看了很多神犇的题解，真的会很有收获。</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h1 id="二、数位dp初刷"><a href="#二、数位dp初刷" class="headerlink" title="二、数位dp初刷"></a>二、数位dp初刷</h1><p><img src="https://img-blog.csdnimg.cn/372be999948a4fd587aa24b90da22d48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="组合题dp"></p><h1 id="三、思路"><a href="#三、思路" class="headerlink" title="三、思路"></a>三、思路</h1><p>这题其实如果用我们高中学的组合的思想，可以做。因为他本身就是一个组合的题目，也就是说，最简单的思路就是，分析不同位数情况下构成的小于n的情况。所以很容易得到，一共只有两种情况</p><ul><li>情况一：构成的数字比要求数字的位数小</li><li>情况二：构成的数字比要求数字的位数大</li></ul><h3 id="①情况一"><a href="#①情况一" class="headerlink" title="①情况一"></a>①情况一</h3><p><font color="red">对于情况一来说，我们很容易进行分析，就是假设当前需要构成的位数为i,我们可以选择的数就是digits数组的长度，因此这种情况的结果累加的代码比较简单，直接给出：</font></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;位数不相同的情况&#x2F;&#x2F;m代表的是数字n的位数一共有多少位&#x2F;&#x2F;m - 1就可以满足i所代表的位数一定小于n所代表的位数        for(int i &#x3D; 1; i &lt;&#x3D; m - 1; i++) &#123;            ans +&#x3D; pow(lent,i);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②情况二的文字描述"><a href="#②情况二的文字描述" class="headerlink" title="②情况二的文字描述"></a>②情况二的文字描述</h3><p><font color="red"><del>对于情况二来说，由我们高中的知识就可以知道，我们可以依次的去比较每一位数在原digits的位置(由于数组是一个递增的情况)，所以当我们找到某个位置的时候，我们就能确定在位置之前的数，都是小于本位置，也就是可以进行一个选择。但是在这个地方，我们要知道不能完全依赖于这样的思想去写题目。</del></font></p><blockquote></blockquote><p><strong>就是假设我们现在选择到了4567的其中某一位且一定要从高位选起(也就是先选2所对应的位置)，这是为什么呢。比如我们给到的选择为1，2，3我们会发现在选择第一个高位的时候，无论我们选择什么，都能满足千位的数一定比4小，那根据乘法原理，很显然所有的答案其实就是$3×3×3×3$，也就是每个位置上都有3种选择</strong></p><p><strong>考虑一种情况，如果考虑$n&#x3D;4567$的时候给到的选择为2，4，8，9呢？此时我们发现如果选择4的时候，会有两种选择2，4但是出于考虑，我们并不能直接说第一个位置2，4都能选，因为我们无法保证选完4之后，是否后面的选择能够保证百位上的数比5小，因此在计算第一位的时候，我们必须只能选2，然后后面的三个位置任意选,也就是$1×3×3×3$,那么很多人在这里就不理解，那4如果作为第一位呢？其实他放到了后面的判断中去了，因为当把4前面的2选完以后，如果后面的操作还能进行，就已经固定了千位为4，然后再进行后面结果的积累。</strong></p><p><font color="red">所以最终的结果一定是不断的去更新每一位之后的选择可能性，因为我们已经确定好了位数之前的可能的结果，这也就是正确解答这个题目的一个顺序!当然如果大家不能理解的话，可以跟着后面的代码进行走一遍，然后多举一些例子辅助性的理解！</font></p><h3 id="③情况二的数学描述"><a href="#③情况二的数学描述" class="headerlink" title="③情况二的数学描述"></a>③情况二的数学描述</h3><p>跟据情况二的文字描述，下面把它用数学语言再进行描述一遍。假设一个数字为n，这个数字一共的位数为len,题目给我们选择的大小位changes(也就是digits数组的长度)。如果我们此时正在确定该位数的第k位时候的结果(也就是说前k位的结果已经被统计确认好了)。我们首先要找到digits数组中的一个位置l(数组已经转化为int类型了)，此位置满足$digits[l] &lt;&#x3D; n[k]$(其中n[k]代表第k位代表的数字)，会分为三种情况：</p><ul><li><p>①$digits[l] &lt; n[k]$：说明l位置包括l在内的数都可以填充这个位置，也就是这个位置有$l+1$种可能性(别忘了下标是从0开始的),当确定这个位置之后，剩余的位置可以任意的进行选择也就是有$pow(len-k,changes)$。所以累加的结果应该为:$(l+1)×pow(len-k,changes)$,此后的结果，因为已经被全部确认了，所以循环要直接<strong>break</strong>!!</p></li><li><p>②$digits[l] &#x3D; n[k]$：说明l位置不包括l在内的数都可以填充这个位置(因为l位置后面还是一个未知的结果，应该等到下一次循环再进行累加)，也就是这个位置有$l+1$种可能性(别忘了下标是从0开始的),当确定这个位置之后，剩余的位置可以任意的进行选择也就是有$pow(len-k,changes)$。所以累加的结果应该为:$(l+1)*pow(len-k,changes)$</p></li><li><p>③找不到满足$digits[l] &lt;&#x3D; n[k]$条件的数:直接break！</p></li></ul><h1 id="四、AC代码"><a href="#四、AC代码" class="headerlink" title="四、AC代码"></a>四、AC代码</h1><p>综上所述，最后把代码全部贴出来，仅供参考。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) &#123;        int lent &#x3D; digits.size();        vector&lt;int&gt; nums(lent, 0);        for(int i &#x3D; 0; i &lt; lent; i++) &#123;            nums[i] &#x3D; digits[i][0] - &#39;0&#39;;        &#125;        long long ans &#x3D; 0;        &#x2F;&#x2F;求出n的位数以及每一位数字上的数        vector&lt;int&gt; nmb;        while(n !&#x3D; 0) &#123;            nmb.push_back(n % 10);            n &#x2F;&#x3D; 10;        &#125;        int m &#x3D; nmb.size();   &#x2F;&#x2F;一共的位数        &#x2F;&#x2F;位数不相同的情况        for(int i &#x3D; 1; i &lt;&#x3D; m - 1; i++) &#123;            ans +&#x3D; pow(lent,i);        &#125;        &#x2F;&#x2F;位数相同的情况        for(int i &#x3D; m - 1, p &#x3D; 1; i &gt;&#x3D; 0; i--, p++) &#123;            &#x2F;&#x2F;因为数组的递增，可以用二分去寻找位置            &#x2F;&#x2F;先找到小于等于此位数的第一个位置            &#x2F;&#x2F;当然其实因为数组的常量比较小，直接循环找也没有问题的            int l &#x3D; -1, r &#x3D; lent;            while(l + 1 !&#x3D; r) &#123;                int mid &#x3D; (l + r) &gt;&gt; 1;                if(nums[mid] &gt; nmb[i]) r &#x3D; mid;                else l &#x3D; mid;            &#125;            if(l &#x3D;&#x3D; -1) break;            else if(nums[l] &#x3D;&#x3D; nmb[i]) &#123;                ans +&#x3D; l * pow(lent, m - p);                &#x2F;&#x2F;如果就连最后一位都相等的时候，一定要记得加上与本身完全相同的那一个结果                &#x2F;&#x2F;因为循环后不会再继续探索后面的结果了                &#x2F;&#x2F;这里可以举一些例子帮助理解                if(i &#x3D;&#x3D; 0) ans++;            &#125;            else &#123;                ans +&#x3D; (l + 1) * pow(lent, m - p);                &#x2F;&#x2F;已经找到了所有结果了记得break                break;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树初探</title>
      <link href="/2022/04/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/04/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、线段树的相关概念"><a href="#一、线段树的相关概念" class="headerlink" title="一、线段树的相关概念"></a>一、线段树的相关概念</h1><h3 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h3><p>什么是线段树呢？首先默认很多同学已经知道树这个结构了。也就是说，我们要用树的每一个节点去存下每一段数，我觉得线段树的名字由来大概如此吧！我们可以看下的图</p><p><img src="https://img-blog.csdnimg.cn/f96a5cc24c4c4d86989ef7b0f60c4aea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树图解"></p><p><strong>上面的图就是线段树上的每一个节点所存的数代表的含义，比如一个线段的左编号为l，右编号为r，那么这个线段所代表的就是$\sum_ {i&#x3D;l}^{r}nums[i]$,最终呈现的一颗树如下图。</strong></p><p><img src="https://img-blog.csdnimg.cn/4437b4713e424355a0743e5902fa3564.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="整个线段树的图形"></p><blockquote><p>而蓝色标记的数字代表树上节点的编号，这个是在二叉树里面的编号，所以可以知道每一个节点左儿子和右儿子的编号，假设当前的编号k, 那么他的<font color="red">左儿子为：2k(k &lt;&lt; 1),右儿子为：2k+1(k&lt;&lt;1|1)</font>,这里加红的地方大家可以注意一下，因为一般来说，位运算能比较快的去遍历一整颗树，所以在后面的代码全部由位运算代替左右儿子的遍历。</p></blockquote><h3 id="②好处"><a href="#②好处" class="headerlink" title="②好处"></a>②好处</h3><p>首先呢，由于线段树是一个二叉树，因此它可以让时间复杂度为$O(N)$的代码降低为$log_2(N)$的时间复杂度，在数据大的时候，很有可能就是这样的时间差距，带来更多的收益。那么线段树到底会解决什么样的问题，那么复杂的一棵树，为什么我一定要拿来用呢？有几个点：<font color="red">如果我们多次修改某个区间，求区间和又或者是多次让某个区间变成一个数</font>,类似这样的问题是可以用线段树的。当然这些问题是可以用线段数组来写的，但是有的时候我们会不得不用线段树，比如多次将一个区间变成同一个数。当然线段树的很多功能可以通过树状数组来代替，如果能够使用树状数组写的题目，最好能够优先选择树状数组。所以为什么还要去学习线段树呢？我觉得在刚开始我一直很畏惧去学，但是经过一天的学习之后我发现，学习完线段树，不仅是多了一个解决问题的手段，多学了一个数据结构，更多的是对递归，分治的思想又加深了。所以建议uu们都可以去学习这样的一颗复杂但是优美的树！</p><h1 id="二、线段树的基本操作（1）"><a href="#二、线段树的基本操作（1）" class="headerlink" title="二、线段树的基本操作（1）"></a>二、线段树的基本操作（1）</h1><h3 id="①建树"><a href="#①建树" class="headerlink" title="①建树"></a>①建树</h3><p>毫无疑问对于这样的一个数据结构来说，我们肯定是得先要把它建出来。这样建树的过程其实在树的学习中，大家肯定都是会的，而因为线段树的定义不同，因此我们要在每次递归回溯的过程，让节点所代表的值加上他左子树和右子树的值，才最终代表某个节点是由下面子树的和而构建来的，具体代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void build_tree(int k, int l, int r) &#123;if(l &#x3D;&#x3D; r) &#123;sum[k] &#x3D; nums[l];return; &#125;int m &#x3D; (l + r) &gt;&gt; 1; &#x2F;&#x2F;取l，r的中点&#x2F;&#x2F;递归左子树，然后k&lt;&lt;1相当于2*k build_tree(k &lt;&lt; 1, l, m);&#x2F;&#x2F;递归右子树，然后k &lt;&lt; 1 | 1相当于2*k+1 build_tree(k &lt;&lt; 1 | 1, m + 1, r); &#x2F;&#x2F;进行区间的求和累积(左子树和右子树的和)sum[k] &#x3D; sum[k &lt;&lt; 1] + sum[k &lt;&lt; 1 | 1]; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②修改单个点的值"><a href="#②修改单个点的值" class="headerlink" title="②修改单个点的值"></a>②修改单个点的值</h3><p>如果题目要求让某个点加上一个val值的话，很显然，在更新一整颗树的时候，每一个线段带有该点都必须一起的进行更新，然后在更新的过程的时候，会有一个必要条件，也就是更新点的下标一定是会被包含在每次递归的左右区间之内的，所以有如下的代码。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;进行单个数的加值void add(int k, int l, int r, int x, int val) &#123;&#x2F;&#x2F;改变的数根据递归肯定会在[l, r]的区间之内 sum[k] +&#x3D; val;if(l &#x3D;&#x3D; r) return;int m &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;要改变的数在左子树 if(x &lt;&#x3D; m) &#123;add(k &lt;&lt; 1, l, m, x, val);&#125;&#x2F;&#x2F;要改变的数在右子树 else &#123;add(k &lt;&lt; 1 | 1, m + 1, r, x, val); &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完成上面的操作之后，就可以让每一颗树进行对应的更新了，因此如果在次基础上，如果我们要查询一段区间和的时候，我们其实只需要递归的去计算每个区间的和就好了</strong></p><h3 id="③针对只修改了单个点值的区间查询"><a href="#③针对只修改了单个点值的区间查询" class="headerlink" title="③针对只修改了单个点值的区间查询"></a>③针对只修改了单个点值的区间查询</h3><p><font color="red">这里可以注意一下标题，只针对修改了单个点值的区间查询，因为在这个前提下的计算和之后的计算有着不同的地方，所以先看一个点，再慢慢推进到后面的点。</font>这里的操作还是以下图为例子：</p><p><img src="https://img-blog.csdnimg.cn/f96a5cc24c4c4d86989ef7b0f60c4aea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树图解"></p><blockquote><p>因为对于这里的递归会有很多的不理解的地方，在这稍作提示。如果我们在做一个区间计算的时候，如果计算的区间刚好在左子树，那么我们最后只需要递归左子树的和就好了，比如在编号为①的时候，我们要查找$[1,2]$区间的和，那么其实只需要到编号为②的地方去计算，右子树同理。那么如果我们跨了区间怎么半呢？比如在上图我要查找$[2,4]$区间的和呢，也很简单，只不过就是左子树的区间$[2,3]$和右子树的区间$[3,4]$两个计算的结果加在一起，具体很多的注释加在代码内，建议读者可以用一些例子理解这个递归式子。而下面第一行注释的lazy标记是后面要介绍的内容！</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;计算某个区间的和，不含有lazy标记 int cal(int k, int l, int r, int x, int y) &#123;if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123;    return sum[k]; &#125;int m &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    return cal(k &lt;&lt; 1, l, m, x, y);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; return cal(k &lt;&lt; 1 | 1, m + 1, r, x, y);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 return cal(k &lt;&lt; 1, l, m, x, m) + cal(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="④例题模板1"><a href="#④例题模板1" class="headerlink" title="④例题模板1"></a>④例题模板1</h3><p><img src="https://img-blog.csdnimg.cn/745ab82a49654f21a1ccc5b8c33fe9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="例题1"></p><p>​                                                                                             <a href="https://www.luogu.com.cn/problem/P3374">例题1入口</a></p><p><strong>这个例题将我们所说的结合起来就可以写了的，当然他是树状数组的一个板子，之所以用线段树去写，只是为了加深对线段树的熟悉度罢了。</strong></p><h3 id="⑤AC全部代码"><a href="#⑤AC全部代码" class="headerlink" title="⑤AC全部代码"></a>⑤AC全部代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F;开辟其他数组的时候最好为4n让数组不会产生越界的情况 int nums[500005];  &#x2F;&#x2F;数据的存储 int sum[2000010];   &#x2F;&#x2F;区间和的存储 int lz[2000010];     &#x2F;&#x2F;lazy标记的存储int n, m;&#x2F;&#x2F;进行线段树的构建 void build_tree(int k, int l, int r) &#123;if(l &#x3D;&#x3D; r) &#123;sum[k] &#x3D; nums[l];return; &#125;int m &#x3D; (l + r) &gt;&gt; 1; &#x2F;&#x2F;取l，r的中点&#x2F;&#x2F;递归左子树，然后k&lt;&lt;1相当于2*k build_tree(k &lt;&lt; 1, l, m);&#x2F;&#x2F;递归右子树，然后k &lt;&lt; 1 | 1相当于2*k+1 build_tree(k &lt;&lt; 1 | 1, m + 1, r); &#x2F;&#x2F;进行区间的求和累积(左子树和右子树的和)sum[k] &#x3D; sum[k &lt;&lt; 1] + sum[k &lt;&lt; 1 | 1]; &#125;&#x2F;&#x2F;进行单个数的加值void add(int k, int l, int r, int x, int val) &#123;&#x2F;&#x2F;改变的数根据递归肯定会在[l, r]的区间之内 sum[k] +&#x3D; val;if(l &#x3D;&#x3D; r) return;int m &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;要改变的数在左子树 if(x &lt;&#x3D; m) &#123;add(k &lt;&lt; 1, l, m, x, val);&#125;&#x2F;&#x2F;要改变的数在右子树 else &#123;add(k &lt;&lt; 1 | 1, m + 1, r, x, val); &#125;&#125;&#x2F;&#x2F;计算某个区间的和，不含有laze标记 int cal(int k, int l, int r, int x, int y) &#123;if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123;    return sum[k]; &#125;int m &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    return cal(k &lt;&lt; 1, l, m, x, y);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; return cal(k &lt;&lt; 1 | 1, m + 1, r, x, y);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 return cal(k &lt;&lt; 1, l, m, x, m) + cal(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y);&#125;&#125;int main() &#123;cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;cin &gt;&gt; nums[i];&#125;build_tree(1, 1, n);for(int i &#x3D; 1; i &lt;&#x3D;m; i++) &#123;int cz, x, y;cin &gt;&gt; cz &gt;&gt; x &gt;&gt; y;if(cz &#x3D;&#x3D; 1) &#123;add(1, 1, n, x, y);&#125;else &#123;cout &lt;&lt; cal(1, 1, n, x, y) &lt;&lt; endl;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、线段树的基本操作（2）不下传懒惰标记版本"><a href="#三、线段树的基本操作（2）不下传懒惰标记版本" class="headerlink" title="三、线段树的基本操作（2）不下传懒惰标记版本"></a>三、线段树的基本操作（2）不下传懒惰标记版本</h1><p>在上面的操作，我们只是进行了对线段树中的某一个值进行一个加减的过程，那么很显然不能体现线段树的好处。那么如果我们对一整个区间去进行操作呢？我们先看一下下面的引入：</p><h3 id="①引入懒惰标记"><a href="#①引入懒惰标记" class="headerlink" title="①引入懒惰标记"></a>①引入懒惰标记</h3><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记"></p><p><strong>如图所示，左边是我们最开始要构建的一颗树，右边是加入了懒惰标记的时候构建的一颗树，在这个地方我们看到了在两个地方我们由红色标记了一个东西，这就是我们的懒惰标记。由它的名字我们可以知道，就是我们可以偷懒，让程序不用去把所有的值进行修改，就可以得到我们最终的答案。也就是图中的下标为3，4的地方的并没有进行加1操作，但是他们的和是加上了2的，这是怎么偷懒的呢？</strong><font color="red">通俗来说，就是假设我们计算一个区间，如果线段树的那一段已经恰好完全包含了这个区间，正如[3,4]的区间被恰好包含在编号为3的子树上，那么我们就直接给他打上一个+1的标记，代表其实它的儿子是都需要加1的，但是由于我已经包含了他们，因此我们不再需要继续往下递归，因为它们的老爸已经把他们相加的结果记录好了，这个操作实现的代码如下：</font></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insert(int k, int l, int r, int x, int y, long long val) &#123;&#x2F;&#x2F;如果刚好区域被包含在[l,r]的区间内 if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123; &#x2F;&#x2F;给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数  lz[k] +&#x3D; val;   return;    &#125;    &#x2F;&#x2F;先让能够满足所求区间为总区间的子区间的加上对应的区间和     sum[k] +&#x3D; (y - x + 1) * val;    int m &#x3D; (l + r) &gt;&gt; 1;    &#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    insert(k &lt;&lt; 1, l, m, x, y, val);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; insert(k &lt;&lt; 1 | 1, m + 1, r, x, y, val);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 insert(k &lt;&lt; 1, l, m, x, m, val);insert(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y, val);&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②区间的查询"><a href="#②区间的查询" class="headerlink" title="②区间的查询"></a>②区间的查询</h3><p>好了那么我们要查询一个区间怎么办呢？首先这里由于我们是这里先介绍不把懒惰标记下传的写法，因此，下面的方法与后面把懒惰标记下传的方法会有些不同的地方，大家注意看一下区别。</p><p>回归正题，如果我们要查找一段区间，但是由于懒惰坐标并没有下传，这就会导致一个什么事情呢，就是在我们查询的时候，有一些孩子的值是并没有得到更新的，这就会导致，他们所存的sum值是没有得到更新的，还需要去加上之前积累的懒惰标记的值才行，这里还是以上图为例子。</p><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记计算1"></p><p>假设我们要查找的就是$[4,4]$这个区间呢？我们可以看到本身4下标的这个数字是要加1的，但是很遗憾的是，我们的第一步操作并没有达到我们想要满足的效果。那么我们可以关注一下，从下标为4的那个地方往上看，是不是可以看到一个懒惰标记，这个代表了什么呢？不就是代表了它上方如果存在懒惰标记的话，那么就代表因为太懒，本来它本身是需要加上懒惰标记的值但是没有加上，那么我们只需要把他上方所有积累的懒惰标记加起来，然后最后在计算本身的时候加上$(\sum{lz}*length(区间的长度))$就好了。这个地方会有点难理解为什么要加上上方所有的和，不急，可以在用一个图为例子：</p><p><img src="https://img-blog.csdnimg.cn/a867ad730ac34f0d9e84e2f799221706.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记计算2"></p><p><strong>假设在前面图的基础上让区间[1,4]都加上了一个1，很显然，因为恰好包含，除了根节点挂上一个+1的懒惰标记，其他地方都不会变化，那如果此时我们还要计算[4,4]的值呢？很显然我们要加上两个懒惰标记的值，因为4被连续加上了两次1。也就是说当我们不把懒惰标记下传的时候，我们是需要计算两部分的值才能最终确定一个区间的和。一个就是懒惰标记的积累和，另外就是本身的子树累计的和，代码如下，大家可以结合代码去走一遍图：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;进行区间的查询&#x2F;&#x2F;函数的意思：在[l,r]上的[x,y]区间所有数的和&#x2F;&#x2F;p代表当前下标的lazy值 int query(int k, int l, int r, int x, int y, int p) &#123;&#x2F;&#x2F;先进行lazy值的累加p +&#x3D; lz[k]; &#x2F;&#x2F;如果恰好包含    if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123;    return p * (y - x + 1) + sum[k];&#125;int m &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    return query(k &lt;&lt; 1, l, m, x, y, p);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; return query(k &lt;&lt; 1 | 1, m + 1, r, x, y, p);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 return query(k &lt;&lt; 1, l, m, x, m, p) + query(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y, p);&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③例题模板2"><a href="#③例题模板2" class="headerlink" title="③例题模板2"></a>③例题模板2</h3><p><img src="https://img-blog.csdnimg.cn/0209f12304fe4725896c1b92231635aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="线段树模板"></p><p>​                                                                                                    <a href="https://www.luogu.com.cn/problem/P3372">题目2入口</a></p><h3 id="④AC完整代码"><a href="#④AC完整代码" class="headerlink" title="④AC完整代码"></a>④AC完整代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F;开辟其他数组的时候最好为4n让数组不会产生越界的情况 int nums[100001];  &#x2F;&#x2F;数据的存储 long long sum[400010];   &#x2F;&#x2F;区间和的存储 long long lz[400010];     &#x2F;&#x2F;lazy标记的存储int n, m;&#x2F;&#x2F;进行线段树的构建 void build_tree(int k, int l, int r) &#123;if(l &#x3D;&#x3D; r) &#123;sum[k] &#x3D; nums[l];return; &#125;int m &#x3D; (l + r) &gt;&gt; 1; &#x2F;&#x2F;取l，r的中点&#x2F;&#x2F;递归左子树，然后k&lt;&lt;1相当于2*k build_tree(k &lt;&lt; 1, l, m);&#x2F;&#x2F;递归右子树，然后k &lt;&lt; 1 | 1相当于2*k+1 build_tree(k &lt;&lt; 1 | 1, m + 1, r); &#x2F;&#x2F;进行区间的求和累积(左子树和右子树的和)sum[k] &#x3D; sum[k &lt;&lt; 1] + sum[k &lt;&lt; 1 | 1]; &#125;&#x2F;&#x2F;进行区间的加值&#x2F;&#x2F;函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;&#x2F;&#x2F;如果刚好区域被包含在[l,r]的区间内 if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123; &#x2F;&#x2F;给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数  lz[k] +&#x3D; val;   return;    &#125;    &#x2F;&#x2F;先让能够满足所求区间为总区间的子区间的加上对应的区间和     sum[k] +&#x3D; (y - x + 1) * val;    int m &#x3D; (l + r) &gt;&gt; 1;    &#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    insert(k &lt;&lt; 1, l, m, x, y, val);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; insert(k &lt;&lt; 1 | 1, m + 1, r, x, y, val);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 insert(k &lt;&lt; 1, l, m, x, m, val);insert(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y, val);&#125; &#125;&#x2F;&#x2F;进行区间的查询&#x2F;&#x2F;函数的意思：在[l,r]上的[x,y]区间所有数的和&#x2F;&#x2F;p代表当前下标的lazy值 long long query(int k, int l, int r, int x, int y, long long p) &#123;&#x2F;&#x2F;先进行lazy值的累加p +&#x3D; lz[k]; &#x2F;&#x2F;如果恰好包含    if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123;    return p * (y - x + 1) + sum[k];&#125;int m &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    return query(k &lt;&lt; 1, l, m, x, y, p);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; return query(k &lt;&lt; 1 | 1, m + 1, r, x, y, p);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 return query(k &lt;&lt; 1, l, m, x, m, p) + query(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y, p);&#125; &#125;int main() &#123;scanf(&quot;%d%d&quot;, &amp;n, &amp;m);for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;scanf(&quot;%d&quot;, &amp;nums[i]);&#125;build_tree(1, 1, n);for(int i &#x3D; 1; i &lt;&#x3D;m; i++) &#123;int cz;scanf(&quot;%d&quot;, &amp;cz);if(cz &#x3D;&#x3D; 1) &#123;            int x,y;            long long k;scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;k);insert(1, 1, n, x, y, k);&#125;else &#123;            int x,y;scanf(&quot;%d%d&quot;, &amp;x, &amp;y);printf(&quot;%lld\n&quot;, query(1, 1, n, x, y, 0));&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、线段树的基本操作（2）下传懒惰标记版本"><a href="#四、线段树的基本操作（2）下传懒惰标记版本" class="headerlink" title="四、线段树的基本操作（2）下传懒惰标记版本"></a>四、线段树的基本操作（2）下传懒惰标记版本</h1><h3 id="①引言"><a href="#①引言" class="headerlink" title="①引言"></a>①引言</h3><p>这里其实就是说会根据很多人的不同习惯有很多不同的写法，所以仅供大家参考目前我在慢慢习惯的一个写法。</p><p>下传懒惰标记其实就是说，我们不要去管计算的时候，一个区间上面的懒惰标记，假设还是如图</p><p><img src="https://img-blog.csdnimg.cn/8e99ec4aaedb41eb80edcdbbc3ce2ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="懒惰标记下传"></p><p>如果我们还是要去计算[4,4]的值，我们不妨在访问和为9的那个线段的时候，直接把它的懒惰标记传给它的左右孩子，然后它本身的懒惰标记变成0。这样的话，我们计算值的时候就不用管上面懒惰标记的和了，因为都是0。那么我们其实就是在计算本层的一个值加上本身就应该加上的懒惰标记的值，其实和之前的方法就是一个过程了相当于，就是思维上稍微有点不同。<font color="red">比如在这个地方，因为计算的时候有可能会把懒惰标记下传，这样的过程会导致什么呢？会导致上方的值因为懒惰标记的下传，上面的值得不到一个更新，因此很简单的思路就是。在递归回溯的过程中，让上方的值不断的进行一个更新，也就是和我们文章最初开头的一种方式是一样的了！</font></p><h3 id="②插入的操作-懒惰标记下传"><a href="#②插入的操作-懒惰标记下传" class="headerlink" title="②插入的操作(懒惰标记下传)"></a>②插入的操作(懒惰标记下传)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;进行区间的加值&#x2F;&#x2F;函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;&#x2F;&#x2F;如果刚好区域被包含在[l,r]的区间内 if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123; &#x2F;&#x2F;给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数  lz[k] +&#x3D; val;   return;    &#125;    &#x2F;&#x2F;如果此处有标记，向下传if(lz[k]) &#123;lz[k &lt;&lt; 1] +&#x3D; lz[k];lz[k &lt;&lt; 1 | 1] +&#x3D; lz[k];lz[k] &#x3D; 0; &#x2F;&#x2F;记得懒惰标记的清0 &#125;     int m &#x3D; (l + r) &gt;&gt; 1;    &#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    insert(k &lt;&lt; 1, l, m, x, y, val);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; insert(k &lt;&lt; 1 | 1, m + 1, r, x, y, val);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 insert(k &lt;&lt; 1, l, m, x, m, val);insert(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y, val);&#125;    &#x2F;&#x2F;最后递归回溯的时候不断更新上面的值sum[k] &#x3D; sum[k &lt;&lt; 1] + (m - l + 1) * lz[k &lt;&lt; 1]    + sum[k &lt;&lt; 1 | 1] + (r - m) * lz[k &lt;&lt; 1 | 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②查询的操作-懒惰标记下传"><a href="#②查询的操作-懒惰标记下传" class="headerlink" title="②查询的操作(懒惰标记下传)"></a>②查询的操作(懒惰标记下传)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;进行区间的查询&#x2F;&#x2F;函数的意思：在[l,r]上的[x,y]区间所有数的和long long query(int k, int l, int r, int x, int y) &#123;&#x2F;&#x2F;如果恰好包含    if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123;    return sum[k] + lz[k] * (r - l + 1);&#125;&#x2F;&#x2F;如果此处有标记，向下传if(lz[k]) &#123;lz[k &lt;&lt; 1] +&#x3D; lz[k];lz[k &lt;&lt; 1 | 1] +&#x3D; lz[k];lz[k] &#x3D; 0; &#x2F;&#x2F;记得懒惰标记的清0 &#125;int m &#x3D; (l + r) &gt;&gt; 1;long long ret &#x3D; 0;&#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    ret &#x3D; query(k &lt;&lt; 1, l, m, x, y);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; ret &#x3D; query(k &lt;&lt; 1 | 1, m + 1, r, x, y);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 ret &#x3D; query(k &lt;&lt; 1, l, m, x, m) + query(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y);&#125;    &#x2F;&#x2F;最后递归回溯的时候不断更新上面的值sum[k] &#x3D; sum[k &lt;&lt; 1] + (m - l + 1) * lz[k &lt;&lt; 1]    + sum[k &lt;&lt; 1 | 1] + (r - m) * lz[k &lt;&lt; 1 | 1]; return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">这里为什么要另外设计一个ret变量对结果进行保存呢？对比不下传的方法，我们可以看到，本次的方法会边回溯边更新答案，因此在我们回溯的过程中，我们才会得到正确的答案，因此回溯的过程要把区间的左右记录下来，最后完成区间和的更新才是我们最终的答案。而方法二为什么不用这个呢？就是因为方法二是不断的往下去更新，然后遇到可以不用更新的地方就直接回溯了，但是我们发现在向下递归的时候，就已经对答案进行了更新，也就是方法三的一个逆过程！</font></p><h3 id="③AC代码"><a href="#③AC代码" class="headerlink" title="③AC代码"></a>③AC代码</h3><p>因为题目还是方法二的，因此这里直接贴上不同版本的代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F;开辟其他数组的时候最好为4n让数组不会产生越界的情况 long long nums[100001];  &#x2F;&#x2F;数据的存储 long long sum[400010];   &#x2F;&#x2F;区间和的存储 long long lz[400010];     &#x2F;&#x2F;lazy标记的存储int n, m;&#x2F;&#x2F;进行线段树的构建 void build_tree(int k, int l, int r) &#123;if(l &#x3D;&#x3D; r) &#123;sum[k] &#x3D; nums[l];return; &#125;int m &#x3D; (l + r) &gt;&gt; 1; &#x2F;&#x2F;取l，r的中点&#x2F;&#x2F;递归左子树，然后k&lt;&lt;1相当于2*k build_tree(k &lt;&lt; 1, l, m);&#x2F;&#x2F;递归右子树，然后k &lt;&lt; 1 | 1相当于2*k+1 build_tree(k &lt;&lt; 1 | 1, m + 1, r); &#x2F;&#x2F;进行区间的求和累积(左子树和右子树的和)sum[k] &#x3D; sum[k &lt;&lt; 1] + sum[k &lt;&lt; 1 | 1]; &#125;&#x2F;&#x2F;进行区间的加值&#x2F;&#x2F;函数意思代表：在[l,r]上的[x,y]区间给每个数加上一个val值 void insert(int k, int l, int r, int x, int y, long long val) &#123;&#x2F;&#x2F;如果刚好区域被包含在[l,r]的区间内 if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123; &#x2F;&#x2F;给恰好包含要求子数做上lazy标记，表示后面不用继续递归加数  lz[k] +&#x3D; val;   return;    &#125;    &#x2F;&#x2F;如果此处有标记，向下传if(lz[k]) &#123;lz[k &lt;&lt; 1] +&#x3D; lz[k];lz[k &lt;&lt; 1 | 1] +&#x3D; lz[k];lz[k] &#x3D; 0; &#x2F;&#x2F;记得懒惰标记的清0 &#125;     int m &#x3D; (l + r) &gt;&gt; 1;    &#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    insert(k &lt;&lt; 1, l, m, x, y, val);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; insert(k &lt;&lt; 1 | 1, m + 1, r, x, y, val);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 insert(k &lt;&lt; 1, l, m, x, m, val);insert(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y, val);&#125;sum[k] &#x3D; sum[k &lt;&lt; 1] + (m - l + 1) * lz[k &lt;&lt; 1]    + sum[k &lt;&lt; 1 | 1] + (r - m) * lz[k &lt;&lt; 1 | 1];&#125;&#x2F;&#x2F;进行区间的查询&#x2F;&#x2F;函数的意思：在[l,r]上的[x,y]区间所有数的和long long query(int k, int l, int r, int x, int y) &#123;&#x2F;&#x2F;如果恰好包含    if(l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; y) &#123;    return sum[k] + lz[k] * (r - l + 1);&#125;&#x2F;&#x2F;如果此处有标记，向下传if(lz[k]) &#123;lz[k &lt;&lt; 1] +&#x3D; lz[k];lz[k &lt;&lt; 1 | 1] +&#x3D; lz[k];lz[k] &#x3D; 0; &#x2F;&#x2F;记得懒惰标记的清0 &#125;int m &#x3D; (l + r) &gt;&gt; 1;long long ret &#x3D; 0;&#x2F;&#x2F;区间完全在左子树     if(y &lt;&#x3D; m) &#123;    ret &#x3D; query(k &lt;&lt; 1, l, m, x, y);&#125;&#x2F;&#x2F;区间完全在右子树 else if(x &gt; m) &#123; ret &#x3D; query(k &lt;&lt; 1 | 1, m + 1, r, x, y);&#125;&#x2F;&#x2F;区间跨越了左右子树else &#123;&#x2F;&#x2F;合并左右子树的结果 ret &#x3D; query(k &lt;&lt; 1, l, m, x, m) + query(k &lt;&lt; 1 | 1, m + 1, r, m + 1, y);&#125;sum[k] &#x3D; sum[k &lt;&lt; 1] + (m - l + 1) * lz[k &lt;&lt; 1]    + sum[k &lt;&lt; 1 | 1] + (r - m) * lz[k &lt;&lt; 1 | 1]; return ret;&#125;int main() &#123;cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;cin &gt;&gt; nums[i];&#125;build_tree(1, 1, n);for(int i &#x3D; 1; i &lt;&#x3D;m; i++) &#123;int cz, x, y;long long k;cin &gt;&gt; cz;if(cz &#x3D;&#x3D; 1) &#123;cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;insert(1, 1, n, x, y, k);&#125;else &#123;cin &gt;&gt; x &gt;&gt; y;cout &lt;&lt; query(1, 1, n, x, y) &lt;&lt; endl;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总而言之，线段树会有很多不同的写法，本文仅提供目前学到的这种，uu们可以找到自己习惯的写法，然后经常复习一下，我觉得对线段树就会慢慢不陌生了！！！</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">线段树详解</a></p><p><a href="https://www.bilibili.com/video/BV1uS4y1m7zY?spm_id_from=333.788.header_right.history_list.click">wls的b站视频</a></p><p>感谢各大佬写的博客，发的视频的帮助！</p><p>本文章的问题也希望读者们指出！</p>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题4</title>
      <link href="/2022/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%984/"/>
      <url>/2022/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>sheepice的刷力扣篇章，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，这些题解的灵感来源于我自己看了很多神犇的题解，真的会很有收获。</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h1 id="二、力扣的某“简单题”"><a href="#二、力扣的某“简单题”" class="headerlink" title="二、力扣的某“简单题”"></a>二、力扣的某“简单题”</h1><p><img src="https://img-blog.csdnimg.cn/ec95219d02954e7fb50cbc622d3e0efe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="检查整数是否被全部覆盖"></p><p><strong>这个题目其实说真的，刚开始觉得真的挺难的，然后看到是个简单题我就知道数据的范围肯定给的非常的小，果不其然，数据范围只给了50，哈哈哈，所以第一次做这个题目的时候，这不就是简单的暴力枚举的题目吧，因为这题是三叶姐给到的“-+”题，然后看了看，好家伙，居然有可能上升为一个困难题（<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490741&idx=1&sn=cd4ab8ff1852c379223efb66d5e904ab">三叶姐关于本题的解答</a>）,awsl,于是乎我觉得今天去学习一下线段树的基本东西！！</strong></p><h1 id="三、一题多解"><a href="#三、一题多解" class="headerlink" title="三、一题多解"></a>三、一题多解</h1><h2 id="①暴力哈希"><a href="#①暴力哈希" class="headerlink" title="①暴力哈希"></a>①暴力哈希</h2><p>这里其实可以很容易想到，把所有题目中给到的range范围中的数，直接存储下来，然后呢直接进行一次$[left, right]$区间的一个遍历，看看区间内的元素是否满足在区间之内就好了！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    map&lt;int, int&gt; nums;    bool isCovered(vector&lt;vector&lt;int&gt;&gt;&amp; ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            for(auto i &#x3D; range[0]; i &lt;&#x3D; range[1]; i++) &#123;                nums[i]++;            &#125;        &#125;        for(int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;            if(!nums.count(i)) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>暴力解法的时间复杂度为$O(N)$，由于这里开了一个哈希表，所以空间复杂度为$O(N)$。当然这里的数据因为比较小嘛，直接开一个常数的52一个数组去记录数字是否存在，空间复杂度就变成$O(C)$了哈哈。</p><h2 id="②差分数组加前缀和"><a href="#②差分数组加前缀和" class="headerlink" title="②差分数组加前缀和"></a>②差分数组加前缀和</h2><p>关于差分的思想和前缀和的计算，相信很多同学已经会了，在此不多加赘述，那么这一题的差分思想在哪呢？其实就是我们去计算一个一个区间所存在数字的时候.先设置一个差分数组$diff[52]$,假设我们要计算区间$[1,10]$之内，保证这之间的数都出现过也就不为0，那么我们只需要让$diff[1]+1$然后让$diff[11]-1$，之后对区间做一次前缀和我们可以发现区间$[1,10]$内的$diff$数组就会全部变成1，代表数字出现在区间内，这样虽然并没有大大的优化时间复杂度。<font color="red">但是我们不难发现，如果当题目所给的区间有重复的时候，我们是可以通过这样的方法去计算出每一个数字被重复的次数，也就是在整个区间里面重复出现了多少次，这个可能也对日后碰到这样的题目提供了一个非常不错的思路！</font></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int diff[52];    bool isCovered(vector&lt;vector&lt;int&gt;&gt;&amp; ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            diff[range[0]]++;            diff[range[1] + 1]--;            &#125;        for(int i &#x3D; 1; i &lt; 52; i++) &#123;            diff[i] +&#x3D; diff[i - 1];        &#125;        for(int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;            if(diff[i] &lt;&#x3D; 0) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为$O(N)$，空间复杂度就变成$O(C)$。</p><h2 id="③树状数组"><a href="#③树状数组" class="headerlink" title="③树状数组"></a>③树状数组</h2><p><strong>本题采用线状数组其实无非就是会和第二种解法一样，只不过在树状数组的add操作里面，每次加入的是代表此元素出现的次数，最后利用差分的思想，可以直接得到某元素出现的次数，其实和方法二大同小异，但是希望自己再练一遍树状数组，所以呢，就还是写了一遍代码。如果对树状数组不了解的同学，sheepice也写了一篇博客，仅供uu们进行参考.</strong><a href="https://sheepice.github.io/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/">树状数组初探</a>！！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int n &#x3D; 55;    int sum[55];    int lowbit(int x) &#123;        return x &amp; (-x);    &#125;    void add(int index, int value) &#123;        for(int i &#x3D; index; i &lt;&#x3D; n - 1; i +&#x3D; lowbit(i)) &#123;            sum[i] +&#x3D; value;        &#125;    &#125;    int query(int index) &#123;        int ans &#x3D; 0;        for(int i &#x3D; index; i &gt; 0; i -&#x3D; lowbit(i)) &#123;            ans +&#x3D; sum[i];        &#125;        return ans;    &#125;    bool isCovered(vector&lt;vector&lt;int&gt;&gt;&amp; ranges, int left, int right) &#123;        for(auto range : ranges) &#123;            for(auto i &#x3D; range[0]; i &lt;&#x3D; range[1]; i++) &#123;                add(i, 1);            &#125;            &#125;        for(int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;            if(query(i) - query(i - 1) &lt;&#x3D; 0) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xxxxxxxxxx &#x2F;&#x2F;c++版本的解答class Solution {public:    int maxProduct(vector<string>&amp; words) {        int n &#x3D; words.size();        vector<int> dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) {            for(int j &#x3D; 0; j &lt; words[i].size(); j++) {                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - ‘a’));              }        }        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) {            for(int j &#x3D; i+1; j &lt; n; j++) {                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) {&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                }            }        }        return ans;    }};c++</int></string></p><h2 id="④线段树"><a href="#④线段树" class="headerlink" title="④线段树"></a>④线段树</h2><p>线段树应该是解决所有树状数组能够解决的一些相关问题，同时也是解决绝大部分的区间求和和查询的一个最有利的手段，有关线段树的学习，大家可以参考此篇：<a href="https://blog.csdn.net/huangzihaoal/article/details/81813454?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164973450016780366523945%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164973450016780366523945&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-81813454.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">线段树和树状数组</a>。本篇下面的代码仅供参考，因为sheepicce今天才稍微懂一点线段树，<font color="red"><strong>预计这周会总结一下线段树的一些东西哦！</strong></font></p><blockquote><p>const int N &#x3D; 55;<br>class Solution {<br>public:<br>struct Node {<br>       int l, r, cnt;<br>   };<br>   Node tr [N * 4];<br>   void pushup(int u) {<br>       tr[u].cnt &#x3D; tr[u &lt;&lt; 1].cnt + tr[u &lt;&lt; 1 | 1].cnt;<br>   }<br>   void build(int u, int l, int r) {<br>       tr[u].l &#x3D; l, tr[u].r &#x3D; r, tr[u].cnt &#x3D; 0;<br>       if(l !&#x3D; r)<br>       {<br>           int mid &#x3D; (l + r) &gt;&gt; 1;<br>           build(u &lt;&lt; 1, l, mid);<br>           build(u &lt;&lt; 1 | 1, mid + 1, r);<br>           pushup(u);<br>       }<br>   }<br>   &#x2F;&#x2F; 从 tr 数组的下标 u 开始，在数值 x 的位置进行标记<br>   void update(int u, int x) {<br>       if (tr[u].l &#x3D;&#x3D; x &amp;&amp; tr[u].r &#x3D;&#x3D; x) {<br>           tr[u].cnt &#x3D; 1;<br>       } else {<br>           int mid &#x3D; (tr[u].l + tr[u].r) &gt;&gt; 1;<br>           if (x &lt;&#x3D; mid) update(u &lt;&lt; 1, x);<br>           else update(u &lt;&lt; 1 | 1, x);<br>           pushup(u);<br>       }<br>   }<br>   &#x2F;&#x2F; 从 tr 数组的下标 u 开始，查询 [l,r] 范围内有多少个数值被标记<br>   int query(int u, int l, int r) {<br>       if (l &lt;&#x3D; tr[u].l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].cnt;<br>       int mid &#x3D; (tr[u].l + tr[u].r) &gt;&gt; 1;<br>       int ans &#x3D; 0;<br>       if (l &lt;&#x3D; mid) ans +&#x3D; query(u &lt;&lt; 1, l, r);<br>       if (r &gt; mid) ans +&#x3D; query(u &lt;&lt; 1 | 1, l, r);<br>       return ans;<br>   }<br>   bool isCovered(vector &lt;vector <int>&gt; &amp; rs, int l, int r) {<br>       build(1, 1, N);<br>       for (auto &amp;  cur : rs) {<br>           int a &#x3D; cur[0], b &#x3D; cur[1];<br>           for (int i &#x3D; a; i &lt;&#x3D; b; i++) {<br>               update(1, i);<br>           }<br>       }<br>       int tot &#x3D; r - l + 1 , cnt &#x3D; query(1, l, r);<br>       return tot &#x3D;&#x3D; cnt;<br>   }<br>};</int></p></blockquote><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>总之，虽然是一个简单的题目，但是还是有很多可以拓展的地方，这也是我需要慢慢去学习的！加油啊！冲鸭！</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结-3</title>
      <link href="/2022/04/10/%E5%91%A8%E6%80%BB%E7%BB%93-3/"/>
      <url>/2022/04/10/%E5%91%A8%E6%80%BB%E7%BB%93-3/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><h3 id="二、力扣的刷题"><a href="#二、力扣的刷题" class="headerlink" title="二、力扣的刷题"></a>二、力扣的刷题</h3><p>这周感觉上，是在数据结构上面下了点功夫吧，对c++的一些容器的概念还有一些用法有了更加清楚的一个认识，然后现在使用迭代器的时候也能够敢去用一些以前不敢用的一些写法。比如<font color="red">auto</font>的使用，迭代器中<font color="red">begin（）</font>的一些使用了，感觉还是比较好的。今天周日好像已经是坚持力扣刷题的第53天了，不知不觉这两个多月的时间吧，力扣的题目已经刷了120多道了，虽然自己还是挺菜的吧，但是感觉比之前有所进步了！</p><h4 id="①数据结构的学习"><a href="#①数据结构的学习" class="headerlink" title="①数据结构的学习"></a>①数据结构的学习</h4><p>这周主要学了一些数据结构，比如怎么用两个栈实现一个队列，链表的数组存取，链式存取，对于一颗树的BFS搜索的进行等。然后跟着做了三叶姐的很多“-+”题，我还记得就是那时候刷奇偶数的遍历的时候，虽然可能难度比当天每日一题的大吧，但是那个时候真的就看着看着就会了，虽然树这个数据结构还是没有去细学吧，骚年继续加油啊！</p><h4 id="②算法的学习"><a href="#②算法的学习" class="headerlink" title="②算法的学习"></a>②算法的学习</h4><p>这周对于算法应该大题来说有新也有旧，新的是学了一下<strong>树状的数组</strong>，但是线段树还没有去学，树状数组可能对于现在的我来说可能还没有特别的习惯，争取下次遇到题目的时候再多复习总结一下。然后就是旧的背包知识，之前对于一维背包知识的一个遍历顺序其实还是会有对应的存疑的，但是看了<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzU4NDE3MTEyMA==&scene=23&album_id=1751702161341628417&count=3#wechat_redirect">三叶姐这方面的总结</a>感觉对基础的背包有了比较深的印象了，当然看了一下状压dp，虽然看不懂呜呜，但是我相信以后会看得懂的哈哈哈！！</p><h3 id="三、课内任务"><a href="#三、课内任务" class="headerlink" title="三、课内任务"></a>三、课内任务</h3><h4 id="①c语言程序设计实验完成："><a href="#①c语言程序设计实验完成：" class="headerlink" title="①c语言程序设计实验完成："></a>①c语言程序设计实验完成：</h4><p>说真的这个实验花了蛮多的时间，其实还是因为自己太菜了，比如对于一些字符串连接，字符串寻找的函数使用非常的不熟悉，导致再重新学这一方面的时候花了蛮多额外的时间，就感觉基础没有大佬。在实验中遇到了很多的问题说真的，比如变量的重复定义，文件目录的创建等等，虽然最后通过各种询问解决了一些问题，但是我现在心里其实还是没有底的，毕竟很多东西查完之后，感觉我没有很彻底的了解到程序最底层的东西吧，希望后面能够在看c++prime的时候继续的巩固。</p><h4 id="②英语6级的复习："><a href="#②英语6级的复习：" class="headerlink" title="②英语6级的复习："></a>②英语6级的复习：</h4><p>其实按理来说我不应该说这个复习的事情的，因为我可能根本就没有复习。就好像6天有4天坚持了听了40min，还是因为自己听力太差了，所以拿听力的原文听了一遍又一遍，最终还是没能听出正确答案呜呜，然后有的时候就是本来说晚上做完事就听听力，然后一到十点多的时候，感觉一天好像学了不少东西，就玩玩手机，刷b站的视频，时间一晃而过，我的天，这周我感觉对时间的管理特别特别的差真的。</p><h3 id="四、一点决心"><a href="#四、一点决心" class="headerlink" title="四、一点决心"></a>四、一点决心</h3><p>其实之前在看星球的各位和我一样为了以后能够进一个好一点的大厂的人打卡和提问，这周印象最深的是北邮的一个同学吧，她现在大一，但是已经有了3个项目的参与，多个程序设计的奖项，然后每天会花5个小时在课内，5个小时在课外，而且已经刚刚通过了阿里的二面。说到这其实不是为了去把自己和这位大佬进行比较吧，但是当时看到的时候，真的感觉自己在时间管理方面，做得是真的挺差的。下周开始，我希望自己能够克服一些娱乐吧。就是先从小事做起，做到一天以内至少8个小时心思是完全在学习上的，而不是说，写完一题就看会微信聊会天，看会书就看点b站什么的吧！我希望下周日的总结日记，写到我的改变！毕竟时间还多，只要想去改变，那么什么时候都不算晚！！！</p><h3 id="五、新球打卡"><a href="#五、新球打卡" class="headerlink" title="五、新球打卡"></a>五、新球打卡</h3><h4 id="①周一"><a href="#①周一" class="headerlink" title="①周一"></a>①周一</h4><p>leetcode每日一题<br>大概懂了树状数组，并且自己实现了一遍</p><p>c++prime越看越看不懂了，特别看到类那一块，星球的uu们能给点建议吗？感觉看那个都有点劝退了。</p><p>操作系统看了线程</p><h4 id="②周二"><a href="#②周二" class="headerlink" title="②周二"></a>②周二</h4><p>英语六级听力40min，好像现在听力有点感觉了</p><p>力扣每日一题照常，开始刷数据结构的leetbook了，刷了3题今天</p><p>写了一篇树状数组的博客，下面有csdn关于这篇博客的网址，uu们可以看看，虽然我写得比较水</p><p>计算机操作系统看了三个调度算法（FCFS,SJF,HRRN），感觉还是比较有趣的</p><p>c++prime水完了第七章，类那一块真的有点不太懂，但是大概懂了点构造函数那一块，包括链表内部那个构造函数，知道怎么记忆了。</p><p><a href="https://blog.csdn.net/qq_60556896/article/details/123967025?spm=1001.2014.3001.5501">树状数组初学_sheep.ice的博客-CSDN博客</a> </p><h4 id="③周三"><a href="#③周三" class="headerlink" title="③周三"></a>③周三</h4><p>课内为主，上了一天课，补了补作业<br>力扣那题图论想不出好办法 明天进攻图论我说的<br>居然就没了哈哈哈哈</p><h4 id="④周四"><a href="#④周四" class="headerlink" title="④周四"></a>④周四</h4><p>被学校的数据文件实验继续折磨<br>开始看《算法竞赛入门》，对各种迭代器的使用又加深了一点<br>力扣照常每日一题<br>英语30min</p><h4 id="⑤周五"><a href="#⑤周五" class="headerlink" title="⑤周五"></a>⑤周五</h4><p>c++prime第八章<br>英语40min<br>两道bfs树的遍历<br>看了下竞赛入门经典一些数据结构</p><h4 id="⑥周六"><a href="#⑥周六" class="headerlink" title="⑥周六"></a>⑥周六</h4><p>终于搞完学校c语言设计的一个实验 写完了实验报告<br>每日一题（简单题）<br>看了三叶姐背包问题看了7章 对背包理解更深了<br>写了3h课内的东西<br>英语今天没看呜呜</p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组初探</title>
      <link href="/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/04/05/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、树状数组的初学"><a href="#一、树状数组的初学" class="headerlink" title="一、树状数组的初学"></a>一、树状数组的初学</h1><p>之前学习过前缀和和差分的一些知识就觉得挺神奇的，然后昨天刷到力扣的每日一题之后发现，好像&#x3D;&#x3D;树状数组&#x3D;&#x3D;在多区间的修改和查询方面很神奇，包括之后要学习的&#x3D;&#x3D;线段树&#x3D;&#x3D;（能解决所有树状数组的问题）可能会更加有收获吧。😁😁</p><hr><h1 id="二、一些小小的理解"><a href="#二、一些小小的理解" class="headerlink" title="二、一些小小的理解"></a>二、一些小小的理解</h1><h3 id="①lowbit的理解"><a href="#①lowbit的理解" class="headerlink" title="①lowbit的理解"></a>①lowbit的理解</h3><p>在线段数组里面有这么一个重要的函数，也是能够构造整个树状数组的<font color="red">核心</font>吧！代码只有一行，但是对于我这种萌新来说，刚开始还是很难理解的。代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;寻找一个数最低位的1int lowbit(int x) &#123;        return x &amp; -x;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个比较简单的例子，一个数为3，他的二进制表示为11，那么根据负数二进制的要求，-3的二进制，我们先求他的反码为00，最后+1得到补码为01，最后让11 &amp; 01 便取得 01，也就是最低位的第一个1，<strong>大家可以试一下，利用这个函数，最后得到的结果一定只会含有一个1在整个数里面</strong>;</p><hr><h1 id="三、树状数组的构建"><a href="#三、树状数组的构建" class="headerlink" title="三、树状数组的构建"></a>三、树状数组的构建</h1><p><img src="https://img-blog.csdnimg.cn/00946e0b43e9458e843fd7c0b90696d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树状数组"><br>大家可以看到，树状数组首先对应一个s数组（假设有8个元素），也就是一个求总和的数组，这个数组里面对应装下一些前缀和，而每一个s对应数都是连续的，这也就为我们后面提供区间和利用<strong>前缀和</strong>的思想提供了很好的办法！<br>&#x3D;&#x3D;当然这里有要注意的点：&#x3D;&#x3D; 就是我们的s数组必须从1作为下标开始，也就是8个元素我们要开s[9]的空间，因为lowbit(0)是不存在最低位1的会造成<strong>无限循环</strong>的风险。大家可能不太理解，这个数组里面为什么能够按照这样的数字进行相加，我们看下面的图：<br><img src="https://img-blog.csdnimg.cn/5c68b3ed52e0422f9a8dde06069d7c9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="二进制表示"><br>从上面的图，我们可以知道，每个s对应的下标，都是从某个下标i，通过加上lowbit(i),并且在每次演变的时候，让$S_i$加上对应的num[i - 1] 的数(因为num数中的下标是从0开始的)，最后就变成了第一张图的样子，也就是接下来要讲的区间的更新。</p><hr><h1 id="四、区间的查询以及更新"><a href="#四、区间的查询以及更新" class="headerlink" title="四、区间的查询以及更新"></a>四、区间的查询以及更新</h1><h3 id="①区间的更新："><a href="#①区间的更新：" class="headerlink" title="①区间的更新："></a>①区间的更新：</h3><p>因为有了上面的铺垫，我们直接放上，s数组更新的一个代码，也就是如何让s数组存上对应相关的值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;添加和到对应的树状数组    void add(int x, int val) &#123;        for(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) &#123;            sum[i] +&#x3D;  val;   &#x2F;&#x2F;这里的val其实就是num[i - 1];        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过上面的操作之后，我们就<font color="green">完成了s数组的构建</font>，那么如果题目要求，改掉num数组里面的某个数的话，我们只需要让那个数所在的s也同时的更新就好，像下面一样:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void update(int index, int val) &#123;&#x2F;&#x2F;这里的index要+1，因为num数组的下标从0开始        add(index + 1, val - nums[index]);        nums[index] &#x3D; val;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②区间的查询"><a href="#②区间的查询" class="headerlink" title="②区间的查询"></a>②区间的查询</h3><p>区间的查询，其实有点像更新的逆过程，比如我们要知道$\sum_{i&#x3D;0}^{6}num[i]$的总和也就是说如何要求出$ S_7 +  S_6  + S_4 $的值（这里大家可以对照一下上面的图）。<strong>7 - 6 - 4 不就是 111 - 110 - 100</strong>的过程吗？那其实就是每次让下标为i的数减去lowbit(i)，<font color="red">然后在此过程中去加上S[i]的值，最后就可以得到原始下标为index的前缀和了，根据区间前缀和计算的方式，最终就可以知道一段区间的和了。</font></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;计算从下标0- x-1的前缀和int query(int x) &#123;        int s &#x3D; 0;        for(int i &#x3D; x; i &gt; 0; i -&#x3D; lowbit(i)) &#123;            s +&#x3D; sum[i];        &#125;        return s;    &#125;&#x2F;&#x2F;计算区间的和(不了解前缀和的同学可以先了解一下前缀和)int sumRange(int left, int right) &#123;&#x2F;&#x2F;因为原始的下标从0开始，那么对应区间和的下标要加1        return query(right + 1) - query(left);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="五、力扣的原题"><a href="#五、力扣的原题" class="headerlink" title="五、力扣的原题"></a>五、力扣的原题</h1><h3 id="①原题贴图"><a href="#①原题贴图" class="headerlink" title="①原题贴图"></a>①原题贴图</h3><p><img src="https://img-blog.csdnimg.cn/48adae96d9104c9c9c868b5332bb8eb0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="树状数组模板题"></p><h3 id="②AC的代码全贴"><a href="#②AC的代码全贴" class="headerlink" title="②AC的代码全贴"></a>②AC的代码全贴</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NumArray &#123;public:    vector&lt;int&gt; sum;    &#x2F;&#x2F;记录最低位的1    int lowbit(int x) &#123;        return x &amp; -x;    &#125;    &#x2F;&#x2F;添加和到对应的树状数组    void add(int x, int val) &#123;        for(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) &#123;            sum[i] +&#x3D;  val;        &#125;    &#125;    int query(int x) &#123;        int s &#x3D; 0;        for(int i &#x3D; x; i &gt; 0; i -&#x3D; lowbit(i)) &#123;            s +&#x3D; sum[i];        &#125;        return s;    &#125;    vector&lt;int&gt; nums;    int n;    NumArray(vector&lt;int&gt;&amp; nums) &#123;        this-&gt;nums &#x3D; nums;        n &#x3D; nums.size();        sum.resize(n + 1, 0);        for(int i &#x3D; 0; i &lt; n; i++) &#123;            add(i + 1, nums[i]);        &#125;    &#125;        void update(int index, int val) &#123;        add(index + 1, val - nums[index]);        nums[index] &#x3D; val;    &#125;        int sumRange(int left, int right) &#123;        return query(right + 1) - query(left);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="六、-参考文档"><a href="#六、-参考文档" class="headerlink" title="六、 参考文档"></a>六、 参考文档</h1><p><a href="https://blog.csdn.net/bestsort/article/details/80796531">参考1 树状数组的详细教程</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/">参考2 力扣胡歌的题解</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">参考3 力扣三叶姐的题解</a></p>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结(2)</title>
      <link href="/2022/04/03/%E5%91%A8%E6%80%BB%E7%BB%93-2/"/>
      <url>/2022/04/03/%E5%91%A8%E6%80%BB%E7%BB%93-2/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到<strong>一周一总结</strong>的栏目！！希望能够和大家一起努力！</p><hr><h3 id="二、leetbook的完结"><a href="#二、leetbook的完结" class="headerlink" title="二、leetbook的完结"></a>二、leetbook的完结</h3><p>算是看完了的第一本leetbook吧，还是很支持三叶姐的。看完这本书的最大感受就是对动态规划有了更加深刻的一个理解吧，准备下周开始看三叶姐的背包问题的总结了。希望能够变得越来越强吧！</p><p>极力推荐**<a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/rt49s5/">三叶姐的第一本leetbook</a>**！！</p><p><img src="https://img-blog.csdnimg.cn/a2ca59a49a0c4c39a46d978111403d41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h3 id="三、知识星球的打卡"><a href="#三、知识星球的打卡" class="headerlink" title="三、知识星球的打卡"></a>三、知识星球的打卡</h3><h5 id="①Day-5，周一"><a href="#①Day-5，周一" class="headerlink" title="①Day 5，周一"></a>①Day 5，周一</h5><p>平平无奇的一天，但又是重新启航的一天。早上的时候终于把博客初步搭建好了，然后啥事也没干。<br>中午的时候忘记调闹钟了，一觉睡到了3点多，然后起来开始刷力扣，这是第39天了，加油啊骚年。写完力扣的题目，做了三叶姐的拓展，写了篇博客<a href="https://sheepice.github.io/">https://sheepice.github.io/</a><br>大家可以看看<br>晚上就继续看c++prime，看了两个多小时，好像对c++的容器还有一些变量的设置有了一点眉目，希望这一周可以好好总结一下，发一篇新的博客<br>呆会手机锁机<br>我要开始复习六级啦！</p><h5 id="②Day6，周二"><a href="#②Day6，周二" class="headerlink" title="②Day6，周二"></a>②Day6，周二</h5><p>今天的力扣每日一题很可惜没能第一时间想出来，当知道是滑动窗口的一个模板题的时候，狠狠的觉得自己题目刷少了哈哈哈。当然还是写了一篇博客的：<a href="https://sheepice.github.io/%E2%80%8B%E2%80%8B">https://sheepice.github.io/​​</a></p><p>早上起来听了六级听力，我从来没有发现英语那么难学啊呜呜。</p><p>下午的时候把c++prime的第四章看完了。</p><p>哦对了，早上的时候，我看了操作系统看了差不多1个多小时的视频，刚开始还觉得这样的课程比较无聊，但是王道那个老师举的例子真的好好玩啊哈哈哈！</p><p>晚上的话就是自己的姨妈生日，翘了一节计算机思维课去帮她过生日，不过好像那一节课讲完了好多c++的东西[流泪]。不过我也是好好的展现了一波社交能力[呲牙]</p><p>回来的时候觉得今天好像一天都没干什么，就花了点时间看了一下数据结构和算法分析，对时间复杂度有了更深刻的理解。然后看到了那个最大子序列和用递归的写法，不得不说，递归这个东西神秘而又奇妙啊[呲牙]</p><p>待会再背背单词还有写写英语翻译，几天都没睡好了，争取今天能睡一个好好的觉[呲牙]</p><h5 id="③Day7-周三"><a href="#③Day7-周三" class="headerlink" title="③Day7 周三"></a>③Day7 周三</h5><p>今天发了一篇生活的博客，有兴趣的uu们可以去看看sheepice的博客​​</p><p>c++prime看了第六章还差一点</p><p>每日一题摆烂，有思路但是对数据结构不太熟悉啊，不太知道怎么用优先队列</p><p>英语听力40min 待会还会背单词</p><p>操作系统看完第一章</p><p>今天好摆啊<img src="file:///C:\Users\0604520\AppData\Roaming\Tencent\QQTempSys\CE_6{RQP]3{T@BAJGTH{IW4.png" alt="img"></p><h5 id="④Day8-周四"><a href="#④Day8-周四" class="headerlink" title="④Day8 周四"></a>④Day8 周四</h5><p>英语听力40min，总共25错7，继续努力<br>lc三月打卡目标完成<br>三叶姐的最短路径和2（困难），记录最小和第二小元素<br>c++prime第六章扫完<br>数据结构看了点列表，那本书有点难，打算开leetbook结合一下<br>操作系统看了进程：了解了一些进程组织，进程状态和进程转换的知识，包括对操作系统内核的原语有了初步印象<br>大物第五章习题刷完，大物慕课刷完</p><h5 id="⑤Day9-周五"><a href="#⑤Day9-周五" class="headerlink" title="⑤Day9 周五"></a>⑤Day9 周五</h5><p>每日一题，写了篇博客<a href="https://sheepice.github.io/%E2%80%8B%E2%80%8B">https://sheepice.github.io/​​</a></p><p>最短路径二hard题目，记忆化搜索</p><p>栈和队列的实现，链表的索引实现<br>今天想休息会，待会和朋友打游戏去了</p><h5 id="⑥Day10-周六"><a href="#⑥Day10-周六" class="headerlink" title="⑥Day10 周六"></a>⑥Day10 周六</h5><p>被电工技术折磨住了<br>刷了一个记忆化搜索题<br>三叶姐的路径leetbook明天可以刷完<br>英语单词<br>摆烂休息</p><hr><h3 id="四、运动任务"><a href="#四、运动任务" class="headerlink" title="四、运动任务"></a>四、运动任务</h3><p>中规中矩吧，每天跑跑步，跳跳绳什么的，每天坚持一点运动还是很不错滴！</p><hr><h3 id="五、一点小倾诉"><a href="#五、一点小倾诉" class="headerlink" title="五、一点小倾诉"></a>五、一点小倾诉</h3><p>就今天不是一周的最后一天了嘛，其实从前天开始，就感觉到自己明显的有点不在状态了。就感觉有好多我自己说不清楚的压力在我的身上，无论是学业的还是生活上的，也不知道是不是因为太久没有和身边的人进行沟通了，太久没有和朋友们进行相聚了，内心老是感觉憋着无数的话说不出来，突然就觉得好像有些累了。不知道大家有没有这样一种情况，就是会突然那一下没有了动力，然后就感觉莫名其妙的空虚感，有的uu们可以来一起聊聊天哈！就其实一直想做一个很乐观很乐观的人，但是可能自己性格的缘故，越想着去说，想把一些开心或者自己想说的话说出去，但是就会有点想展示自己，就是我无比感受到这样的展现挺空虚的，我估计还是心灵在作祟吧！可恶的疫情啊，你什么时候能够对我们善良一点，我真的很想回到自己的学校，见到熟悉的朋友。到那时，也许望着天边的一片片云，都觉得很有味道吧。</p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题3</title>
      <link href="/2022/04/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%983/"/>
      <url>/2022/04/01/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><h3 id="二、leetcode每日一题"><a href="#二、leetcode每日一题" class="headerlink" title="二、leetcode每日一题"></a>二、leetcode每日一题</h3><p>今天的每日一题难度不大，主要想记录一下关系哈希表的容器相关写法吧！</p><p><img src="https://img-blog.csdnimg.cn/3f3ea20f3f3246cb883ad941a49020dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h5 id="①思路："><a href="#①思路：" class="headerlink" title="①思路："></a>①思路：</h5><p>采用哈希表记录下来所有出现过的数和对应的次数，然后利用<strong>绝对值大小进行排序</strong>（这个排序可以方便我们对表进行一次遍历，只需要看arr[i]对应的arr[i] * 2的次数是不是比前者大，即满足前者能够充分的匹配后者，然后一旦不满足就return false就好了的。</p><hr><h5 id="②解答："><a href="#②解答：" class="headerlink" title="②解答："></a>②解答：</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canReorderDoubled(vector&lt;int&gt;&amp; arr) &#123;         unordered_map&lt;int, int&gt; cnt;        for (int x : arr) &#123;            ++cnt[x];        &#125;        if (cnt[0] % 2) &#123;            return false;        &#125;        vector&lt;int&gt; vals;        vals.reserve(cnt.size());        for (auto &amp;[x, y] : cnt) &#123;            vals.push_back(x);        &#125;        sort(vals.begin(), vals.end(), [](int a, int b) &#123; return abs(a) &lt; abs(b); &#125;);        for (int x : vals) &#123;            if (cnt[2 * x] &lt; cnt[x]) &#123; &#x2F;&#x2F; 无法找到足够的 2x 与 x 配对                return false;            &#125;            cnt[2 * x] -&#x3D; cnt[x];        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="③学到的东西"><a href="#③学到的东西" class="headerlink" title="③学到的东西"></a>③学到的东西</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;应该都是容器的相关知识，但是我还没看到，就先记录一下1.    &#x2F;&#x2F;将哈希表里面的第一个元素放到数组里面，    for (auto &amp;[x, y] : cnt) &#123;            vals.push_back(x);        &#125;2.    &#x2F;&#x2F;直接在sort里面进行比较函数的书写    sort(vals.begin(), vals.end(), [](int a, int b) &#123; return abs(a) &lt; abs(b); &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、三叶姐的题解"><a href="#三、三叶姐的题解" class="headerlink" title="三、三叶姐的题解"></a>三、三叶姐的题解</h3><p>xxxxxxxxxx &#x2F;&#x2F;c++版本的解答class Solution {public:    int maxProduct(vector<string>&amp; words) {        int n &#x3D; words.size();        vector<int> dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) {            for(int j &#x3D; 0; j &lt; words[i].size(); j++) {                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - ‘a’));              }        }        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) {            for(int j &#x3D; i+1; j &lt; n; j++) {                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) {&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                }            }        }        return ans;    }};c++</int></string></p><p><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/">三叶姐的题解</a></p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活分享1</title>
      <link href="/2022/03/30/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB1/"/>
      <url>/2022/03/30/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p>一直认为生活不应该只有学业还有各种方面的压力，一定要有属于自己的诗和远方，开启生活篇的博客就是希望能够分享一下sheepice在生活里面遇到的很多很多事情吧！也相当于没有写技术博客的一个补充吧哈哈！</p><h3 id="二、《朋友请听好》"><a href="#二、《朋友请听好》" class="headerlink" title="二、《朋友请听好》"></a>二、《朋友请听好》</h3><p><img src="https://pics1.baidu.com/feed/d788d43f8794a4c2f670bf9a1b00dfdcac6e3929.jpeg?token=8b27736236d409e565c7c4c01d6aa0cd"></p><p>这是一档我很喜欢的综艺，说是一个综艺节目但是我更觉得它的意义在于一个情感上的慰藉港湾，在这里面有很多很多温暖的声音，有很多很多暖心的故事。当然在这里面我也收获了很多很多的慰藉！</p><h5 id="①“永远要相信世上的善意”"><a href="#①“永远要相信世上的善意”" class="headerlink" title="①“永远要相信世上的善意”"></a>①“永远要相信世上的善意”</h5><p>一位打电话来的女生，因为是自己一人在外打拼，所以自己就租了一个单间的房子，而有段时间她和邻居发生了争执。邻居住着一家，有着一个已经哑了的老奶奶，还有一个可爱的小孩。女生每次回家的时候，都会发现自己的家门口摆放着一双干净但又很破旧的皮鞋，因为是一个人，回家看到这样的情况，一定会有些恐惧的感觉。有一天，女生也没忍住，就去敲了邻居家的门，对着奶奶(情绪激动地)说到这样的事情，也许是因为太突然，女生觉得可能吓到老奶奶了，她看着老奶奶好像被吓得说不出话，因此也没有继续激动下去，而是提醒之后就走了。可是当天回来之后，那一双皮鞋依旧整整齐齐地摆放在自己家的门前，女生正无语的时候，看到鞋子里面有着一张小孩子写的纸条:”阿姨你好，我的奶奶她不能说话。我的爷爷走了，家里就剩下爷爷的这一双皮鞋，奶奶知道你是一个人住在这里，担心你的安全，所以把爷爷的皮鞋放在你的门口…….”</p><p><strong>我的描述可能不会太感动，但是当时听到最后的纸条内容的时候，我是真的一下也没有绷住，眼泪很自热而然地就流了下来。那时的我就突然觉得这个世界真的很好，真的很好，无论是最亲近的人还是陌生的人，他们也许无时无刻地在对你表示着善意，而请我们也要同样地对这个世界，对这个世界的每一个人保持善意！</strong></p><h5 id="②”你愿意和我建造一个图书馆吗？“"><a href="#②”你愿意和我建造一个图书馆吗？“" class="headerlink" title="②”你愿意和我建造一个图书馆吗？“"></a>②”你愿意和我建造一个图书馆吗？“</h5><p>因为故事很长，所以希望看到此篇博客的uu们可以到<a href="https://b23.tv/qzMpMH7">朋友请听好</a>这里去看！我深深被女生最后的英文誓词感动了，不知道是不是一时兴起，但是我觉得英文得好好学：</p><ul><li><p>英文誓词</p><ul><li><p>For the first, I love you deeply and passionately that I have felt for no one else in this life.</p></li><li><p>You said “早上好” this morning with your awkward Chinese. And I thought I can’t imagine myself love you more than I do today. But I thought the same way yesterday.</p></li><li><p>And if it astonished you, it almost frightened me as well.</p></li><li><p>It’s just. I was not such an fool even once hoped. Aspired, dreamed that one could find everything one want in a person.</p></li><li><p>And yet in you, I found everything.</p><p>…….</p></li></ul></li></ul><p><strong>读至此，我渴望着自己也能够变得更加的温柔，善良等等，因为一生的遇见，遇见的所有人，还有你，是多么多么的不容易啊。就像最后唱到的《慢慢喜欢你》,歌曲温柔，听着听着，就幻想到了后面的一生。</strong></p><h3 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h3><p>虽然当下的人包括自己真的在很多很多时候，想要快一点，再快一点。也许是快一点找到喜欢的一份工作，也许是快一点找到自己喜欢的人，可是殊不知，美好是一直在身边的。走得越快，真的能够抓住吗？</p>]]></content>
      
      
      <categories>
          
          <category> 生活篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题2</title>
      <link href="/2022/03/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%982/"/>
      <url>/2022/03/29/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><hr><h3 id="二、leetcode每日一题"><a href="#二、leetcode每日一题" class="headerlink" title="二、leetcode每日一题"></a>二、leetcode每日一题</h3><p><img src="https://img-blog.csdnimg.cn/39df104b32574cbbac56a8e175e46cc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="滑动窗口题目"></p><p>说实话，这一题在刚开始用双指针的时候，是有些地方没有想明白的，比如当最后的右指针移动到某个位置把k次数用完后，左指针应该移动到哪个位置，所以开始死磕了好久，最后也是积累了这样一种滑动窗口的办法吧。其实就是不要等右指针移到位才开始计算结果，边移动的时候就可以开始计算了，利用维护一个sum值，当sum依然小于k的时候，右指针就可以一直往后面移动，sum也一直++，知道他大于k的那一刻，我们的left就需要移动到他等于k的地方。那么这一题和后面要-+(三叶姐的简单题加餐)的题目是几乎一样的，只不过这题是需要计算最多有多少个“F”和“T”最后取两者的最大值就是答案啦！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string s;    int jl;    int maxConsecutiveAnswers(string answerKey, int k) &#123;        s &#x3D; answerKey;        jl &#x3D; k;        int ans &#x3D; 0;        ans &#x3D; max(getmax(&#39;T&#39;), getmax(&#39;F&#39;));        return ans;    &#125;    int getmax(char ss) &#123;        int n &#x3D; s.size();        int sum &#x3D; 0;        int as &#x3D; 0;        for(int i &#x3D; 0, j &#x3D; 0; j &lt; n; j++) &#123;            &#x2F;&#x2F;不等于ss时，翻牌操作++；            sum +&#x3D; (s[j] !&#x3D; ss);            &#x2F;&#x2F;翻牌的操作已经用空了            while(sum &gt; jl) &#123;                sum -&#x3D; (s[i] !&#x3D; ss);                i++;            &#125;            &#x2F;&#x2F;边走边记录下来答案            as &#x3D; max(as, j - i + 1);        &#125;        return as;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、-套餐（简单题加餐）"><a href="#三、-套餐（简单题加餐）" class="headerlink" title="三、-+套餐（简单题加餐）"></a>三、-+套餐（简单题加餐）</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247486241&idx=1&sn=609ca05e6e21a72023172b52d0af0a75&chksm=fd9ca03ecaeb2928018ef5b2faf20b170ae123813eec30962d2ea2d3c93e78e54ddde0d51c87&cur_album_id=1805384400772087811&scene=189#wechat_redirect">最大连续1的个数</a></p><p>上方来自三叶姐的题解，里面涉及到dp做法；二分加前缀和；还有今天的滑动窗口，非常的厉害！！</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题1</title>
      <link href="/2022/03/28/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%981/"/>
      <url>/2022/03/28/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice开启新的篇章了，虽然现在比较忙，但是如果有空，且写到一些比较有启发的力扣题的时候希望能够发一点点题解，毕竟三叶姐坚持了那么久，也给我有了很好的榜样作用！</p><p><a href="https://blog.csdn.net/qq_60556896/">sheepice的CSDN地址</a>：大家感兴趣也可以去里面，说不定能学到一点东西哦！</p><hr><h3 id="二、leecode每日一题"><a href="#二、leecode每日一题" class="headerlink" title="二、leecode每日一题"></a>二、leecode每日一题</h3><h5 id="①首先是今天的每日一题，题目如下："><a href="#①首先是今天的每日一题，题目如下：" class="headerlink" title="①首先是今天的每日一题，题目如下："></a>①首先是今天的每日一题，题目如下：</h5><p><img src="https://img-blog.csdnimg.cn/69c46960dcf04186a11aab308856d966.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="交替二进制"></p><h5 id="②题目解答（1）"><a href="#②题目解答（1）" class="headerlink" title="②题目解答（1）"></a>②题目解答（1）</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;版本1，逐步的进行判断class Solution &#123;public:    bool hasAlternatingBits(int n) &#123;        int prev &#x3D; 100;  &#x2F;&#x2F;因为二进制每一位不可能超过2，所以prev比2大就好        while (n !&#x3D; 0) &#123;            int cur &#x3D; n &amp; 1;    &#x2F;&#x2F;当前判断的位数            if (cur &#x3D;&#x3D; prev) &#123;  &#x2F;&#x2F;如果与上一位相等就不满足                return false;            &#125;            prev &#x3D; cur;         &#x2F;&#x2F;前缀等于当前，进行下一次的判断            n &gt;&gt;&#x3D; 1;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="③题目解答（2）"><a href="#③题目解答（2）" class="headerlink" title="③题目解答（2）"></a>③题目解答（2）</h5><p>因为位运算的性质，所以这题其实可以几行代码就解决的。例如一个二进制数为101，如何判断他是交替的呢。首先令u&#x3D;101，然后u &gt;&gt; 1是等于010的，这一步可以看成让一个本来是101交替的，变成010交替，那么u^(u&gt;&gt;1)等于111，也就是说对于交替进行的数字，必然有其本身抑或本身右移一位后得到的结果位数全部为1!!</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;版本二：利用位运算的相关性质class Solution &#123;public:    bool hasAlternatingBits(int n) &#123;        long a &#x3D; n ^ (n &gt;&gt; 1);        &#x2F;&#x2F;a加1后如果为真，111变成1000与原数按位与必然为0        return (a &amp; (a+1)) &#x3D;&#x3D; 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、三叶姐的拓展"><a href="#三、三叶姐的拓展" class="headerlink" title="三、三叶姐的拓展"></a>三、三叶姐的拓展</h3><p>这一题之后三叶姐给了一个位运算的入门专题，也是状态压缩的一个入门题目：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490530&idx=1&sn=f53d29ff37a37b41408a83e10bff0ee6&chksm=fd9cb0fdcaeb39eb014629bce596c667600ad22791f5c4e50307da0090c8777caaefadf85948&mpshare=1&scene=23&srcid=0328BdmtGDal2kCsgWYe74cB&sharer_sharetime=1648433142477&sharer_shareid=700066f28b945e5d1cd5d3f0173f1539#rd">【位运算专题】经典「状态压缩 + 位运算」入门题</a></p><h5 id="①题目如下："><a href="#①题目如下：" class="headerlink" title="①题目如下："></a>①题目如下：</h5><p><img src="https://img-blog.csdnimg.cn/45a0dd6be54f4da8946facbd537559b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2hlZXAuaWNl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="状态压缩入门"></p><h5 id="②解答如下"><a href="#②解答如下" class="headerlink" title="②解答如下"></a>②解答如下</h5><p>因为数据给的比较小，然后要判断的只是小写字母，因此只需要把每一个单词小写字母出现的情况放在一个二进制数下进行表示就好了的！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;c++版本的解答class Solution &#123;public:    int maxProduct(vector&lt;string&gt;&amp; words) &#123;        int n &#x3D; words.size();        vector&lt;int&gt; dp(n,0);        for(int i &#x3D; 0; i &lt; n; i++) &#123;            for(int j &#x3D; 0; j &lt; words[i].size(); j++) &#123;                char u &#x3D; words[i][j];                &#x2F;&#x2F;进行每一位1的存储                dp[i] |&#x3D; (1 &lt;&lt; (u - &#39;a&#39;));              &#125;        &#125;        int ans &#x3D; 0;        &#x2F;&#x2F;从头比较到尾，满足无重复数字就进行相关的答案记录        for(int i &#x3D; 0; i &lt; n - 1; i++) &#123;            for(int j &#x3D; i+1; j &lt; n; j++) &#123;                if((dp[i] &amp; dp[j]) &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;这里取最大值的地方可以注意一下&#x2F;&#x2F;可以用ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));&#x2F;&#x2F;因为.size()结构是返回无符号类型的int所以力扣上会报错！！！                    if(words[i].size() * words[j].size() &gt; ans)                    ans &#x3D; words[i].size() * words[j].size();                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结（1）</title>
      <link href="/2022/03/27/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
      <url>/2022/03/27/%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>sheepice的CSDN博客地址：<a href="https://blog.csdn.net/qq_60556896/">CSDN地址</a></p><p>欢迎大家来到&#x3D;&#x3D;一周一总结&#x3D;&#x3D;的栏目！！希望能够和大家一起努力！</p><h3 id="二、学习任务"><a href="#二、学习任务" class="headerlink" title="二、学习任务"></a>二、学习任务</h3><h5 id="①力扣的刷题任务"><a href="#①力扣的刷题任务" class="headerlink" title="①力扣的刷题任务"></a>①力扣的刷题任务</h5><p>这周的力扣好像都没有出太难的题目，唯一令我印象比较深刻的是一道困难题<a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">字典序的第k小的数字</a>，这个题目的模仿了字典树的一个遍历过程，当时真的没有想到，但是其实还是有点眉目的，虽然最后还是没写出来吧。遗憾的是，自己还是没有把字典树给学精通来！</p><p><img src="https://img-blog.csdnimg.cn/b15450e05169480fbb75e160274b782a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;贴一下这个题目的一个求解过程吧class Solution &#123;public:    long min(long a, long b)&#123;        if(a &gt;&#x3D; b) return b;        return a;    &#125;    &#x2F;&#x2F;找到此时的数字的所有树节点的个数    int findnums(long cur,int n)&#123;        long next &#x3D; cur+1;        long sumtox &#x3D; 0;        while(cur &lt;&#x3D; n)&#123;            sumtox +&#x3D; min(next-cur,n-cur+1);            next *&#x3D; 10;            cur *&#x3D; 10;        &#125;        return (int) sumtox;    &#125;    int findKthNumber(int n, int k) &#123;        long cur &#x3D; 1;        k--;        while(k &gt; 0)&#123;            int nodes &#x3D; findnums(cur, n);            &#x2F;&#x2F;如果结点数小于此时数量，直接在同一层搜索            if(k &gt;&#x3D; nodes)&#123;                k -&#x3D; nodes;                cur++;            &#125;            &#x2F;&#x2F;否则到树的下一层搜索            else&#123;                cur *&#x3D; 10;                k--;            &#125;        &#125;        return (int)cur;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;当时反正是想不出来的，希望以后看到总结的时候能够写出来这题吧！&#x3D;&#x3D;</p><p><strong>过完本周就是坚持力扣刷题38天了，当然这个连续刷题是有水分的，有的时候遇到完全没有思路的题目就直接跳过去了，蒟蒻太菜，求大佬们带带！</strong></p><hr><h5 id="②leetbook的学习"><a href="#②leetbook的学习" class="headerlink" title="②leetbook的学习"></a>②leetbook的学习</h5><p>本周还跟着三叶姐出的书，学了一点路径dp的知识，虽然在其中有很多以前写过的题目，但是再次刷题的时候还是会遇到各种各样的问题，当然收获最大的是，自己得到了某些方面的拓展，关于这一周的一个拓展，我也写在了我的CSDN博客里面，便于以后的查找：<a href="https://blog.csdn.net/qq_60556896/article/details/123754413?spm=1001.2014.3001.5502">最短路径拓展</a>！！</p><p>下面也是三叶姐的书，感兴趣的同学可以点这：<a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/r8h07j/">dp路径学习</a></p><p><img src="https://img-blog.csdnimg.cn/56991cd79f994e238c58468699a18170.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><hr><h5 id="③课内的学习"><a href="#③课内的学习" class="headerlink" title="③课内的学习"></a>③课内的学习</h5><p>课内其实这周就中规中矩吧，但是因为自己比较的笨，所以会花更多时间去把老师没有布置的题目写完，比如大物第二和第四章的课后习题都刷了一遍，等等。然后就是本来这周想要去开始六级的准备了，但是本人准备了个寂寞，每天都不太想背单词，听听力，我希望赶紧能够养成每天复习点英语的习惯，希望下一次的周记能够写到我英语有一直在复习哈哈哈！！</p><hr><h5 id="④博客的搭建"><a href="#④博客的搭建" class="headerlink" title="④博客的搭建"></a>④博客的搭建</h5><p>虽然自己对网页的方方面面都不知晓，但是为了让自己的博客目前看起来像点样子，还是抽出了周日的一天时间去美化自己的博客吧，就像大家看到的这个亚子，虽然还有些功能没有完善，但是我真的不太会怎么完善了，希望会的uu们可以交一下子我！</p><hr><h3 id="三、运动任务"><a href="#三、运动任务" class="headerlink" title="三、运动任务"></a>三、运动任务</h3><p>这周前几天比较冷还下雨，所以鸽了几天运动，但是后面有每天都去跑步和跳绳哦，我记得这周虽然没有减肥太多，但是体重保持得相当不错。还记得跳绳的时候，跳双摇，旁边的小弟弟召集了他的伙伴到身边围观，哈哈哈哈哈哈哈哈哈哈哈，当时的我真的会有点羞涩的！！</p><h3 id="四、创新任务"><a href="#四、创新任务" class="headerlink" title="四、创新任务"></a>四、创新任务</h3><h5 id="①加入了Carl哥的知识星球："><a href="#①加入了Carl哥的知识星球：" class="headerlink" title="①加入了Carl哥的知识星球："></a>①加入了Carl哥的知识星球：</h5><p>感兴趣的同学可以一起加入哦，曾听一位学姐说，与其花钱在各种不必须的物品之上，不如多知识付费去提高自己的能力！！加入星球后我发现了很多小伙伴有着跟自己相同的困惑，Carl哥非常好的，就是他会给每一个人进行解答，包括传授各种各样的知识和学习路线，值得大家入手！！</p><p><strong>下面是我得到的回答，收获很丰富</strong></p><p><img src="https://img-blog.csdnimg.cn/443ee98d271e4f50ade1640f701b0723.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="②加了Carl哥还有三叶姐的微信"><a href="#②加了Carl哥还有三叶姐的微信" class="headerlink" title="②加了Carl哥还有三叶姐的微信"></a>②加了Carl哥还有三叶姐的微信</h5><p>&#x3D;&#x3D;虽然可能就是刚开始互相不认识的人，但是总是觉得已经认识了好久哈哈&#x3D;&#x3D;</p><hr><h3 id="五、总结-贴图"><a href="#五、总结-贴图" class="headerlink" title="五、总结+贴图"></a>五、总结+贴图</h3><p>一周下来真的很累很累，但是其实过得真的非常的充实，希望自己接下来可以不嫌麻烦的，继续坚持的做自己喜欢的事情，就像一直保持热爱的她！</p><p><img src="https://img-blog.csdnimg.cn/09100c5cafb848b4b0dc0220a6882b81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JKf6JK7c2hlZXA=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
